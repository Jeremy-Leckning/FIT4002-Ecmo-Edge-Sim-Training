#include <cmath>
#include <string.h>

class ECMO {
    Pump pump;
};




class Pump {
public:
    void start_pump(int rpm) {
        this->rpm = rpm;
    };

    bool is_on() {
        return e_switch;
    };

    void advance_pump() {
        prevFlowAcceleration = flowAcceleration;
        flowAcceleration = totalGeneratedPressure() / 0.04;

        pumpFlow =  0.5 * (flowVelocity + flowAcceleration) * (1/refreshRate); // Integrator block

        // pumpFlow = 0.5 * (flow Acceleration - prevFlowAcceleration) * (1/refreshRate);

        iteration++;
    }

    void addRightAtriumBloodPressure(double value)
    {
        rightAtriumBloodPressure[iteration % (5 * refreshRate)] = value;
    }

    void addAorticPressure(double value)
    {
        aorticPressure[iteration % (5 * refreshRate)] = value;
    }

    void toggleSwitch() {
        e_switch = !e_switch;
    }

    void setRpm(int rpmValue) {
        this->rpm = rpmValue;
    }

    void setKinkedReturnLine(bool present) {
        kinkedReturnLine = present;
    }

    void setOxygenatorMembraneThrombosis(bool present) {
        oxygenatorMembraneThrombosis = present;
    }

    void setBloodVesselSuction(bool present) {
        bloodVesselSuction = present;
    }

  std::string getStats() {
        std::stringstream stats;
        stats << "switch: " << e_switch;
        stats << "iteration:" << iteration;
        stats << "rpm:" << rpm;
        stats << "pump flow:" << pumpFlow;
        stats << "arterialPressure" << aorticPressure[25];

        return stats;
    }
    
private:
    // ECMO controls variables
    bool e_switch = false;
    int iteration = 0;
    int rpm = 0;
    double pumpFlow = 0;
    double pumpFlow_litrePerMinute = pumpFlow * 0.06;
    double pumpFlow_m3PerSecond = pumpFlow_litrePerMinute * 1.66667e-5; // pump flow in m3 per second
    int refreshRate = 50; // in Hz

    double flowVelocity = 58.65;
    double flowAcceleration;
    double prevFlowAcceleration;
    
    // Array size 250 to hold values for 50Hz refresh rate for 5 secnds
    double rightAtriumBloodPressure[250]; // Using pulmonary capillaries wedge pressure for right atrium blood pressure
    double aorticPressure[250]; //ranging around 40-50

    // Tubing variables
    double tubeRadius = 0.0047625;
    double tube1Length = 1.8;
    double tube2Length = 0.8;
    double tube3Length = 1.8;

    // Cannula In variables
    double cannulaInLength = 0.4;
    double cannulaInSize = 17;
    double frenchSizeInLength = 0.18;
    
    // Cannula Out variables
    double cannulaOutLength = 0.3;
    double cannulaOutSize = 21;
    double frenchSizeOutLength = 0.15;

    // Condition variables
    bool bloodVesselSuction = false;
    bool kinkedReturnLine = false;
    bool oxygenatorMembraneThrombosis = false;

    double bloodViscosity = 2.7;
    double bloodViscosityinPascals = bloodViscosity * 0.001;

    /**
     * Calculate the total generated pressure in pump, subtracting the pressure drops in relevant compartments
     */
    double totalGeneratedPressure() {
        double pumpPressure = generatedPressure();

        // Transfer function block - taking a moving average of values for 5 seconds
        double averageAorticPressure = fiveSecondMovingAverage(aorticPressure, refreshRate);
        double averageRightAtriumPressure = fiveSecondMovingAverage(rightAtriumBloodPressure, refreshRate);
        double averagePressureFromHeart = averageAorticPressure - averageRightAtriumPressure;

        double pressureDrop = oxygenatorPressureDrop() + tubingPressureDrop() + totalCannulaPressureDrop() + averagePressureFromHeart;
        
        double generated = pumpPressure - pressureDrop;
        return generated;
    }

    double fiveSecondMovingAverage(double array[], int refreshRate)
    {
        double total = 0;
        for (int i = 0; i < 5 * refreshRate; i++)
        {
            total += array[i];
        }

        return (double)(total / (5 * refreshRate));
    }
    /** 
     * Calculating flow pressure generated by pump
     */
    double generatedPressure() {

        // Constant variables obtained from MATLAB model workspace
        const double p00 = -92.34;
        const double p01 = 0.05172;
        const double p02 = 2.289e-05;
        const double p10 = 2.708;
        const double p11 = -0.003733;
        const double p12 = -1.84e-07;
        const double p20 = -0.8888;
        const double p21 = 0.0005172;
        const double p30 = -0.08211;

        // For pump RPM less than 1500
        if (this->rpm < 1500) {
            return rpm * 0.0285714 + pumpFlow_litrePerMinute;
        } 

        // Thesis Equation 2.15
        // For pump RPM >= 1500
        double multiply = p10 * pumpFlow_litrePerMinute;
        double multiply1 = p01 * rpm;
        double multiply2 = p20 * pow(pumpFlow_litrePerMinute, 2);
        double multiply3 = p11 * pumpFlow_litrePerMinute * rpm;
        double multiply4 = p02  * pow(rpm, 2);
        double multiply5 = p30 * pow(pumpFlow_litrePerMinute, 3);
        double multiply6 = p21 * pow(pumpFlow_litrePerMinute, 2)* rpm;
        double multiply7 = p12 * pumpFlow * pow(rpm, 2);

        return p00 + multiply + multiply1 + multiply2 + multiply3 + multiply4 + multiply5 + multiply6 + multiply7;

    }

    /** 
     * Calculate pressure drop across oxygenator
     * **/
    double oxygenatorPressureDrop()
    {
        // Constants obtained from pressure drop wrapper
        const double cr = 6;
        const double cf = -4.2659;
        const double ca = -0.099;
        const double cb = 1.8024;
        double pd_oxygenator = 0;

        double thrombosis = 0;

        //Oxygenator Membrane Thrombosis function
        if (!oxygenatorMembraneThrombosis) 
        {
            thrombosis = 1; // returns default constant of 1 if no thrombosis occurrence in oxygenator
        } else {
            thrombosis = 1.5 - oxygenatorThrombosisFunction();
        }

        // Using thrombosis results to calculate pressure drop in oxygenator
        double uFunction = cb * exp(ca * bloodViscosity * thrombosis);  // f(u) block
        double powerFunction = pow(pumpFlow, uFunction);  // +/- u^v block
        double x = ((cr * bloodViscosity) + cf) * (powerFunction);  //constant * power function  block
        

        return (double)(x / 2.2);  //  output for PD across oxygenator
    }

    /**
     * Calculate amount of thrombosis in oxygenator based on the number of iterations. 
     * Value increases by 0.035 per iteration, starting from 0 and has a upper limit of 16.5
     */
    double oxygenatorThrombosisFunction() 
    {
        double sub_pd_oxy = exp(0.035 * iteration) * 0.5; // subsystem

        if (sub_pd_oxy > 16.5) //Saturation - upper limit of 16.5
        {
            return 16.5; 
        }

        return sub_pd_oxy;
    }


    /** 
     * Pressure drop across tubing, in mmHg
     */
    double tubingPressureDrop()
    {   
        // Calculating pressure drop in Pascals
        //tube 1
        double tube1PressureDrop = pumpFlow_m3PerSecond * (HagenPoiseuille(tube1Length, bloodViscosityinPascals));

        //tube 2
        double tube2PressureDrop = pumpFlow_m3PerSecond * (HagenPoiseuille(tube2Length, bloodViscosityinPascals));

        double tube3PressureDrop = pumpFlow_m3PerSecond * (HagenPoiseuille(tube3Length, bloodViscosityinPascals));

        double pd_tube_total = tube1PressureDrop + tube2PressureDrop + tube3PressureDrop;

        // Return total pressure drop in mmHg
        return (double)(pd_tube_total / 133.322);
    }

    // Hagen Poiseuille function to calculate pressure drops in tubes
    double HagenPoiseuille(double tubeLength, double bloodViscosity) {
        double pi = 3.1415926;

        return (double) ((8 * bloodViscosity * tubeLength) / (pi * pow(tubeLength, 4)));
    }

    // sub- function for pd cannula in when patient has blood vessel suction complication
    double bloodVesselSuctionPressureDrop()
    {
        return exp(-1 * pow(((rightAtriumBloodPressure[iteration % 250] + 1.3) / 1.3), 2)) * 6000;
    }

    /** 
     *  sub-function to calculate pressure drop across canula in a normal situation or with kinked return line (In the absence of blood vessel suction)
     */
    double cannulaPressureDrop(double cannulaLength, double frenchSizeLength, bool isCannulaOut)
    {
        double pi = 3.1415926;
        double hagenPoiseuille = (8 * bloodViscosityinPascals * (cannulaLength - frenchSizeLength)) / (pi * pow((0.0047625 - 0.00096), 4));
        double firstPressureDrop = hagenPoiseuille * pumpFlow_m3PerSecond;

        double velocity = 4 / (pi * pow((frenchSizeLength / 3000 - 0.00096), 2));
        double RE = ((frenchSizeLength / 6000 - 0.00096) * 1060) / bloodViscosityinPascals;
        double darcyWeisbach = (1060 * 8 * frenchSizeLength) / (pow(pi, 2) * pow((frenchSizeLength / 3000 - 0.00096), 5));

        // If kinked return line complication is present
        if (kinkedReturnLine && isCannulaOut) {
            double ramp = 1 + 1.4 * iteration;
            if (ramp > 5)
            { // saturation
                ramp = 5;
            }
            darcyWeisbach *= ramp;
        }

        // from velocity to darcy friction factor
        double darcyFriction = 0.316 / pow((velocity * pumpFlow_m3PerSecond * RE), 0.25);
        double secondPressureDrop = darcyFriction * darcyWeisbach * pow(pumpFlow, 2); // multiply5 block

        // return pressure drop in cannula in a regular situation
        return (double)((firstPressureDrop + secondPressureDrop) / 133.322);

    }

    /** 
     * Pressure drop across cannula in and out
     * **/

    double totalCannulaPressureDrop()
    {
        double cannulaInPressureDrop = cannulaPressureDrop(cannulaInLength, frenchSizeInLength, false);
        
        if (bloodVesselSuction) {
            cannulaInPressureDrop += bloodVesselSuctionPressureDrop();
        }

        double cannulaOutPressureDrop = cannulaPressureDrop(cannulaOutLength, frenchSizeOutLength, true);

        return (double)(cannulaInPressureDrop + cannulaOutPressureDrop);
    }
    
};

