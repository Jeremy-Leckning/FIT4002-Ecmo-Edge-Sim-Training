// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pulse/cdm/bind/MechanicalVentilator.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pulse_2fcdm_2fbind_2fMechanicalVentilator_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pulse_2fcdm_2fbind_2fMechanicalVentilator_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "pulse/cdm/bind/Properties.pb.h"
#include "pulse/cdm/bind/Substance.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fMechanicalVentilator_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pulse_2fcdm_2fbind_2fMechanicalVentilator_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pulse_2fcdm_2fbind_2fMechanicalVentilator_2eproto;
namespace pulse {
namespace cdm {
namespace bind {
class MechanicalVentilatorData;
class MechanicalVentilatorDataDefaultTypeInternal;
extern MechanicalVentilatorDataDefaultTypeInternal _MechanicalVentilatorData_default_instance_;
}  // namespace bind
}  // namespace cdm
}  // namespace pulse
PROTOBUF_NAMESPACE_OPEN
template<> ::pulse::cdm::bind::MechanicalVentilatorData* Arena::CreateMaybeMessage<::pulse::cdm::bind::MechanicalVentilatorData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pulse {
namespace cdm {
namespace bind {

enum MechanicalVentilatorData_eConnection : int {
  MechanicalVentilatorData_eConnection_NullConnection = 0,
  MechanicalVentilatorData_eConnection_Off = 1,
  MechanicalVentilatorData_eConnection_Mask = 2,
  MechanicalVentilatorData_eConnection_Tube = 3,
  MechanicalVentilatorData_eConnection_MechanicalVentilatorData_eConnection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MechanicalVentilatorData_eConnection_MechanicalVentilatorData_eConnection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MechanicalVentilatorData_eConnection_IsValid(int value);
constexpr MechanicalVentilatorData_eConnection MechanicalVentilatorData_eConnection_eConnection_MIN = MechanicalVentilatorData_eConnection_NullConnection;
constexpr MechanicalVentilatorData_eConnection MechanicalVentilatorData_eConnection_eConnection_MAX = MechanicalVentilatorData_eConnection_Tube;
constexpr int MechanicalVentilatorData_eConnection_eConnection_ARRAYSIZE = MechanicalVentilatorData_eConnection_eConnection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MechanicalVentilatorData_eConnection_descriptor();
template<typename T>
inline const std::string& MechanicalVentilatorData_eConnection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MechanicalVentilatorData_eConnection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MechanicalVentilatorData_eConnection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MechanicalVentilatorData_eConnection_descriptor(), enum_t_value);
}
inline bool MechanicalVentilatorData_eConnection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MechanicalVentilatorData_eConnection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MechanicalVentilatorData_eConnection>(
    MechanicalVentilatorData_eConnection_descriptor(), name, value);
}
enum MechanicalVentilatorData_eDriverWaveform : int {
  MechanicalVentilatorData_eDriverWaveform_NullDriverWaveform = 0,
  MechanicalVentilatorData_eDriverWaveform_Square = 1,
  MechanicalVentilatorData_eDriverWaveform_Exponential = 2,
  MechanicalVentilatorData_eDriverWaveform_Ramp = 3,
  MechanicalVentilatorData_eDriverWaveform_Sinusoidal = 4,
  MechanicalVentilatorData_eDriverWaveform_Sigmoidal = 5,
  MechanicalVentilatorData_eDriverWaveform_MechanicalVentilatorData_eDriverWaveform_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MechanicalVentilatorData_eDriverWaveform_MechanicalVentilatorData_eDriverWaveform_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MechanicalVentilatorData_eDriverWaveform_IsValid(int value);
constexpr MechanicalVentilatorData_eDriverWaveform MechanicalVentilatorData_eDriverWaveform_eDriverWaveform_MIN = MechanicalVentilatorData_eDriverWaveform_NullDriverWaveform;
constexpr MechanicalVentilatorData_eDriverWaveform MechanicalVentilatorData_eDriverWaveform_eDriverWaveform_MAX = MechanicalVentilatorData_eDriverWaveform_Sigmoidal;
constexpr int MechanicalVentilatorData_eDriverWaveform_eDriverWaveform_ARRAYSIZE = MechanicalVentilatorData_eDriverWaveform_eDriverWaveform_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MechanicalVentilatorData_eDriverWaveform_descriptor();
template<typename T>
inline const std::string& MechanicalVentilatorData_eDriverWaveform_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MechanicalVentilatorData_eDriverWaveform>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MechanicalVentilatorData_eDriverWaveform_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MechanicalVentilatorData_eDriverWaveform_descriptor(), enum_t_value);
}
inline bool MechanicalVentilatorData_eDriverWaveform_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MechanicalVentilatorData_eDriverWaveform* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MechanicalVentilatorData_eDriverWaveform>(
    MechanicalVentilatorData_eDriverWaveform_descriptor(), name, value);
}
// ===================================================================

class MechanicalVentilatorData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.MechanicalVentilatorData) */ {
 public:
  inline MechanicalVentilatorData() : MechanicalVentilatorData(nullptr) {}
  virtual ~MechanicalVentilatorData();

  MechanicalVentilatorData(const MechanicalVentilatorData& from);
  MechanicalVentilatorData(MechanicalVentilatorData&& from) noexcept
    : MechanicalVentilatorData() {
    *this = ::std::move(from);
  }

  inline MechanicalVentilatorData& operator=(const MechanicalVentilatorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MechanicalVentilatorData& operator=(MechanicalVentilatorData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MechanicalVentilatorData& default_instance();

  enum ExpiratoryBaselineCase {
    kPositiveEndExpiredPressure = 3,
    kFunctionalResidualCapacity = 4,
    EXPIRATORYBASELINE_NOT_SET = 0,
  };

  enum ExpirationCycleCase {
    kExpirationCycleFlow = 5,
    kExpirationCyclePressure = 6,
    kExpirationCycleTime = 7,
    kExpirationCycleVolume = 8,
    EXPIRATIONCYCLE_NOT_SET = 0,
  };

  enum InspirationLimitCase {
    kInspirationLimitFlow = 12,
    kInspirationLimitPressure = 13,
    kInspirationLimitVolume = 14,
    INSPIRATIONLIMIT_NOT_SET = 0,
  };

  enum InspiratoryTargetCase {
    kInspirationTargetFlow = 16,
    kPeakInspiratoryPressure = 17,
    INSPIRATORYTARGET_NOT_SET = 0,
  };

  enum InspirationMachineTriggerCase {
    kInspirationMachineTriggerTime = 18,
    INSPIRATIONMACHINETRIGGER_NOT_SET = 0,
  };

  enum InspirationPatientTriggerCase {
    kInspirationPatientTriggerFlow = 19,
    kInspirationPatientTriggerPressure = 20,
    INSPIRATIONPATIENTTRIGGER_NOT_SET = 0,
  };

  static inline const MechanicalVentilatorData* internal_default_instance() {
    return reinterpret_cast<const MechanicalVentilatorData*>(
               &_MechanicalVentilatorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MechanicalVentilatorData& a, MechanicalVentilatorData& b) {
    a.Swap(&b);
  }
  inline void Swap(MechanicalVentilatorData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MechanicalVentilatorData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MechanicalVentilatorData* New() const final {
    return CreateMaybeMessage<MechanicalVentilatorData>(nullptr);
  }

  MechanicalVentilatorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MechanicalVentilatorData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MechanicalVentilatorData& from);
  void MergeFrom(const MechanicalVentilatorData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MechanicalVentilatorData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.MechanicalVentilatorData";
  }
  protected:
  explicit MechanicalVentilatorData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fMechanicalVentilator_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fMechanicalVentilator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MechanicalVentilatorData_eConnection eConnection;
  static constexpr eConnection NullConnection =
    MechanicalVentilatorData_eConnection_NullConnection;
  static constexpr eConnection Off =
    MechanicalVentilatorData_eConnection_Off;
  static constexpr eConnection Mask =
    MechanicalVentilatorData_eConnection_Mask;
  static constexpr eConnection Tube =
    MechanicalVentilatorData_eConnection_Tube;
  static inline bool eConnection_IsValid(int value) {
    return MechanicalVentilatorData_eConnection_IsValid(value);
  }
  static constexpr eConnection eConnection_MIN =
    MechanicalVentilatorData_eConnection_eConnection_MIN;
  static constexpr eConnection eConnection_MAX =
    MechanicalVentilatorData_eConnection_eConnection_MAX;
  static constexpr int eConnection_ARRAYSIZE =
    MechanicalVentilatorData_eConnection_eConnection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  eConnection_descriptor() {
    return MechanicalVentilatorData_eConnection_descriptor();
  }
  template<typename T>
  static inline const std::string& eConnection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, eConnection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function eConnection_Name.");
    return MechanicalVentilatorData_eConnection_Name(enum_t_value);
  }
  static inline bool eConnection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      eConnection* value) {
    return MechanicalVentilatorData_eConnection_Parse(name, value);
  }

  typedef MechanicalVentilatorData_eDriverWaveform eDriverWaveform;
  static constexpr eDriverWaveform NullDriverWaveform =
    MechanicalVentilatorData_eDriverWaveform_NullDriverWaveform;
  static constexpr eDriverWaveform Square =
    MechanicalVentilatorData_eDriverWaveform_Square;
  static constexpr eDriverWaveform Exponential =
    MechanicalVentilatorData_eDriverWaveform_Exponential;
  static constexpr eDriverWaveform Ramp =
    MechanicalVentilatorData_eDriverWaveform_Ramp;
  static constexpr eDriverWaveform Sinusoidal =
    MechanicalVentilatorData_eDriverWaveform_Sinusoidal;
  static constexpr eDriverWaveform Sigmoidal =
    MechanicalVentilatorData_eDriverWaveform_Sigmoidal;
  static inline bool eDriverWaveform_IsValid(int value) {
    return MechanicalVentilatorData_eDriverWaveform_IsValid(value);
  }
  static constexpr eDriverWaveform eDriverWaveform_MIN =
    MechanicalVentilatorData_eDriverWaveform_eDriverWaveform_MIN;
  static constexpr eDriverWaveform eDriverWaveform_MAX =
    MechanicalVentilatorData_eDriverWaveform_eDriverWaveform_MAX;
  static constexpr int eDriverWaveform_ARRAYSIZE =
    MechanicalVentilatorData_eDriverWaveform_eDriverWaveform_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  eDriverWaveform_descriptor() {
    return MechanicalVentilatorData_eDriverWaveform_descriptor();
  }
  template<typename T>
  static inline const std::string& eDriverWaveform_Name(T enum_t_value) {
    static_assert(::std::is_same<T, eDriverWaveform>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function eDriverWaveform_Name.");
    return MechanicalVentilatorData_eDriverWaveform_Name(enum_t_value);
  }
  static inline bool eDriverWaveform_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      eDriverWaveform* value) {
    return MechanicalVentilatorData_eDriverWaveform_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFractionInspiredGasFieldNumber = 24,
    kConcentrationInspiredAerosolFieldNumber = 25,
    kEndotrachealTubeResistanceFieldNumber = 2,
    kExpirationTubeResistanceFieldNumber = 9,
    kExpirationValveResistanceFieldNumber = 10,
    kInspirationPauseTimeFieldNumber = 15,
    kInspirationTubeResistanceFieldNumber = 21,
    kInspirationValveResistanceFieldNumber = 22,
    kConnectionFieldNumber = 1,
    kExpirationWaveformFieldNumber = 11,
    kInspirationWaveformFieldNumber = 23,
    kPositiveEndExpiredPressureFieldNumber = 3,
    kFunctionalResidualCapacityFieldNumber = 4,
    kExpirationCycleFlowFieldNumber = 5,
    kExpirationCyclePressureFieldNumber = 6,
    kExpirationCycleTimeFieldNumber = 7,
    kExpirationCycleVolumeFieldNumber = 8,
    kInspirationLimitFlowFieldNumber = 12,
    kInspirationLimitPressureFieldNumber = 13,
    kInspirationLimitVolumeFieldNumber = 14,
    kInspirationTargetFlowFieldNumber = 16,
    kPeakInspiratoryPressureFieldNumber = 17,
    kInspirationMachineTriggerTimeFieldNumber = 18,
    kInspirationPatientTriggerFlowFieldNumber = 19,
    kInspirationPatientTriggerPressureFieldNumber = 20,
  };
  // repeated .pulse.cdm.bind.SubstanceFractionData FractionInspiredGas = 24;
  int fractioninspiredgas_size() const;
  private:
  int _internal_fractioninspiredgas_size() const;
  public:
  void clear_fractioninspiredgas();
  ::pulse::cdm::bind::SubstanceFractionData* mutable_fractioninspiredgas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceFractionData >*
      mutable_fractioninspiredgas();
  private:
  const ::pulse::cdm::bind::SubstanceFractionData& _internal_fractioninspiredgas(int index) const;
  ::pulse::cdm::bind::SubstanceFractionData* _internal_add_fractioninspiredgas();
  public:
  const ::pulse::cdm::bind::SubstanceFractionData& fractioninspiredgas(int index) const;
  ::pulse::cdm::bind::SubstanceFractionData* add_fractioninspiredgas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceFractionData >&
      fractioninspiredgas() const;

  // repeated .pulse.cdm.bind.SubstanceConcentrationData ConcentrationInspiredAerosol = 25;
  int concentrationinspiredaerosol_size() const;
  private:
  int _internal_concentrationinspiredaerosol_size() const;
  public:
  void clear_concentrationinspiredaerosol();
  ::pulse::cdm::bind::SubstanceConcentrationData* mutable_concentrationinspiredaerosol(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceConcentrationData >*
      mutable_concentrationinspiredaerosol();
  private:
  const ::pulse::cdm::bind::SubstanceConcentrationData& _internal_concentrationinspiredaerosol(int index) const;
  ::pulse::cdm::bind::SubstanceConcentrationData* _internal_add_concentrationinspiredaerosol();
  public:
  const ::pulse::cdm::bind::SubstanceConcentrationData& concentrationinspiredaerosol(int index) const;
  ::pulse::cdm::bind::SubstanceConcentrationData* add_concentrationinspiredaerosol();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceConcentrationData >&
      concentrationinspiredaerosol() const;

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData EndotrachealTubeResistance = 2;
  bool has_endotrachealtuberesistance() const;
  private:
  bool _internal_has_endotrachealtuberesistance() const;
  public:
  void clear_endotrachealtuberesistance();
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& endotrachealtuberesistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* release_endotrachealtuberesistance();
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* mutable_endotrachealtuberesistance();
  void set_allocated_endotrachealtuberesistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* endotrachealtuberesistance);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& _internal_endotrachealtuberesistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* _internal_mutable_endotrachealtuberesistance();
  public:
  void unsafe_arena_set_allocated_endotrachealtuberesistance(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* endotrachealtuberesistance);
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* unsafe_arena_release_endotrachealtuberesistance();

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData ExpirationTubeResistance = 9;
  bool has_expirationtuberesistance() const;
  private:
  bool _internal_has_expirationtuberesistance() const;
  public:
  void clear_expirationtuberesistance();
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& expirationtuberesistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* release_expirationtuberesistance();
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* mutable_expirationtuberesistance();
  void set_allocated_expirationtuberesistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationtuberesistance);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& _internal_expirationtuberesistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* _internal_mutable_expirationtuberesistance();
  public:
  void unsafe_arena_set_allocated_expirationtuberesistance(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationtuberesistance);
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* unsafe_arena_release_expirationtuberesistance();

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData ExpirationValveResistance = 10;
  bool has_expirationvalveresistance() const;
  private:
  bool _internal_has_expirationvalveresistance() const;
  public:
  void clear_expirationvalveresistance();
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& expirationvalveresistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* release_expirationvalveresistance();
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* mutable_expirationvalveresistance();
  void set_allocated_expirationvalveresistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationvalveresistance);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& _internal_expirationvalveresistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* _internal_mutable_expirationvalveresistance();
  public:
  void unsafe_arena_set_allocated_expirationvalveresistance(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationvalveresistance);
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* unsafe_arena_release_expirationvalveresistance();

  // .pulse.cdm.bind.ScalarTimeData InspirationPauseTime = 15;
  bool has_inspirationpausetime() const;
  private:
  bool _internal_has_inspirationpausetime() const;
  public:
  void clear_inspirationpausetime();
  const ::pulse::cdm::bind::ScalarTimeData& inspirationpausetime() const;
  ::pulse::cdm::bind::ScalarTimeData* release_inspirationpausetime();
  ::pulse::cdm::bind::ScalarTimeData* mutable_inspirationpausetime();
  void set_allocated_inspirationpausetime(::pulse::cdm::bind::ScalarTimeData* inspirationpausetime);
  private:
  const ::pulse::cdm::bind::ScalarTimeData& _internal_inspirationpausetime() const;
  ::pulse::cdm::bind::ScalarTimeData* _internal_mutable_inspirationpausetime();
  public:
  void unsafe_arena_set_allocated_inspirationpausetime(
      ::pulse::cdm::bind::ScalarTimeData* inspirationpausetime);
  ::pulse::cdm::bind::ScalarTimeData* unsafe_arena_release_inspirationpausetime();

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData InspirationTubeResistance = 21;
  bool has_inspirationtuberesistance() const;
  private:
  bool _internal_has_inspirationtuberesistance() const;
  public:
  void clear_inspirationtuberesistance();
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& inspirationtuberesistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* release_inspirationtuberesistance();
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* mutable_inspirationtuberesistance();
  void set_allocated_inspirationtuberesistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationtuberesistance);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& _internal_inspirationtuberesistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* _internal_mutable_inspirationtuberesistance();
  public:
  void unsafe_arena_set_allocated_inspirationtuberesistance(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationtuberesistance);
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* unsafe_arena_release_inspirationtuberesistance();

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData InspirationValveResistance = 22;
  bool has_inspirationvalveresistance() const;
  private:
  bool _internal_has_inspirationvalveresistance() const;
  public:
  void clear_inspirationvalveresistance();
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& inspirationvalveresistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* release_inspirationvalveresistance();
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* mutable_inspirationvalveresistance();
  void set_allocated_inspirationvalveresistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationvalveresistance);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& _internal_inspirationvalveresistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* _internal_mutable_inspirationvalveresistance();
  public:
  void unsafe_arena_set_allocated_inspirationvalveresistance(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationvalveresistance);
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* unsafe_arena_release_inspirationvalveresistance();

  // .pulse.cdm.bind.MechanicalVentilatorData.eConnection Connection = 1;
  void clear_connection();
  ::pulse::cdm::bind::MechanicalVentilatorData_eConnection connection() const;
  void set_connection(::pulse::cdm::bind::MechanicalVentilatorData_eConnection value);
  private:
  ::pulse::cdm::bind::MechanicalVentilatorData_eConnection _internal_connection() const;
  void _internal_set_connection(::pulse::cdm::bind::MechanicalVentilatorData_eConnection value);
  public:

  // .pulse.cdm.bind.MechanicalVentilatorData.eDriverWaveform ExpirationWaveform = 11;
  void clear_expirationwaveform();
  ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform expirationwaveform() const;
  void set_expirationwaveform(::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform value);
  private:
  ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform _internal_expirationwaveform() const;
  void _internal_set_expirationwaveform(::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform value);
  public:

  // .pulse.cdm.bind.MechanicalVentilatorData.eDriverWaveform InspirationWaveform = 23;
  void clear_inspirationwaveform();
  ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform inspirationwaveform() const;
  void set_inspirationwaveform(::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform value);
  private:
  ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform _internal_inspirationwaveform() const;
  void _internal_set_inspirationwaveform(::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform value);
  public:

  // .pulse.cdm.bind.ScalarPressureData PositiveEndExpiredPressure = 3;
  bool has_positiveendexpiredpressure() const;
  private:
  bool _internal_has_positiveendexpiredpressure() const;
  public:
  void clear_positiveendexpiredpressure();
  const ::pulse::cdm::bind::ScalarPressureData& positiveendexpiredpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* release_positiveendexpiredpressure();
  ::pulse::cdm::bind::ScalarPressureData* mutable_positiveendexpiredpressure();
  void set_allocated_positiveendexpiredpressure(::pulse::cdm::bind::ScalarPressureData* positiveendexpiredpressure);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_positiveendexpiredpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_positiveendexpiredpressure();
  public:
  void unsafe_arena_set_allocated_positiveendexpiredpressure(
      ::pulse::cdm::bind::ScalarPressureData* positiveendexpiredpressure);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_positiveendexpiredpressure();

  // .pulse.cdm.bind.ScalarPressureData FunctionalResidualCapacity = 4;
  bool has_functionalresidualcapacity() const;
  private:
  bool _internal_has_functionalresidualcapacity() const;
  public:
  void clear_functionalresidualcapacity();
  const ::pulse::cdm::bind::ScalarPressureData& functionalresidualcapacity() const;
  ::pulse::cdm::bind::ScalarPressureData* release_functionalresidualcapacity();
  ::pulse::cdm::bind::ScalarPressureData* mutable_functionalresidualcapacity();
  void set_allocated_functionalresidualcapacity(::pulse::cdm::bind::ScalarPressureData* functionalresidualcapacity);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_functionalresidualcapacity() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_functionalresidualcapacity();
  public:
  void unsafe_arena_set_allocated_functionalresidualcapacity(
      ::pulse::cdm::bind::ScalarPressureData* functionalresidualcapacity);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_functionalresidualcapacity();

  // .pulse.cdm.bind.ScalarVolumePerTimeData ExpirationCycleFlow = 5;
  bool has_expirationcycleflow() const;
  private:
  bool _internal_has_expirationcycleflow() const;
  public:
  void clear_expirationcycleflow();
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& expirationcycleflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* release_expirationcycleflow();
  ::pulse::cdm::bind::ScalarVolumePerTimeData* mutable_expirationcycleflow();
  void set_allocated_expirationcycleflow(::pulse::cdm::bind::ScalarVolumePerTimeData* expirationcycleflow);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& _internal_expirationcycleflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* _internal_mutable_expirationcycleflow();
  public:
  void unsafe_arena_set_allocated_expirationcycleflow(
      ::pulse::cdm::bind::ScalarVolumePerTimeData* expirationcycleflow);
  ::pulse::cdm::bind::ScalarVolumePerTimeData* unsafe_arena_release_expirationcycleflow();

  // .pulse.cdm.bind.ScalarPressureData ExpirationCyclePressure = 6;
  bool has_expirationcyclepressure() const;
  private:
  bool _internal_has_expirationcyclepressure() const;
  public:
  void clear_expirationcyclepressure();
  const ::pulse::cdm::bind::ScalarPressureData& expirationcyclepressure() const;
  ::pulse::cdm::bind::ScalarPressureData* release_expirationcyclepressure();
  ::pulse::cdm::bind::ScalarPressureData* mutable_expirationcyclepressure();
  void set_allocated_expirationcyclepressure(::pulse::cdm::bind::ScalarPressureData* expirationcyclepressure);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_expirationcyclepressure() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_expirationcyclepressure();
  public:
  void unsafe_arena_set_allocated_expirationcyclepressure(
      ::pulse::cdm::bind::ScalarPressureData* expirationcyclepressure);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_expirationcyclepressure();

  // .pulse.cdm.bind.ScalarTimeData ExpirationCycleTime = 7;
  bool has_expirationcycletime() const;
  private:
  bool _internal_has_expirationcycletime() const;
  public:
  void clear_expirationcycletime();
  const ::pulse::cdm::bind::ScalarTimeData& expirationcycletime() const;
  ::pulse::cdm::bind::ScalarTimeData* release_expirationcycletime();
  ::pulse::cdm::bind::ScalarTimeData* mutable_expirationcycletime();
  void set_allocated_expirationcycletime(::pulse::cdm::bind::ScalarTimeData* expirationcycletime);
  private:
  const ::pulse::cdm::bind::ScalarTimeData& _internal_expirationcycletime() const;
  ::pulse::cdm::bind::ScalarTimeData* _internal_mutable_expirationcycletime();
  public:
  void unsafe_arena_set_allocated_expirationcycletime(
      ::pulse::cdm::bind::ScalarTimeData* expirationcycletime);
  ::pulse::cdm::bind::ScalarTimeData* unsafe_arena_release_expirationcycletime();

  // .pulse.cdm.bind.ScalarVolumeData ExpirationCycleVolume = 8;
  bool has_expirationcyclevolume() const;
  private:
  bool _internal_has_expirationcyclevolume() const;
  public:
  void clear_expirationcyclevolume();
  const ::pulse::cdm::bind::ScalarVolumeData& expirationcyclevolume() const;
  ::pulse::cdm::bind::ScalarVolumeData* release_expirationcyclevolume();
  ::pulse::cdm::bind::ScalarVolumeData* mutable_expirationcyclevolume();
  void set_allocated_expirationcyclevolume(::pulse::cdm::bind::ScalarVolumeData* expirationcyclevolume);
  private:
  const ::pulse::cdm::bind::ScalarVolumeData& _internal_expirationcyclevolume() const;
  ::pulse::cdm::bind::ScalarVolumeData* _internal_mutable_expirationcyclevolume();
  public:
  void unsafe_arena_set_allocated_expirationcyclevolume(
      ::pulse::cdm::bind::ScalarVolumeData* expirationcyclevolume);
  ::pulse::cdm::bind::ScalarVolumeData* unsafe_arena_release_expirationcyclevolume();

  // .pulse.cdm.bind.ScalarVolumePerTimeData InspirationLimitFlow = 12;
  bool has_inspirationlimitflow() const;
  private:
  bool _internal_has_inspirationlimitflow() const;
  public:
  void clear_inspirationlimitflow();
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& inspirationlimitflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* release_inspirationlimitflow();
  ::pulse::cdm::bind::ScalarVolumePerTimeData* mutable_inspirationlimitflow();
  void set_allocated_inspirationlimitflow(::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationlimitflow);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& _internal_inspirationlimitflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* _internal_mutable_inspirationlimitflow();
  public:
  void unsafe_arena_set_allocated_inspirationlimitflow(
      ::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationlimitflow);
  ::pulse::cdm::bind::ScalarVolumePerTimeData* unsafe_arena_release_inspirationlimitflow();

  // .pulse.cdm.bind.ScalarPressureData InspirationLimitPressure = 13;
  bool has_inspirationlimitpressure() const;
  private:
  bool _internal_has_inspirationlimitpressure() const;
  public:
  void clear_inspirationlimitpressure();
  const ::pulse::cdm::bind::ScalarPressureData& inspirationlimitpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* release_inspirationlimitpressure();
  ::pulse::cdm::bind::ScalarPressureData* mutable_inspirationlimitpressure();
  void set_allocated_inspirationlimitpressure(::pulse::cdm::bind::ScalarPressureData* inspirationlimitpressure);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_inspirationlimitpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_inspirationlimitpressure();
  public:
  void unsafe_arena_set_allocated_inspirationlimitpressure(
      ::pulse::cdm::bind::ScalarPressureData* inspirationlimitpressure);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_inspirationlimitpressure();

  // .pulse.cdm.bind.ScalarVolumeData InspirationLimitVolume = 14;
  bool has_inspirationlimitvolume() const;
  private:
  bool _internal_has_inspirationlimitvolume() const;
  public:
  void clear_inspirationlimitvolume();
  const ::pulse::cdm::bind::ScalarVolumeData& inspirationlimitvolume() const;
  ::pulse::cdm::bind::ScalarVolumeData* release_inspirationlimitvolume();
  ::pulse::cdm::bind::ScalarVolumeData* mutable_inspirationlimitvolume();
  void set_allocated_inspirationlimitvolume(::pulse::cdm::bind::ScalarVolumeData* inspirationlimitvolume);
  private:
  const ::pulse::cdm::bind::ScalarVolumeData& _internal_inspirationlimitvolume() const;
  ::pulse::cdm::bind::ScalarVolumeData* _internal_mutable_inspirationlimitvolume();
  public:
  void unsafe_arena_set_allocated_inspirationlimitvolume(
      ::pulse::cdm::bind::ScalarVolumeData* inspirationlimitvolume);
  ::pulse::cdm::bind::ScalarVolumeData* unsafe_arena_release_inspirationlimitvolume();

  // .pulse.cdm.bind.ScalarVolumePerTimeData InspirationTargetFlow = 16;
  bool has_inspirationtargetflow() const;
  private:
  bool _internal_has_inspirationtargetflow() const;
  public:
  void clear_inspirationtargetflow();
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& inspirationtargetflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* release_inspirationtargetflow();
  ::pulse::cdm::bind::ScalarVolumePerTimeData* mutable_inspirationtargetflow();
  void set_allocated_inspirationtargetflow(::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationtargetflow);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& _internal_inspirationtargetflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* _internal_mutable_inspirationtargetflow();
  public:
  void unsafe_arena_set_allocated_inspirationtargetflow(
      ::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationtargetflow);
  ::pulse::cdm::bind::ScalarVolumePerTimeData* unsafe_arena_release_inspirationtargetflow();

  // .pulse.cdm.bind.ScalarPressureData PeakInspiratoryPressure = 17;
  bool has_peakinspiratorypressure() const;
  private:
  bool _internal_has_peakinspiratorypressure() const;
  public:
  void clear_peakinspiratorypressure();
  const ::pulse::cdm::bind::ScalarPressureData& peakinspiratorypressure() const;
  ::pulse::cdm::bind::ScalarPressureData* release_peakinspiratorypressure();
  ::pulse::cdm::bind::ScalarPressureData* mutable_peakinspiratorypressure();
  void set_allocated_peakinspiratorypressure(::pulse::cdm::bind::ScalarPressureData* peakinspiratorypressure);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_peakinspiratorypressure() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_peakinspiratorypressure();
  public:
  void unsafe_arena_set_allocated_peakinspiratorypressure(
      ::pulse::cdm::bind::ScalarPressureData* peakinspiratorypressure);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_peakinspiratorypressure();

  // .pulse.cdm.bind.ScalarTimeData InspirationMachineTriggerTime = 18;
  bool has_inspirationmachinetriggertime() const;
  private:
  bool _internal_has_inspirationmachinetriggertime() const;
  public:
  void clear_inspirationmachinetriggertime();
  const ::pulse::cdm::bind::ScalarTimeData& inspirationmachinetriggertime() const;
  ::pulse::cdm::bind::ScalarTimeData* release_inspirationmachinetriggertime();
  ::pulse::cdm::bind::ScalarTimeData* mutable_inspirationmachinetriggertime();
  void set_allocated_inspirationmachinetriggertime(::pulse::cdm::bind::ScalarTimeData* inspirationmachinetriggertime);
  private:
  const ::pulse::cdm::bind::ScalarTimeData& _internal_inspirationmachinetriggertime() const;
  ::pulse::cdm::bind::ScalarTimeData* _internal_mutable_inspirationmachinetriggertime();
  public:
  void unsafe_arena_set_allocated_inspirationmachinetriggertime(
      ::pulse::cdm::bind::ScalarTimeData* inspirationmachinetriggertime);
  ::pulse::cdm::bind::ScalarTimeData* unsafe_arena_release_inspirationmachinetriggertime();

  // .pulse.cdm.bind.ScalarVolumePerTimeData InspirationPatientTriggerFlow = 19;
  bool has_inspirationpatienttriggerflow() const;
  private:
  bool _internal_has_inspirationpatienttriggerflow() const;
  public:
  void clear_inspirationpatienttriggerflow();
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& inspirationpatienttriggerflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* release_inspirationpatienttriggerflow();
  ::pulse::cdm::bind::ScalarVolumePerTimeData* mutable_inspirationpatienttriggerflow();
  void set_allocated_inspirationpatienttriggerflow(::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationpatienttriggerflow);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& _internal_inspirationpatienttriggerflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* _internal_mutable_inspirationpatienttriggerflow();
  public:
  void unsafe_arena_set_allocated_inspirationpatienttriggerflow(
      ::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationpatienttriggerflow);
  ::pulse::cdm::bind::ScalarVolumePerTimeData* unsafe_arena_release_inspirationpatienttriggerflow();

  // .pulse.cdm.bind.ScalarPressureData InspirationPatientTriggerPressure = 20;
  bool has_inspirationpatienttriggerpressure() const;
  private:
  bool _internal_has_inspirationpatienttriggerpressure() const;
  public:
  void clear_inspirationpatienttriggerpressure();
  const ::pulse::cdm::bind::ScalarPressureData& inspirationpatienttriggerpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* release_inspirationpatienttriggerpressure();
  ::pulse::cdm::bind::ScalarPressureData* mutable_inspirationpatienttriggerpressure();
  void set_allocated_inspirationpatienttriggerpressure(::pulse::cdm::bind::ScalarPressureData* inspirationpatienttriggerpressure);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_inspirationpatienttriggerpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_inspirationpatienttriggerpressure();
  public:
  void unsafe_arena_set_allocated_inspirationpatienttriggerpressure(
      ::pulse::cdm::bind::ScalarPressureData* inspirationpatienttriggerpressure);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_inspirationpatienttriggerpressure();

  void clear_ExpiratoryBaseline();
  ExpiratoryBaselineCase ExpiratoryBaseline_case() const;
  void clear_ExpirationCycle();
  ExpirationCycleCase ExpirationCycle_case() const;
  void clear_InspirationLimit();
  InspirationLimitCase InspirationLimit_case() const;
  void clear_InspiratoryTarget();
  InspiratoryTargetCase InspiratoryTarget_case() const;
  void clear_InspirationMachineTrigger();
  InspirationMachineTriggerCase InspirationMachineTrigger_case() const;
  void clear_InspirationPatientTrigger();
  InspirationPatientTriggerCase InspirationPatientTrigger_case() const;
  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.MechanicalVentilatorData)
 private:
  class _Internal;
  void set_has_positiveendexpiredpressure();
  void set_has_functionalresidualcapacity();
  void set_has_expirationcycleflow();
  void set_has_expirationcyclepressure();
  void set_has_expirationcycletime();
  void set_has_expirationcyclevolume();
  void set_has_inspirationlimitflow();
  void set_has_inspirationlimitpressure();
  void set_has_inspirationlimitvolume();
  void set_has_inspirationtargetflow();
  void set_has_peakinspiratorypressure();
  void set_has_inspirationmachinetriggertime();
  void set_has_inspirationpatienttriggerflow();
  void set_has_inspirationpatienttriggerpressure();

  inline bool has_ExpiratoryBaseline() const;
  inline void clear_has_ExpiratoryBaseline();

  inline bool has_ExpirationCycle() const;
  inline void clear_has_ExpirationCycle();

  inline bool has_InspirationLimit() const;
  inline void clear_has_InspirationLimit();

  inline bool has_InspiratoryTarget() const;
  inline void clear_has_InspiratoryTarget();

  inline bool has_InspirationMachineTrigger() const;
  inline void clear_has_InspirationMachineTrigger();

  inline bool has_InspirationPatientTrigger() const;
  inline void clear_has_InspirationPatientTrigger();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceFractionData > fractioninspiredgas_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceConcentrationData > concentrationinspiredaerosol_;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* endotrachealtuberesistance_;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationtuberesistance_;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationvalveresistance_;
  ::pulse::cdm::bind::ScalarTimeData* inspirationpausetime_;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationtuberesistance_;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationvalveresistance_;
  int connection_;
  int expirationwaveform_;
  int inspirationwaveform_;
  union ExpiratoryBaselineUnion {
    ExpiratoryBaselineUnion() {}
    ::pulse::cdm::bind::ScalarPressureData* positiveendexpiredpressure_;
    ::pulse::cdm::bind::ScalarPressureData* functionalresidualcapacity_;
  } ExpiratoryBaseline_;
  union ExpirationCycleUnion {
    ExpirationCycleUnion() {}
    ::pulse::cdm::bind::ScalarVolumePerTimeData* expirationcycleflow_;
    ::pulse::cdm::bind::ScalarPressureData* expirationcyclepressure_;
    ::pulse::cdm::bind::ScalarTimeData* expirationcycletime_;
    ::pulse::cdm::bind::ScalarVolumeData* expirationcyclevolume_;
  } ExpirationCycle_;
  union InspirationLimitUnion {
    InspirationLimitUnion() {}
    ::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationlimitflow_;
    ::pulse::cdm::bind::ScalarPressureData* inspirationlimitpressure_;
    ::pulse::cdm::bind::ScalarVolumeData* inspirationlimitvolume_;
  } InspirationLimit_;
  union InspiratoryTargetUnion {
    InspiratoryTargetUnion() {}
    ::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationtargetflow_;
    ::pulse::cdm::bind::ScalarPressureData* peakinspiratorypressure_;
  } InspiratoryTarget_;
  union InspirationMachineTriggerUnion {
    InspirationMachineTriggerUnion() {}
    ::pulse::cdm::bind::ScalarTimeData* inspirationmachinetriggertime_;
  } InspirationMachineTrigger_;
  union InspirationPatientTriggerUnion {
    InspirationPatientTriggerUnion() {}
    ::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationpatienttriggerflow_;
    ::pulse::cdm::bind::ScalarPressureData* inspirationpatienttriggerpressure_;
  } InspirationPatientTrigger_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[6];

  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fMechanicalVentilator_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MechanicalVentilatorData

// .pulse.cdm.bind.MechanicalVentilatorData.eConnection Connection = 1;
inline void MechanicalVentilatorData::clear_connection() {
  connection_ = 0;
}
inline ::pulse::cdm::bind::MechanicalVentilatorData_eConnection MechanicalVentilatorData::_internal_connection() const {
  return static_cast< ::pulse::cdm::bind::MechanicalVentilatorData_eConnection >(connection_);
}
inline ::pulse::cdm::bind::MechanicalVentilatorData_eConnection MechanicalVentilatorData::connection() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.Connection)
  return _internal_connection();
}
inline void MechanicalVentilatorData::_internal_set_connection(::pulse::cdm::bind::MechanicalVentilatorData_eConnection value) {
  
  connection_ = value;
}
inline void MechanicalVentilatorData::set_connection(::pulse::cdm::bind::MechanicalVentilatorData_eConnection value) {
  _internal_set_connection(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.MechanicalVentilatorData.Connection)
}

// .pulse.cdm.bind.ScalarPressureTimePerVolumeData EndotrachealTubeResistance = 2;
inline bool MechanicalVentilatorData::_internal_has_endotrachealtuberesistance() const {
  return this != internal_default_instance() && endotrachealtuberesistance_ != nullptr;
}
inline bool MechanicalVentilatorData::has_endotrachealtuberesistance() const {
  return _internal_has_endotrachealtuberesistance();
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::_internal_endotrachealtuberesistance() const {
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* p = endotrachealtuberesistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimePerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::endotrachealtuberesistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.EndotrachealTubeResistance)
  return _internal_endotrachealtuberesistance();
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_endotrachealtuberesistance(
    ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* endotrachealtuberesistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endotrachealtuberesistance_);
  }
  endotrachealtuberesistance_ = endotrachealtuberesistance;
  if (endotrachealtuberesistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.EndotrachealTubeResistance)
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::release_endotrachealtuberesistance() {
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = endotrachealtuberesistance_;
  endotrachealtuberesistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::unsafe_arena_release_endotrachealtuberesistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.EndotrachealTubeResistance)
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = endotrachealtuberesistance_;
  endotrachealtuberesistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::_internal_mutable_endotrachealtuberesistance() {
  
  if (endotrachealtuberesistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimePerVolumeData>(GetArena());
    endotrachealtuberesistance_ = p;
  }
  return endotrachealtuberesistance_;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::mutable_endotrachealtuberesistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.EndotrachealTubeResistance)
  return _internal_mutable_endotrachealtuberesistance();
}
inline void MechanicalVentilatorData::set_allocated_endotrachealtuberesistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* endotrachealtuberesistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endotrachealtuberesistance_);
  }
  if (endotrachealtuberesistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endotrachealtuberesistance)->GetArena();
    if (message_arena != submessage_arena) {
      endotrachealtuberesistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endotrachealtuberesistance, submessage_arena);
    }
    
  } else {
    
  }
  endotrachealtuberesistance_ = endotrachealtuberesistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.EndotrachealTubeResistance)
}

// .pulse.cdm.bind.ScalarPressureData PositiveEndExpiredPressure = 3;
inline bool MechanicalVentilatorData::_internal_has_positiveendexpiredpressure() const {
  return ExpiratoryBaseline_case() == kPositiveEndExpiredPressure;
}
inline bool MechanicalVentilatorData::has_positiveendexpiredpressure() const {
  return _internal_has_positiveendexpiredpressure();
}
inline void MechanicalVentilatorData::set_has_positiveendexpiredpressure() {
  _oneof_case_[0] = kPositiveEndExpiredPressure;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::release_positiveendexpiredpressure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.PositiveEndExpiredPressure)
  if (_internal_has_positiveendexpiredpressure()) {
    clear_has_ExpiratoryBaseline();
      ::pulse::cdm::bind::ScalarPressureData* temp = ExpiratoryBaseline_.positiveendexpiredpressure_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ExpiratoryBaseline_.positiveendexpiredpressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::_internal_positiveendexpiredpressure() const {
  return _internal_has_positiveendexpiredpressure()
      ? *ExpiratoryBaseline_.positiveendexpiredpressure_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarPressureData&>(::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::positiveendexpiredpressure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.PositiveEndExpiredPressure)
  return _internal_positiveendexpiredpressure();
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::unsafe_arena_release_positiveendexpiredpressure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.PositiveEndExpiredPressure)
  if (_internal_has_positiveendexpiredpressure()) {
    clear_has_ExpiratoryBaseline();
    ::pulse::cdm::bind::ScalarPressureData* temp = ExpiratoryBaseline_.positiveendexpiredpressure_;
    ExpiratoryBaseline_.positiveendexpiredpressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_positiveendexpiredpressure(::pulse::cdm::bind::ScalarPressureData* positiveendexpiredpressure) {
  clear_ExpiratoryBaseline();
  if (positiveendexpiredpressure) {
    set_has_positiveendexpiredpressure();
    ExpiratoryBaseline_.positiveendexpiredpressure_ = positiveendexpiredpressure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.PositiveEndExpiredPressure)
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::_internal_mutable_positiveendexpiredpressure() {
  if (!_internal_has_positiveendexpiredpressure()) {
    clear_ExpiratoryBaseline();
    set_has_positiveendexpiredpressure();
    ExpiratoryBaseline_.positiveendexpiredpressure_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarPressureData >(GetArena());
  }
  return ExpiratoryBaseline_.positiveendexpiredpressure_;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::mutable_positiveendexpiredpressure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.PositiveEndExpiredPressure)
  return _internal_mutable_positiveendexpiredpressure();
}

// .pulse.cdm.bind.ScalarPressureData FunctionalResidualCapacity = 4;
inline bool MechanicalVentilatorData::_internal_has_functionalresidualcapacity() const {
  return ExpiratoryBaseline_case() == kFunctionalResidualCapacity;
}
inline bool MechanicalVentilatorData::has_functionalresidualcapacity() const {
  return _internal_has_functionalresidualcapacity();
}
inline void MechanicalVentilatorData::set_has_functionalresidualcapacity() {
  _oneof_case_[0] = kFunctionalResidualCapacity;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::release_functionalresidualcapacity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.FunctionalResidualCapacity)
  if (_internal_has_functionalresidualcapacity()) {
    clear_has_ExpiratoryBaseline();
      ::pulse::cdm::bind::ScalarPressureData* temp = ExpiratoryBaseline_.functionalresidualcapacity_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ExpiratoryBaseline_.functionalresidualcapacity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::_internal_functionalresidualcapacity() const {
  return _internal_has_functionalresidualcapacity()
      ? *ExpiratoryBaseline_.functionalresidualcapacity_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarPressureData&>(::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::functionalresidualcapacity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.FunctionalResidualCapacity)
  return _internal_functionalresidualcapacity();
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::unsafe_arena_release_functionalresidualcapacity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.FunctionalResidualCapacity)
  if (_internal_has_functionalresidualcapacity()) {
    clear_has_ExpiratoryBaseline();
    ::pulse::cdm::bind::ScalarPressureData* temp = ExpiratoryBaseline_.functionalresidualcapacity_;
    ExpiratoryBaseline_.functionalresidualcapacity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_functionalresidualcapacity(::pulse::cdm::bind::ScalarPressureData* functionalresidualcapacity) {
  clear_ExpiratoryBaseline();
  if (functionalresidualcapacity) {
    set_has_functionalresidualcapacity();
    ExpiratoryBaseline_.functionalresidualcapacity_ = functionalresidualcapacity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.FunctionalResidualCapacity)
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::_internal_mutable_functionalresidualcapacity() {
  if (!_internal_has_functionalresidualcapacity()) {
    clear_ExpiratoryBaseline();
    set_has_functionalresidualcapacity();
    ExpiratoryBaseline_.functionalresidualcapacity_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarPressureData >(GetArena());
  }
  return ExpiratoryBaseline_.functionalresidualcapacity_;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::mutable_functionalresidualcapacity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.FunctionalResidualCapacity)
  return _internal_mutable_functionalresidualcapacity();
}

// .pulse.cdm.bind.ScalarVolumePerTimeData ExpirationCycleFlow = 5;
inline bool MechanicalVentilatorData::_internal_has_expirationcycleflow() const {
  return ExpirationCycle_case() == kExpirationCycleFlow;
}
inline bool MechanicalVentilatorData::has_expirationcycleflow() const {
  return _internal_has_expirationcycleflow();
}
inline void MechanicalVentilatorData::set_has_expirationcycleflow() {
  _oneof_case_[1] = kExpirationCycleFlow;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::release_expirationcycleflow() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleFlow)
  if (_internal_has_expirationcycleflow()) {
    clear_has_ExpirationCycle();
      ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = ExpirationCycle_.expirationcycleflow_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ExpirationCycle_.expirationcycleflow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& MechanicalVentilatorData::_internal_expirationcycleflow() const {
  return _internal_has_expirationcycleflow()
      ? *ExpirationCycle_.expirationcycleflow_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarVolumePerTimeData&>(::pulse::cdm::bind::_ScalarVolumePerTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& MechanicalVentilatorData::expirationcycleflow() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleFlow)
  return _internal_expirationcycleflow();
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::unsafe_arena_release_expirationcycleflow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleFlow)
  if (_internal_has_expirationcycleflow()) {
    clear_has_ExpirationCycle();
    ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = ExpirationCycle_.expirationcycleflow_;
    ExpirationCycle_.expirationcycleflow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_expirationcycleflow(::pulse::cdm::bind::ScalarVolumePerTimeData* expirationcycleflow) {
  clear_ExpirationCycle();
  if (expirationcycleflow) {
    set_has_expirationcycleflow();
    ExpirationCycle_.expirationcycleflow_ = expirationcycleflow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleFlow)
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::_internal_mutable_expirationcycleflow() {
  if (!_internal_has_expirationcycleflow()) {
    clear_ExpirationCycle();
    set_has_expirationcycleflow();
    ExpirationCycle_.expirationcycleflow_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarVolumePerTimeData >(GetArena());
  }
  return ExpirationCycle_.expirationcycleflow_;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::mutable_expirationcycleflow() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleFlow)
  return _internal_mutable_expirationcycleflow();
}

// .pulse.cdm.bind.ScalarPressureData ExpirationCyclePressure = 6;
inline bool MechanicalVentilatorData::_internal_has_expirationcyclepressure() const {
  return ExpirationCycle_case() == kExpirationCyclePressure;
}
inline bool MechanicalVentilatorData::has_expirationcyclepressure() const {
  return _internal_has_expirationcyclepressure();
}
inline void MechanicalVentilatorData::set_has_expirationcyclepressure() {
  _oneof_case_[1] = kExpirationCyclePressure;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::release_expirationcyclepressure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCyclePressure)
  if (_internal_has_expirationcyclepressure()) {
    clear_has_ExpirationCycle();
      ::pulse::cdm::bind::ScalarPressureData* temp = ExpirationCycle_.expirationcyclepressure_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ExpirationCycle_.expirationcyclepressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::_internal_expirationcyclepressure() const {
  return _internal_has_expirationcyclepressure()
      ? *ExpirationCycle_.expirationcyclepressure_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarPressureData&>(::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::expirationcyclepressure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCyclePressure)
  return _internal_expirationcyclepressure();
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::unsafe_arena_release_expirationcyclepressure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCyclePressure)
  if (_internal_has_expirationcyclepressure()) {
    clear_has_ExpirationCycle();
    ::pulse::cdm::bind::ScalarPressureData* temp = ExpirationCycle_.expirationcyclepressure_;
    ExpirationCycle_.expirationcyclepressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_expirationcyclepressure(::pulse::cdm::bind::ScalarPressureData* expirationcyclepressure) {
  clear_ExpirationCycle();
  if (expirationcyclepressure) {
    set_has_expirationcyclepressure();
    ExpirationCycle_.expirationcyclepressure_ = expirationcyclepressure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCyclePressure)
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::_internal_mutable_expirationcyclepressure() {
  if (!_internal_has_expirationcyclepressure()) {
    clear_ExpirationCycle();
    set_has_expirationcyclepressure();
    ExpirationCycle_.expirationcyclepressure_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarPressureData >(GetArena());
  }
  return ExpirationCycle_.expirationcyclepressure_;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::mutable_expirationcyclepressure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCyclePressure)
  return _internal_mutable_expirationcyclepressure();
}

// .pulse.cdm.bind.ScalarTimeData ExpirationCycleTime = 7;
inline bool MechanicalVentilatorData::_internal_has_expirationcycletime() const {
  return ExpirationCycle_case() == kExpirationCycleTime;
}
inline bool MechanicalVentilatorData::has_expirationcycletime() const {
  return _internal_has_expirationcycletime();
}
inline void MechanicalVentilatorData::set_has_expirationcycletime() {
  _oneof_case_[1] = kExpirationCycleTime;
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::release_expirationcycletime() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleTime)
  if (_internal_has_expirationcycletime()) {
    clear_has_ExpirationCycle();
      ::pulse::cdm::bind::ScalarTimeData* temp = ExpirationCycle_.expirationcycletime_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ExpirationCycle_.expirationcycletime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarTimeData& MechanicalVentilatorData::_internal_expirationcycletime() const {
  return _internal_has_expirationcycletime()
      ? *ExpirationCycle_.expirationcycletime_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarTimeData&>(::pulse::cdm::bind::_ScalarTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTimeData& MechanicalVentilatorData::expirationcycletime() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleTime)
  return _internal_expirationcycletime();
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::unsafe_arena_release_expirationcycletime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleTime)
  if (_internal_has_expirationcycletime()) {
    clear_has_ExpirationCycle();
    ::pulse::cdm::bind::ScalarTimeData* temp = ExpirationCycle_.expirationcycletime_;
    ExpirationCycle_.expirationcycletime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_expirationcycletime(::pulse::cdm::bind::ScalarTimeData* expirationcycletime) {
  clear_ExpirationCycle();
  if (expirationcycletime) {
    set_has_expirationcycletime();
    ExpirationCycle_.expirationcycletime_ = expirationcycletime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleTime)
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::_internal_mutable_expirationcycletime() {
  if (!_internal_has_expirationcycletime()) {
    clear_ExpirationCycle();
    set_has_expirationcycletime();
    ExpirationCycle_.expirationcycletime_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarTimeData >(GetArena());
  }
  return ExpirationCycle_.expirationcycletime_;
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::mutable_expirationcycletime() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleTime)
  return _internal_mutable_expirationcycletime();
}

// .pulse.cdm.bind.ScalarVolumeData ExpirationCycleVolume = 8;
inline bool MechanicalVentilatorData::_internal_has_expirationcyclevolume() const {
  return ExpirationCycle_case() == kExpirationCycleVolume;
}
inline bool MechanicalVentilatorData::has_expirationcyclevolume() const {
  return _internal_has_expirationcyclevolume();
}
inline void MechanicalVentilatorData::set_has_expirationcyclevolume() {
  _oneof_case_[1] = kExpirationCycleVolume;
}
inline ::pulse::cdm::bind::ScalarVolumeData* MechanicalVentilatorData::release_expirationcyclevolume() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleVolume)
  if (_internal_has_expirationcyclevolume()) {
    clear_has_ExpirationCycle();
      ::pulse::cdm::bind::ScalarVolumeData* temp = ExpirationCycle_.expirationcyclevolume_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ExpirationCycle_.expirationcyclevolume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarVolumeData& MechanicalVentilatorData::_internal_expirationcyclevolume() const {
  return _internal_has_expirationcyclevolume()
      ? *ExpirationCycle_.expirationcyclevolume_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarVolumeData&>(::pulse::cdm::bind::_ScalarVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumeData& MechanicalVentilatorData::expirationcyclevolume() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleVolume)
  return _internal_expirationcyclevolume();
}
inline ::pulse::cdm::bind::ScalarVolumeData* MechanicalVentilatorData::unsafe_arena_release_expirationcyclevolume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleVolume)
  if (_internal_has_expirationcyclevolume()) {
    clear_has_ExpirationCycle();
    ::pulse::cdm::bind::ScalarVolumeData* temp = ExpirationCycle_.expirationcyclevolume_;
    ExpirationCycle_.expirationcyclevolume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_expirationcyclevolume(::pulse::cdm::bind::ScalarVolumeData* expirationcyclevolume) {
  clear_ExpirationCycle();
  if (expirationcyclevolume) {
    set_has_expirationcyclevolume();
    ExpirationCycle_.expirationcyclevolume_ = expirationcyclevolume;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleVolume)
}
inline ::pulse::cdm::bind::ScalarVolumeData* MechanicalVentilatorData::_internal_mutable_expirationcyclevolume() {
  if (!_internal_has_expirationcyclevolume()) {
    clear_ExpirationCycle();
    set_has_expirationcyclevolume();
    ExpirationCycle_.expirationcyclevolume_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarVolumeData >(GetArena());
  }
  return ExpirationCycle_.expirationcyclevolume_;
}
inline ::pulse::cdm::bind::ScalarVolumeData* MechanicalVentilatorData::mutable_expirationcyclevolume() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.ExpirationCycleVolume)
  return _internal_mutable_expirationcyclevolume();
}

// .pulse.cdm.bind.ScalarPressureTimePerVolumeData ExpirationTubeResistance = 9;
inline bool MechanicalVentilatorData::_internal_has_expirationtuberesistance() const {
  return this != internal_default_instance() && expirationtuberesistance_ != nullptr;
}
inline bool MechanicalVentilatorData::has_expirationtuberesistance() const {
  return _internal_has_expirationtuberesistance();
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::_internal_expirationtuberesistance() const {
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* p = expirationtuberesistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimePerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::expirationtuberesistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.ExpirationTubeResistance)
  return _internal_expirationtuberesistance();
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_expirationtuberesistance(
    ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationtuberesistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expirationtuberesistance_);
  }
  expirationtuberesistance_ = expirationtuberesistance;
  if (expirationtuberesistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.ExpirationTubeResistance)
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::release_expirationtuberesistance() {
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = expirationtuberesistance_;
  expirationtuberesistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::unsafe_arena_release_expirationtuberesistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationTubeResistance)
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = expirationtuberesistance_;
  expirationtuberesistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::_internal_mutable_expirationtuberesistance() {
  
  if (expirationtuberesistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimePerVolumeData>(GetArena());
    expirationtuberesistance_ = p;
  }
  return expirationtuberesistance_;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::mutable_expirationtuberesistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.ExpirationTubeResistance)
  return _internal_mutable_expirationtuberesistance();
}
inline void MechanicalVentilatorData::set_allocated_expirationtuberesistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationtuberesistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expirationtuberesistance_);
  }
  if (expirationtuberesistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expirationtuberesistance)->GetArena();
    if (message_arena != submessage_arena) {
      expirationtuberesistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expirationtuberesistance, submessage_arena);
    }
    
  } else {
    
  }
  expirationtuberesistance_ = expirationtuberesistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.ExpirationTubeResistance)
}

// .pulse.cdm.bind.ScalarPressureTimePerVolumeData ExpirationValveResistance = 10;
inline bool MechanicalVentilatorData::_internal_has_expirationvalveresistance() const {
  return this != internal_default_instance() && expirationvalveresistance_ != nullptr;
}
inline bool MechanicalVentilatorData::has_expirationvalveresistance() const {
  return _internal_has_expirationvalveresistance();
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::_internal_expirationvalveresistance() const {
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* p = expirationvalveresistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimePerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::expirationvalveresistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.ExpirationValveResistance)
  return _internal_expirationvalveresistance();
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_expirationvalveresistance(
    ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationvalveresistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expirationvalveresistance_);
  }
  expirationvalveresistance_ = expirationvalveresistance;
  if (expirationvalveresistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.ExpirationValveResistance)
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::release_expirationvalveresistance() {
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = expirationvalveresistance_;
  expirationvalveresistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::unsafe_arena_release_expirationvalveresistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.ExpirationValveResistance)
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = expirationvalveresistance_;
  expirationvalveresistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::_internal_mutable_expirationvalveresistance() {
  
  if (expirationvalveresistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimePerVolumeData>(GetArena());
    expirationvalveresistance_ = p;
  }
  return expirationvalveresistance_;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::mutable_expirationvalveresistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.ExpirationValveResistance)
  return _internal_mutable_expirationvalveresistance();
}
inline void MechanicalVentilatorData::set_allocated_expirationvalveresistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* expirationvalveresistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expirationvalveresistance_);
  }
  if (expirationvalveresistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expirationvalveresistance)->GetArena();
    if (message_arena != submessage_arena) {
      expirationvalveresistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expirationvalveresistance, submessage_arena);
    }
    
  } else {
    
  }
  expirationvalveresistance_ = expirationvalveresistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.ExpirationValveResistance)
}

// .pulse.cdm.bind.MechanicalVentilatorData.eDriverWaveform ExpirationWaveform = 11;
inline void MechanicalVentilatorData::clear_expirationwaveform() {
  expirationwaveform_ = 0;
}
inline ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform MechanicalVentilatorData::_internal_expirationwaveform() const {
  return static_cast< ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform >(expirationwaveform_);
}
inline ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform MechanicalVentilatorData::expirationwaveform() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.ExpirationWaveform)
  return _internal_expirationwaveform();
}
inline void MechanicalVentilatorData::_internal_set_expirationwaveform(::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform value) {
  
  expirationwaveform_ = value;
}
inline void MechanicalVentilatorData::set_expirationwaveform(::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform value) {
  _internal_set_expirationwaveform(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.MechanicalVentilatorData.ExpirationWaveform)
}

// .pulse.cdm.bind.ScalarVolumePerTimeData InspirationLimitFlow = 12;
inline bool MechanicalVentilatorData::_internal_has_inspirationlimitflow() const {
  return InspirationLimit_case() == kInspirationLimitFlow;
}
inline bool MechanicalVentilatorData::has_inspirationlimitflow() const {
  return _internal_has_inspirationlimitflow();
}
inline void MechanicalVentilatorData::set_has_inspirationlimitflow() {
  _oneof_case_[2] = kInspirationLimitFlow;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::release_inspirationlimitflow() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitFlow)
  if (_internal_has_inspirationlimitflow()) {
    clear_has_InspirationLimit();
      ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = InspirationLimit_.inspirationlimitflow_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    InspirationLimit_.inspirationlimitflow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& MechanicalVentilatorData::_internal_inspirationlimitflow() const {
  return _internal_has_inspirationlimitflow()
      ? *InspirationLimit_.inspirationlimitflow_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarVolumePerTimeData&>(::pulse::cdm::bind::_ScalarVolumePerTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& MechanicalVentilatorData::inspirationlimitflow() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitFlow)
  return _internal_inspirationlimitflow();
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::unsafe_arena_release_inspirationlimitflow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitFlow)
  if (_internal_has_inspirationlimitflow()) {
    clear_has_InspirationLimit();
    ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = InspirationLimit_.inspirationlimitflow_;
    InspirationLimit_.inspirationlimitflow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationlimitflow(::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationlimitflow) {
  clear_InspirationLimit();
  if (inspirationlimitflow) {
    set_has_inspirationlimitflow();
    InspirationLimit_.inspirationlimitflow_ = inspirationlimitflow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitFlow)
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::_internal_mutable_inspirationlimitflow() {
  if (!_internal_has_inspirationlimitflow()) {
    clear_InspirationLimit();
    set_has_inspirationlimitflow();
    InspirationLimit_.inspirationlimitflow_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarVolumePerTimeData >(GetArena());
  }
  return InspirationLimit_.inspirationlimitflow_;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::mutable_inspirationlimitflow() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitFlow)
  return _internal_mutable_inspirationlimitflow();
}

// .pulse.cdm.bind.ScalarPressureData InspirationLimitPressure = 13;
inline bool MechanicalVentilatorData::_internal_has_inspirationlimitpressure() const {
  return InspirationLimit_case() == kInspirationLimitPressure;
}
inline bool MechanicalVentilatorData::has_inspirationlimitpressure() const {
  return _internal_has_inspirationlimitpressure();
}
inline void MechanicalVentilatorData::set_has_inspirationlimitpressure() {
  _oneof_case_[2] = kInspirationLimitPressure;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::release_inspirationlimitpressure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitPressure)
  if (_internal_has_inspirationlimitpressure()) {
    clear_has_InspirationLimit();
      ::pulse::cdm::bind::ScalarPressureData* temp = InspirationLimit_.inspirationlimitpressure_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    InspirationLimit_.inspirationlimitpressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::_internal_inspirationlimitpressure() const {
  return _internal_has_inspirationlimitpressure()
      ? *InspirationLimit_.inspirationlimitpressure_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarPressureData&>(::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::inspirationlimitpressure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitPressure)
  return _internal_inspirationlimitpressure();
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::unsafe_arena_release_inspirationlimitpressure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitPressure)
  if (_internal_has_inspirationlimitpressure()) {
    clear_has_InspirationLimit();
    ::pulse::cdm::bind::ScalarPressureData* temp = InspirationLimit_.inspirationlimitpressure_;
    InspirationLimit_.inspirationlimitpressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationlimitpressure(::pulse::cdm::bind::ScalarPressureData* inspirationlimitpressure) {
  clear_InspirationLimit();
  if (inspirationlimitpressure) {
    set_has_inspirationlimitpressure();
    InspirationLimit_.inspirationlimitpressure_ = inspirationlimitpressure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitPressure)
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::_internal_mutable_inspirationlimitpressure() {
  if (!_internal_has_inspirationlimitpressure()) {
    clear_InspirationLimit();
    set_has_inspirationlimitpressure();
    InspirationLimit_.inspirationlimitpressure_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarPressureData >(GetArena());
  }
  return InspirationLimit_.inspirationlimitpressure_;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::mutable_inspirationlimitpressure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitPressure)
  return _internal_mutable_inspirationlimitpressure();
}

// .pulse.cdm.bind.ScalarVolumeData InspirationLimitVolume = 14;
inline bool MechanicalVentilatorData::_internal_has_inspirationlimitvolume() const {
  return InspirationLimit_case() == kInspirationLimitVolume;
}
inline bool MechanicalVentilatorData::has_inspirationlimitvolume() const {
  return _internal_has_inspirationlimitvolume();
}
inline void MechanicalVentilatorData::set_has_inspirationlimitvolume() {
  _oneof_case_[2] = kInspirationLimitVolume;
}
inline ::pulse::cdm::bind::ScalarVolumeData* MechanicalVentilatorData::release_inspirationlimitvolume() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitVolume)
  if (_internal_has_inspirationlimitvolume()) {
    clear_has_InspirationLimit();
      ::pulse::cdm::bind::ScalarVolumeData* temp = InspirationLimit_.inspirationlimitvolume_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    InspirationLimit_.inspirationlimitvolume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarVolumeData& MechanicalVentilatorData::_internal_inspirationlimitvolume() const {
  return _internal_has_inspirationlimitvolume()
      ? *InspirationLimit_.inspirationlimitvolume_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarVolumeData&>(::pulse::cdm::bind::_ScalarVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumeData& MechanicalVentilatorData::inspirationlimitvolume() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitVolume)
  return _internal_inspirationlimitvolume();
}
inline ::pulse::cdm::bind::ScalarVolumeData* MechanicalVentilatorData::unsafe_arena_release_inspirationlimitvolume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitVolume)
  if (_internal_has_inspirationlimitvolume()) {
    clear_has_InspirationLimit();
    ::pulse::cdm::bind::ScalarVolumeData* temp = InspirationLimit_.inspirationlimitvolume_;
    InspirationLimit_.inspirationlimitvolume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationlimitvolume(::pulse::cdm::bind::ScalarVolumeData* inspirationlimitvolume) {
  clear_InspirationLimit();
  if (inspirationlimitvolume) {
    set_has_inspirationlimitvolume();
    InspirationLimit_.inspirationlimitvolume_ = inspirationlimitvolume;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitVolume)
}
inline ::pulse::cdm::bind::ScalarVolumeData* MechanicalVentilatorData::_internal_mutable_inspirationlimitvolume() {
  if (!_internal_has_inspirationlimitvolume()) {
    clear_InspirationLimit();
    set_has_inspirationlimitvolume();
    InspirationLimit_.inspirationlimitvolume_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarVolumeData >(GetArena());
  }
  return InspirationLimit_.inspirationlimitvolume_;
}
inline ::pulse::cdm::bind::ScalarVolumeData* MechanicalVentilatorData::mutable_inspirationlimitvolume() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationLimitVolume)
  return _internal_mutable_inspirationlimitvolume();
}

// .pulse.cdm.bind.ScalarTimeData InspirationPauseTime = 15;
inline bool MechanicalVentilatorData::_internal_has_inspirationpausetime() const {
  return this != internal_default_instance() && inspirationpausetime_ != nullptr;
}
inline bool MechanicalVentilatorData::has_inspirationpausetime() const {
  return _internal_has_inspirationpausetime();
}
inline const ::pulse::cdm::bind::ScalarTimeData& MechanicalVentilatorData::_internal_inspirationpausetime() const {
  const ::pulse::cdm::bind::ScalarTimeData* p = inspirationpausetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarTimeData&>(
      ::pulse::cdm::bind::_ScalarTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTimeData& MechanicalVentilatorData::inspirationpausetime() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationPauseTime)
  return _internal_inspirationpausetime();
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationpausetime(
    ::pulse::cdm::bind::ScalarTimeData* inspirationpausetime) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inspirationpausetime_);
  }
  inspirationpausetime_ = inspirationpausetime;
  if (inspirationpausetime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationPauseTime)
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::release_inspirationpausetime() {
  
  ::pulse::cdm::bind::ScalarTimeData* temp = inspirationpausetime_;
  inspirationpausetime_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::unsafe_arena_release_inspirationpausetime() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationPauseTime)
  
  ::pulse::cdm::bind::ScalarTimeData* temp = inspirationpausetime_;
  inspirationpausetime_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::_internal_mutable_inspirationpausetime() {
  
  if (inspirationpausetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarTimeData>(GetArena());
    inspirationpausetime_ = p;
  }
  return inspirationpausetime_;
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::mutable_inspirationpausetime() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationPauseTime)
  return _internal_mutable_inspirationpausetime();
}
inline void MechanicalVentilatorData::set_allocated_inspirationpausetime(::pulse::cdm::bind::ScalarTimeData* inspirationpausetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inspirationpausetime_);
  }
  if (inspirationpausetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inspirationpausetime)->GetArena();
    if (message_arena != submessage_arena) {
      inspirationpausetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inspirationpausetime, submessage_arena);
    }
    
  } else {
    
  }
  inspirationpausetime_ = inspirationpausetime;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationPauseTime)
}

// .pulse.cdm.bind.ScalarVolumePerTimeData InspirationTargetFlow = 16;
inline bool MechanicalVentilatorData::_internal_has_inspirationtargetflow() const {
  return InspiratoryTarget_case() == kInspirationTargetFlow;
}
inline bool MechanicalVentilatorData::has_inspirationtargetflow() const {
  return _internal_has_inspirationtargetflow();
}
inline void MechanicalVentilatorData::set_has_inspirationtargetflow() {
  _oneof_case_[3] = kInspirationTargetFlow;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::release_inspirationtargetflow() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationTargetFlow)
  if (_internal_has_inspirationtargetflow()) {
    clear_has_InspiratoryTarget();
      ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = InspiratoryTarget_.inspirationtargetflow_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    InspiratoryTarget_.inspirationtargetflow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& MechanicalVentilatorData::_internal_inspirationtargetflow() const {
  return _internal_has_inspirationtargetflow()
      ? *InspiratoryTarget_.inspirationtargetflow_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarVolumePerTimeData&>(::pulse::cdm::bind::_ScalarVolumePerTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& MechanicalVentilatorData::inspirationtargetflow() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationTargetFlow)
  return _internal_inspirationtargetflow();
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::unsafe_arena_release_inspirationtargetflow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationTargetFlow)
  if (_internal_has_inspirationtargetflow()) {
    clear_has_InspiratoryTarget();
    ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = InspiratoryTarget_.inspirationtargetflow_;
    InspiratoryTarget_.inspirationtargetflow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationtargetflow(::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationtargetflow) {
  clear_InspiratoryTarget();
  if (inspirationtargetflow) {
    set_has_inspirationtargetflow();
    InspiratoryTarget_.inspirationtargetflow_ = inspirationtargetflow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationTargetFlow)
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::_internal_mutable_inspirationtargetflow() {
  if (!_internal_has_inspirationtargetflow()) {
    clear_InspiratoryTarget();
    set_has_inspirationtargetflow();
    InspiratoryTarget_.inspirationtargetflow_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarVolumePerTimeData >(GetArena());
  }
  return InspiratoryTarget_.inspirationtargetflow_;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::mutable_inspirationtargetflow() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationTargetFlow)
  return _internal_mutable_inspirationtargetflow();
}

// .pulse.cdm.bind.ScalarPressureData PeakInspiratoryPressure = 17;
inline bool MechanicalVentilatorData::_internal_has_peakinspiratorypressure() const {
  return InspiratoryTarget_case() == kPeakInspiratoryPressure;
}
inline bool MechanicalVentilatorData::has_peakinspiratorypressure() const {
  return _internal_has_peakinspiratorypressure();
}
inline void MechanicalVentilatorData::set_has_peakinspiratorypressure() {
  _oneof_case_[3] = kPeakInspiratoryPressure;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::release_peakinspiratorypressure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.PeakInspiratoryPressure)
  if (_internal_has_peakinspiratorypressure()) {
    clear_has_InspiratoryTarget();
      ::pulse::cdm::bind::ScalarPressureData* temp = InspiratoryTarget_.peakinspiratorypressure_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    InspiratoryTarget_.peakinspiratorypressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::_internal_peakinspiratorypressure() const {
  return _internal_has_peakinspiratorypressure()
      ? *InspiratoryTarget_.peakinspiratorypressure_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarPressureData&>(::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::peakinspiratorypressure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.PeakInspiratoryPressure)
  return _internal_peakinspiratorypressure();
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::unsafe_arena_release_peakinspiratorypressure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.PeakInspiratoryPressure)
  if (_internal_has_peakinspiratorypressure()) {
    clear_has_InspiratoryTarget();
    ::pulse::cdm::bind::ScalarPressureData* temp = InspiratoryTarget_.peakinspiratorypressure_;
    InspiratoryTarget_.peakinspiratorypressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_peakinspiratorypressure(::pulse::cdm::bind::ScalarPressureData* peakinspiratorypressure) {
  clear_InspiratoryTarget();
  if (peakinspiratorypressure) {
    set_has_peakinspiratorypressure();
    InspiratoryTarget_.peakinspiratorypressure_ = peakinspiratorypressure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.PeakInspiratoryPressure)
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::_internal_mutable_peakinspiratorypressure() {
  if (!_internal_has_peakinspiratorypressure()) {
    clear_InspiratoryTarget();
    set_has_peakinspiratorypressure();
    InspiratoryTarget_.peakinspiratorypressure_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarPressureData >(GetArena());
  }
  return InspiratoryTarget_.peakinspiratorypressure_;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::mutable_peakinspiratorypressure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.PeakInspiratoryPressure)
  return _internal_mutable_peakinspiratorypressure();
}

// .pulse.cdm.bind.ScalarTimeData InspirationMachineTriggerTime = 18;
inline bool MechanicalVentilatorData::_internal_has_inspirationmachinetriggertime() const {
  return InspirationMachineTrigger_case() == kInspirationMachineTriggerTime;
}
inline bool MechanicalVentilatorData::has_inspirationmachinetriggertime() const {
  return _internal_has_inspirationmachinetriggertime();
}
inline void MechanicalVentilatorData::set_has_inspirationmachinetriggertime() {
  _oneof_case_[4] = kInspirationMachineTriggerTime;
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::release_inspirationmachinetriggertime() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationMachineTriggerTime)
  if (_internal_has_inspirationmachinetriggertime()) {
    clear_has_InspirationMachineTrigger();
      ::pulse::cdm::bind::ScalarTimeData* temp = InspirationMachineTrigger_.inspirationmachinetriggertime_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    InspirationMachineTrigger_.inspirationmachinetriggertime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarTimeData& MechanicalVentilatorData::_internal_inspirationmachinetriggertime() const {
  return _internal_has_inspirationmachinetriggertime()
      ? *InspirationMachineTrigger_.inspirationmachinetriggertime_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarTimeData&>(::pulse::cdm::bind::_ScalarTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTimeData& MechanicalVentilatorData::inspirationmachinetriggertime() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationMachineTriggerTime)
  return _internal_inspirationmachinetriggertime();
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::unsafe_arena_release_inspirationmachinetriggertime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationMachineTriggerTime)
  if (_internal_has_inspirationmachinetriggertime()) {
    clear_has_InspirationMachineTrigger();
    ::pulse::cdm::bind::ScalarTimeData* temp = InspirationMachineTrigger_.inspirationmachinetriggertime_;
    InspirationMachineTrigger_.inspirationmachinetriggertime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationmachinetriggertime(::pulse::cdm::bind::ScalarTimeData* inspirationmachinetriggertime) {
  clear_InspirationMachineTrigger();
  if (inspirationmachinetriggertime) {
    set_has_inspirationmachinetriggertime();
    InspirationMachineTrigger_.inspirationmachinetriggertime_ = inspirationmachinetriggertime;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationMachineTriggerTime)
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::_internal_mutable_inspirationmachinetriggertime() {
  if (!_internal_has_inspirationmachinetriggertime()) {
    clear_InspirationMachineTrigger();
    set_has_inspirationmachinetriggertime();
    InspirationMachineTrigger_.inspirationmachinetriggertime_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarTimeData >(GetArena());
  }
  return InspirationMachineTrigger_.inspirationmachinetriggertime_;
}
inline ::pulse::cdm::bind::ScalarTimeData* MechanicalVentilatorData::mutable_inspirationmachinetriggertime() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationMachineTriggerTime)
  return _internal_mutable_inspirationmachinetriggertime();
}

// .pulse.cdm.bind.ScalarVolumePerTimeData InspirationPatientTriggerFlow = 19;
inline bool MechanicalVentilatorData::_internal_has_inspirationpatienttriggerflow() const {
  return InspirationPatientTrigger_case() == kInspirationPatientTriggerFlow;
}
inline bool MechanicalVentilatorData::has_inspirationpatienttriggerflow() const {
  return _internal_has_inspirationpatienttriggerflow();
}
inline void MechanicalVentilatorData::set_has_inspirationpatienttriggerflow() {
  _oneof_case_[5] = kInspirationPatientTriggerFlow;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::release_inspirationpatienttriggerflow() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerFlow)
  if (_internal_has_inspirationpatienttriggerflow()) {
    clear_has_InspirationPatientTrigger();
      ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = InspirationPatientTrigger_.inspirationpatienttriggerflow_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    InspirationPatientTrigger_.inspirationpatienttriggerflow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& MechanicalVentilatorData::_internal_inspirationpatienttriggerflow() const {
  return _internal_has_inspirationpatienttriggerflow()
      ? *InspirationPatientTrigger_.inspirationpatienttriggerflow_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarVolumePerTimeData&>(::pulse::cdm::bind::_ScalarVolumePerTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& MechanicalVentilatorData::inspirationpatienttriggerflow() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerFlow)
  return _internal_inspirationpatienttriggerflow();
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::unsafe_arena_release_inspirationpatienttriggerflow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerFlow)
  if (_internal_has_inspirationpatienttriggerflow()) {
    clear_has_InspirationPatientTrigger();
    ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = InspirationPatientTrigger_.inspirationpatienttriggerflow_;
    InspirationPatientTrigger_.inspirationpatienttriggerflow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationpatienttriggerflow(::pulse::cdm::bind::ScalarVolumePerTimeData* inspirationpatienttriggerflow) {
  clear_InspirationPatientTrigger();
  if (inspirationpatienttriggerflow) {
    set_has_inspirationpatienttriggerflow();
    InspirationPatientTrigger_.inspirationpatienttriggerflow_ = inspirationpatienttriggerflow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerFlow)
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::_internal_mutable_inspirationpatienttriggerflow() {
  if (!_internal_has_inspirationpatienttriggerflow()) {
    clear_InspirationPatientTrigger();
    set_has_inspirationpatienttriggerflow();
    InspirationPatientTrigger_.inspirationpatienttriggerflow_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarVolumePerTimeData >(GetArena());
  }
  return InspirationPatientTrigger_.inspirationpatienttriggerflow_;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* MechanicalVentilatorData::mutable_inspirationpatienttriggerflow() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerFlow)
  return _internal_mutable_inspirationpatienttriggerflow();
}

// .pulse.cdm.bind.ScalarPressureData InspirationPatientTriggerPressure = 20;
inline bool MechanicalVentilatorData::_internal_has_inspirationpatienttriggerpressure() const {
  return InspirationPatientTrigger_case() == kInspirationPatientTriggerPressure;
}
inline bool MechanicalVentilatorData::has_inspirationpatienttriggerpressure() const {
  return _internal_has_inspirationpatienttriggerpressure();
}
inline void MechanicalVentilatorData::set_has_inspirationpatienttriggerpressure() {
  _oneof_case_[5] = kInspirationPatientTriggerPressure;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::release_inspirationpatienttriggerpressure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerPressure)
  if (_internal_has_inspirationpatienttriggerpressure()) {
    clear_has_InspirationPatientTrigger();
      ::pulse::cdm::bind::ScalarPressureData* temp = InspirationPatientTrigger_.inspirationpatienttriggerpressure_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    InspirationPatientTrigger_.inspirationpatienttriggerpressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::_internal_inspirationpatienttriggerpressure() const {
  return _internal_has_inspirationpatienttriggerpressure()
      ? *InspirationPatientTrigger_.inspirationpatienttriggerpressure_
      : reinterpret_cast< ::pulse::cdm::bind::ScalarPressureData&>(::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& MechanicalVentilatorData::inspirationpatienttriggerpressure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerPressure)
  return _internal_inspirationpatienttriggerpressure();
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::unsafe_arena_release_inspirationpatienttriggerpressure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerPressure)
  if (_internal_has_inspirationpatienttriggerpressure()) {
    clear_has_InspirationPatientTrigger();
    ::pulse::cdm::bind::ScalarPressureData* temp = InspirationPatientTrigger_.inspirationpatienttriggerpressure_;
    InspirationPatientTrigger_.inspirationpatienttriggerpressure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationpatienttriggerpressure(::pulse::cdm::bind::ScalarPressureData* inspirationpatienttriggerpressure) {
  clear_InspirationPatientTrigger();
  if (inspirationpatienttriggerpressure) {
    set_has_inspirationpatienttriggerpressure();
    InspirationPatientTrigger_.inspirationpatienttriggerpressure_ = inspirationpatienttriggerpressure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerPressure)
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::_internal_mutable_inspirationpatienttriggerpressure() {
  if (!_internal_has_inspirationpatienttriggerpressure()) {
    clear_InspirationPatientTrigger();
    set_has_inspirationpatienttriggerpressure();
    InspirationPatientTrigger_.inspirationpatienttriggerpressure_ = CreateMaybeMessage< ::pulse::cdm::bind::ScalarPressureData >(GetArena());
  }
  return InspirationPatientTrigger_.inspirationpatienttriggerpressure_;
}
inline ::pulse::cdm::bind::ScalarPressureData* MechanicalVentilatorData::mutable_inspirationpatienttriggerpressure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationPatientTriggerPressure)
  return _internal_mutable_inspirationpatienttriggerpressure();
}

// .pulse.cdm.bind.ScalarPressureTimePerVolumeData InspirationTubeResistance = 21;
inline bool MechanicalVentilatorData::_internal_has_inspirationtuberesistance() const {
  return this != internal_default_instance() && inspirationtuberesistance_ != nullptr;
}
inline bool MechanicalVentilatorData::has_inspirationtuberesistance() const {
  return _internal_has_inspirationtuberesistance();
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::_internal_inspirationtuberesistance() const {
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* p = inspirationtuberesistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimePerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::inspirationtuberesistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationTubeResistance)
  return _internal_inspirationtuberesistance();
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationtuberesistance(
    ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationtuberesistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inspirationtuberesistance_);
  }
  inspirationtuberesistance_ = inspirationtuberesistance;
  if (inspirationtuberesistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationTubeResistance)
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::release_inspirationtuberesistance() {
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = inspirationtuberesistance_;
  inspirationtuberesistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::unsafe_arena_release_inspirationtuberesistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationTubeResistance)
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = inspirationtuberesistance_;
  inspirationtuberesistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::_internal_mutable_inspirationtuberesistance() {
  
  if (inspirationtuberesistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimePerVolumeData>(GetArena());
    inspirationtuberesistance_ = p;
  }
  return inspirationtuberesistance_;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::mutable_inspirationtuberesistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationTubeResistance)
  return _internal_mutable_inspirationtuberesistance();
}
inline void MechanicalVentilatorData::set_allocated_inspirationtuberesistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationtuberesistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inspirationtuberesistance_);
  }
  if (inspirationtuberesistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inspirationtuberesistance)->GetArena();
    if (message_arena != submessage_arena) {
      inspirationtuberesistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inspirationtuberesistance, submessage_arena);
    }
    
  } else {
    
  }
  inspirationtuberesistance_ = inspirationtuberesistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationTubeResistance)
}

// .pulse.cdm.bind.ScalarPressureTimePerVolumeData InspirationValveResistance = 22;
inline bool MechanicalVentilatorData::_internal_has_inspirationvalveresistance() const {
  return this != internal_default_instance() && inspirationvalveresistance_ != nullptr;
}
inline bool MechanicalVentilatorData::has_inspirationvalveresistance() const {
  return _internal_has_inspirationvalveresistance();
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::_internal_inspirationvalveresistance() const {
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* p = inspirationvalveresistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimePerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& MechanicalVentilatorData::inspirationvalveresistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationValveResistance)
  return _internal_inspirationvalveresistance();
}
inline void MechanicalVentilatorData::unsafe_arena_set_allocated_inspirationvalveresistance(
    ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationvalveresistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inspirationvalveresistance_);
  }
  inspirationvalveresistance_ = inspirationvalveresistance;
  if (inspirationvalveresistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationValveResistance)
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::release_inspirationvalveresistance() {
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = inspirationvalveresistance_;
  inspirationvalveresistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::unsafe_arena_release_inspirationvalveresistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.MechanicalVentilatorData.InspirationValveResistance)
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = inspirationvalveresistance_;
  inspirationvalveresistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::_internal_mutable_inspirationvalveresistance() {
  
  if (inspirationvalveresistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimePerVolumeData>(GetArena());
    inspirationvalveresistance_ = p;
  }
  return inspirationvalveresistance_;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* MechanicalVentilatorData::mutable_inspirationvalveresistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.InspirationValveResistance)
  return _internal_mutable_inspirationvalveresistance();
}
inline void MechanicalVentilatorData::set_allocated_inspirationvalveresistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* inspirationvalveresistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inspirationvalveresistance_);
  }
  if (inspirationvalveresistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inspirationvalveresistance)->GetArena();
    if (message_arena != submessage_arena) {
      inspirationvalveresistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inspirationvalveresistance, submessage_arena);
    }
    
  } else {
    
  }
  inspirationvalveresistance_ = inspirationvalveresistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.MechanicalVentilatorData.InspirationValveResistance)
}

// .pulse.cdm.bind.MechanicalVentilatorData.eDriverWaveform InspirationWaveform = 23;
inline void MechanicalVentilatorData::clear_inspirationwaveform() {
  inspirationwaveform_ = 0;
}
inline ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform MechanicalVentilatorData::_internal_inspirationwaveform() const {
  return static_cast< ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform >(inspirationwaveform_);
}
inline ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform MechanicalVentilatorData::inspirationwaveform() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.InspirationWaveform)
  return _internal_inspirationwaveform();
}
inline void MechanicalVentilatorData::_internal_set_inspirationwaveform(::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform value) {
  
  inspirationwaveform_ = value;
}
inline void MechanicalVentilatorData::set_inspirationwaveform(::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform value) {
  _internal_set_inspirationwaveform(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.MechanicalVentilatorData.InspirationWaveform)
}

// repeated .pulse.cdm.bind.SubstanceFractionData FractionInspiredGas = 24;
inline int MechanicalVentilatorData::_internal_fractioninspiredgas_size() const {
  return fractioninspiredgas_.size();
}
inline int MechanicalVentilatorData::fractioninspiredgas_size() const {
  return _internal_fractioninspiredgas_size();
}
inline ::pulse::cdm::bind::SubstanceFractionData* MechanicalVentilatorData::mutable_fractioninspiredgas(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.FractionInspiredGas)
  return fractioninspiredgas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceFractionData >*
MechanicalVentilatorData::mutable_fractioninspiredgas() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.MechanicalVentilatorData.FractionInspiredGas)
  return &fractioninspiredgas_;
}
inline const ::pulse::cdm::bind::SubstanceFractionData& MechanicalVentilatorData::_internal_fractioninspiredgas(int index) const {
  return fractioninspiredgas_.Get(index);
}
inline const ::pulse::cdm::bind::SubstanceFractionData& MechanicalVentilatorData::fractioninspiredgas(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.FractionInspiredGas)
  return _internal_fractioninspiredgas(index);
}
inline ::pulse::cdm::bind::SubstanceFractionData* MechanicalVentilatorData::_internal_add_fractioninspiredgas() {
  return fractioninspiredgas_.Add();
}
inline ::pulse::cdm::bind::SubstanceFractionData* MechanicalVentilatorData::add_fractioninspiredgas() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.MechanicalVentilatorData.FractionInspiredGas)
  return _internal_add_fractioninspiredgas();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceFractionData >&
MechanicalVentilatorData::fractioninspiredgas() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.MechanicalVentilatorData.FractionInspiredGas)
  return fractioninspiredgas_;
}

// repeated .pulse.cdm.bind.SubstanceConcentrationData ConcentrationInspiredAerosol = 25;
inline int MechanicalVentilatorData::_internal_concentrationinspiredaerosol_size() const {
  return concentrationinspiredaerosol_.size();
}
inline int MechanicalVentilatorData::concentrationinspiredaerosol_size() const {
  return _internal_concentrationinspiredaerosol_size();
}
inline ::pulse::cdm::bind::SubstanceConcentrationData* MechanicalVentilatorData::mutable_concentrationinspiredaerosol(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.MechanicalVentilatorData.ConcentrationInspiredAerosol)
  return concentrationinspiredaerosol_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceConcentrationData >*
MechanicalVentilatorData::mutable_concentrationinspiredaerosol() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.MechanicalVentilatorData.ConcentrationInspiredAerosol)
  return &concentrationinspiredaerosol_;
}
inline const ::pulse::cdm::bind::SubstanceConcentrationData& MechanicalVentilatorData::_internal_concentrationinspiredaerosol(int index) const {
  return concentrationinspiredaerosol_.Get(index);
}
inline const ::pulse::cdm::bind::SubstanceConcentrationData& MechanicalVentilatorData::concentrationinspiredaerosol(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.MechanicalVentilatorData.ConcentrationInspiredAerosol)
  return _internal_concentrationinspiredaerosol(index);
}
inline ::pulse::cdm::bind::SubstanceConcentrationData* MechanicalVentilatorData::_internal_add_concentrationinspiredaerosol() {
  return concentrationinspiredaerosol_.Add();
}
inline ::pulse::cdm::bind::SubstanceConcentrationData* MechanicalVentilatorData::add_concentrationinspiredaerosol() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.MechanicalVentilatorData.ConcentrationInspiredAerosol)
  return _internal_add_concentrationinspiredaerosol();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceConcentrationData >&
MechanicalVentilatorData::concentrationinspiredaerosol() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.MechanicalVentilatorData.ConcentrationInspiredAerosol)
  return concentrationinspiredaerosol_;
}

inline bool MechanicalVentilatorData::has_ExpiratoryBaseline() const {
  return ExpiratoryBaseline_case() != EXPIRATORYBASELINE_NOT_SET;
}
inline void MechanicalVentilatorData::clear_has_ExpiratoryBaseline() {
  _oneof_case_[0] = EXPIRATORYBASELINE_NOT_SET;
}
inline bool MechanicalVentilatorData::has_ExpirationCycle() const {
  return ExpirationCycle_case() != EXPIRATIONCYCLE_NOT_SET;
}
inline void MechanicalVentilatorData::clear_has_ExpirationCycle() {
  _oneof_case_[1] = EXPIRATIONCYCLE_NOT_SET;
}
inline bool MechanicalVentilatorData::has_InspirationLimit() const {
  return InspirationLimit_case() != INSPIRATIONLIMIT_NOT_SET;
}
inline void MechanicalVentilatorData::clear_has_InspirationLimit() {
  _oneof_case_[2] = INSPIRATIONLIMIT_NOT_SET;
}
inline bool MechanicalVentilatorData::has_InspiratoryTarget() const {
  return InspiratoryTarget_case() != INSPIRATORYTARGET_NOT_SET;
}
inline void MechanicalVentilatorData::clear_has_InspiratoryTarget() {
  _oneof_case_[3] = INSPIRATORYTARGET_NOT_SET;
}
inline bool MechanicalVentilatorData::has_InspirationMachineTrigger() const {
  return InspirationMachineTrigger_case() != INSPIRATIONMACHINETRIGGER_NOT_SET;
}
inline void MechanicalVentilatorData::clear_has_InspirationMachineTrigger() {
  _oneof_case_[4] = INSPIRATIONMACHINETRIGGER_NOT_SET;
}
inline bool MechanicalVentilatorData::has_InspirationPatientTrigger() const {
  return InspirationPatientTrigger_case() != INSPIRATIONPATIENTTRIGGER_NOT_SET;
}
inline void MechanicalVentilatorData::clear_has_InspirationPatientTrigger() {
  _oneof_case_[5] = INSPIRATIONPATIENTTRIGGER_NOT_SET;
}
inline MechanicalVentilatorData::ExpiratoryBaselineCase MechanicalVentilatorData::ExpiratoryBaseline_case() const {
  return MechanicalVentilatorData::ExpiratoryBaselineCase(_oneof_case_[0]);
}
inline MechanicalVentilatorData::ExpirationCycleCase MechanicalVentilatorData::ExpirationCycle_case() const {
  return MechanicalVentilatorData::ExpirationCycleCase(_oneof_case_[1]);
}
inline MechanicalVentilatorData::InspirationLimitCase MechanicalVentilatorData::InspirationLimit_case() const {
  return MechanicalVentilatorData::InspirationLimitCase(_oneof_case_[2]);
}
inline MechanicalVentilatorData::InspiratoryTargetCase MechanicalVentilatorData::InspiratoryTarget_case() const {
  return MechanicalVentilatorData::InspiratoryTargetCase(_oneof_case_[3]);
}
inline MechanicalVentilatorData::InspirationMachineTriggerCase MechanicalVentilatorData::InspirationMachineTrigger_case() const {
  return MechanicalVentilatorData::InspirationMachineTriggerCase(_oneof_case_[4]);
}
inline MechanicalVentilatorData::InspirationPatientTriggerCase MechanicalVentilatorData::InspirationPatientTrigger_case() const {
  return MechanicalVentilatorData::InspirationPatientTriggerCase(_oneof_case_[5]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace bind
}  // namespace cdm
}  // namespace pulse

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pulse::cdm::bind::MechanicalVentilatorData_eConnection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pulse::cdm::bind::MechanicalVentilatorData_eConnection>() {
  return ::pulse::cdm::bind::MechanicalVentilatorData_eConnection_descriptor();
}
template <> struct is_proto_enum< ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform>() {
  return ::pulse::cdm::bind::MechanicalVentilatorData_eDriverWaveform_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pulse_2fcdm_2fbind_2fMechanicalVentilator_2eproto
