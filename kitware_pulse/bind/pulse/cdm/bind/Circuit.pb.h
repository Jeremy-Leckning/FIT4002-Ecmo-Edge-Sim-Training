// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pulse/cdm/bind/Circuit.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pulse_2fcdm_2fbind_2fCircuit_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pulse_2fcdm_2fbind_2fCircuit_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "pulse/cdm/bind/Enums.pb.h"
#include "pulse/cdm/bind/Properties.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto;
namespace pulse {
namespace cdm {
namespace bind {
class CircuitData;
class CircuitDataDefaultTypeInternal;
extern CircuitDataDefaultTypeInternal _CircuitData_default_instance_;
class CircuitManagerData;
class CircuitManagerDataDefaultTypeInternal;
extern CircuitManagerDataDefaultTypeInternal _CircuitManagerData_default_instance_;
class CircuitNodeData;
class CircuitNodeDataDefaultTypeInternal;
extern CircuitNodeDataDefaultTypeInternal _CircuitNodeData_default_instance_;
class CircuitPathData;
class CircuitPathDataDefaultTypeInternal;
extern CircuitPathDataDefaultTypeInternal _CircuitPathData_default_instance_;
class ElectricalCircuitData;
class ElectricalCircuitDataDefaultTypeInternal;
extern ElectricalCircuitDataDefaultTypeInternal _ElectricalCircuitData_default_instance_;
class ElectricalCircuitNodeData;
class ElectricalCircuitNodeDataDefaultTypeInternal;
extern ElectricalCircuitNodeDataDefaultTypeInternal _ElectricalCircuitNodeData_default_instance_;
class ElectricalCircuitPathData;
class ElectricalCircuitPathDataDefaultTypeInternal;
extern ElectricalCircuitPathDataDefaultTypeInternal _ElectricalCircuitPathData_default_instance_;
class FluidCircuitData;
class FluidCircuitDataDefaultTypeInternal;
extern FluidCircuitDataDefaultTypeInternal _FluidCircuitData_default_instance_;
class FluidCircuitNodeData;
class FluidCircuitNodeDataDefaultTypeInternal;
extern FluidCircuitNodeDataDefaultTypeInternal _FluidCircuitNodeData_default_instance_;
class FluidCircuitPathData;
class FluidCircuitPathDataDefaultTypeInternal;
extern FluidCircuitPathDataDefaultTypeInternal _FluidCircuitPathData_default_instance_;
class ThermalCircuitData;
class ThermalCircuitDataDefaultTypeInternal;
extern ThermalCircuitDataDefaultTypeInternal _ThermalCircuitData_default_instance_;
class ThermalCircuitNodeData;
class ThermalCircuitNodeDataDefaultTypeInternal;
extern ThermalCircuitNodeDataDefaultTypeInternal _ThermalCircuitNodeData_default_instance_;
class ThermalCircuitPathData;
class ThermalCircuitPathDataDefaultTypeInternal;
extern ThermalCircuitPathDataDefaultTypeInternal _ThermalCircuitPathData_default_instance_;
}  // namespace bind
}  // namespace cdm
}  // namespace pulse
PROTOBUF_NAMESPACE_OPEN
template<> ::pulse::cdm::bind::CircuitData* Arena::CreateMaybeMessage<::pulse::cdm::bind::CircuitData>(Arena*);
template<> ::pulse::cdm::bind::CircuitManagerData* Arena::CreateMaybeMessage<::pulse::cdm::bind::CircuitManagerData>(Arena*);
template<> ::pulse::cdm::bind::CircuitNodeData* Arena::CreateMaybeMessage<::pulse::cdm::bind::CircuitNodeData>(Arena*);
template<> ::pulse::cdm::bind::CircuitPathData* Arena::CreateMaybeMessage<::pulse::cdm::bind::CircuitPathData>(Arena*);
template<> ::pulse::cdm::bind::ElectricalCircuitData* Arena::CreateMaybeMessage<::pulse::cdm::bind::ElectricalCircuitData>(Arena*);
template<> ::pulse::cdm::bind::ElectricalCircuitNodeData* Arena::CreateMaybeMessage<::pulse::cdm::bind::ElectricalCircuitNodeData>(Arena*);
template<> ::pulse::cdm::bind::ElectricalCircuitPathData* Arena::CreateMaybeMessage<::pulse::cdm::bind::ElectricalCircuitPathData>(Arena*);
template<> ::pulse::cdm::bind::FluidCircuitData* Arena::CreateMaybeMessage<::pulse::cdm::bind::FluidCircuitData>(Arena*);
template<> ::pulse::cdm::bind::FluidCircuitNodeData* Arena::CreateMaybeMessage<::pulse::cdm::bind::FluidCircuitNodeData>(Arena*);
template<> ::pulse::cdm::bind::FluidCircuitPathData* Arena::CreateMaybeMessage<::pulse::cdm::bind::FluidCircuitPathData>(Arena*);
template<> ::pulse::cdm::bind::ThermalCircuitData* Arena::CreateMaybeMessage<::pulse::cdm::bind::ThermalCircuitData>(Arena*);
template<> ::pulse::cdm::bind::ThermalCircuitNodeData* Arena::CreateMaybeMessage<::pulse::cdm::bind::ThermalCircuitNodeData>(Arena*);
template<> ::pulse::cdm::bind::ThermalCircuitPathData* Arena::CreateMaybeMessage<::pulse::cdm::bind::ThermalCircuitPathData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pulse {
namespace cdm {
namespace bind {

// ===================================================================

class CircuitData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.CircuitData) */ {
 public:
  inline CircuitData() : CircuitData(nullptr) {}
  virtual ~CircuitData();

  CircuitData(const CircuitData& from);
  CircuitData(CircuitData&& from) noexcept
    : CircuitData() {
    *this = ::std::move(from);
  }

  inline CircuitData& operator=(const CircuitData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitData& operator=(CircuitData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitData& default_instance();

  static inline const CircuitData* internal_default_instance() {
    return reinterpret_cast<const CircuitData*>(
               &_CircuitData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CircuitData& a, CircuitData& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitData* New() const final {
    return CreateMaybeMessage<CircuitData>(nullptr);
  }

  CircuitData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitData& from);
  void MergeFrom(const CircuitData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.CircuitData";
  }
  protected:
  explicit CircuitData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 2,
    kPathFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // repeated string Node = 2;
  int node_size() const;
  private:
  int _internal_node_size() const;
  public:
  void clear_node();
  const std::string& node(int index) const;
  std::string* mutable_node(int index);
  void set_node(int index, const std::string& value);
  void set_node(int index, std::string&& value);
  void set_node(int index, const char* value);
  void set_node(int index, const char* value, size_t size);
  std::string* add_node();
  void add_node(const std::string& value);
  void add_node(std::string&& value);
  void add_node(const char* value);
  void add_node(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& node() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_node();
  private:
  const std::string& _internal_node(int index) const;
  std::string* _internal_add_node();
  public:

  // repeated string Path = 3;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  const std::string& path(int index) const;
  std::string* mutable_path(int index);
  void set_path(int index, const std::string& value);
  void set_path(int index, std::string&& value);
  void set_path(int index, const char* value);
  void set_path(int index, const char* value, size_t size);
  std::string* add_path();
  void add_path(const std::string& value);
  void add_path(std::string&& value);
  void add_path(const char* value);
  void add_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_path();
  private:
  const std::string& _internal_path(int index) const;
  std::string* _internal_add_path();
  public:

  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.CircuitData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> node_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class CircuitNodeData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.CircuitNodeData) */ {
 public:
  inline CircuitNodeData() : CircuitNodeData(nullptr) {}
  virtual ~CircuitNodeData();

  CircuitNodeData(const CircuitNodeData& from);
  CircuitNodeData(CircuitNodeData&& from) noexcept
    : CircuitNodeData() {
    *this = ::std::move(from);
  }

  inline CircuitNodeData& operator=(const CircuitNodeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitNodeData& operator=(CircuitNodeData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitNodeData& default_instance();

  static inline const CircuitNodeData* internal_default_instance() {
    return reinterpret_cast<const CircuitNodeData*>(
               &_CircuitNodeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CircuitNodeData& a, CircuitNodeData& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitNodeData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitNodeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitNodeData* New() const final {
    return CreateMaybeMessage<CircuitNodeData>(nullptr);
  }

  CircuitNodeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitNodeData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitNodeData& from);
  void MergeFrom(const CircuitNodeData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitNodeData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.CircuitNodeData";
  }
  protected:
  explicit CircuitNodeData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kReferenceNodeFieldNumber = 2,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool ReferenceNode = 2;
  void clear_referencenode();
  bool referencenode() const;
  void set_referencenode(bool value);
  private:
  bool _internal_referencenode() const;
  void _internal_set_referencenode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.CircuitNodeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool referencenode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class CircuitPathData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.CircuitPathData) */ {
 public:
  inline CircuitPathData() : CircuitPathData(nullptr) {}
  virtual ~CircuitPathData();

  CircuitPathData(const CircuitPathData& from);
  CircuitPathData(CircuitPathData&& from) noexcept
    : CircuitPathData() {
    *this = ::std::move(from);
  }

  inline CircuitPathData& operator=(const CircuitPathData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitPathData& operator=(CircuitPathData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitPathData& default_instance();

  static inline const CircuitPathData* internal_default_instance() {
    return reinterpret_cast<const CircuitPathData*>(
               &_CircuitPathData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CircuitPathData& a, CircuitPathData& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitPathData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitPathData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitPathData* New() const final {
    return CreateMaybeMessage<CircuitPathData>(nullptr);
  }

  CircuitPathData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitPathData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitPathData& from);
  void MergeFrom(const CircuitPathData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitPathData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.CircuitPathData";
  }
  protected:
  explicit CircuitPathData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSourceNodeFieldNumber = 2,
    kTargetNodeFieldNumber = 3,
    kSwitchFieldNumber = 4,
    kNextSwitchFieldNumber = 5,
    kValveFieldNumber = 6,
    kNextValveFieldNumber = 7,
    kPolarizedStateFieldNumber = 8,
    kNextPolarizedStateFieldNumber = 9,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string SourceNode = 2;
  void clear_sourcenode();
  const std::string& sourcenode() const;
  void set_sourcenode(const std::string& value);
  void set_sourcenode(std::string&& value);
  void set_sourcenode(const char* value);
  void set_sourcenode(const char* value, size_t size);
  std::string* mutable_sourcenode();
  std::string* release_sourcenode();
  void set_allocated_sourcenode(std::string* sourcenode);
  private:
  const std::string& _internal_sourcenode() const;
  void _internal_set_sourcenode(const std::string& value);
  std::string* _internal_mutable_sourcenode();
  public:

  // string TargetNode = 3;
  void clear_targetnode();
  const std::string& targetnode() const;
  void set_targetnode(const std::string& value);
  void set_targetnode(std::string&& value);
  void set_targetnode(const char* value);
  void set_targetnode(const char* value, size_t size);
  std::string* mutable_targetnode();
  std::string* release_targetnode();
  void set_allocated_targetnode(std::string* targetnode);
  private:
  const std::string& _internal_targetnode() const;
  void _internal_set_targetnode(const std::string& value);
  std::string* _internal_mutable_targetnode();
  public:

  // .pulse.cdm.bind.eGate Switch = 4;
  void clear_switch_();
  ::pulse::cdm::bind::eGate switch_() const;
  void set_switch_(::pulse::cdm::bind::eGate value);
  private:
  ::pulse::cdm::bind::eGate _internal_switch_() const;
  void _internal_set_switch_(::pulse::cdm::bind::eGate value);
  public:

  // .pulse.cdm.bind.eGate NextSwitch = 5;
  void clear_nextswitch();
  ::pulse::cdm::bind::eGate nextswitch() const;
  void set_nextswitch(::pulse::cdm::bind::eGate value);
  private:
  ::pulse::cdm::bind::eGate _internal_nextswitch() const;
  void _internal_set_nextswitch(::pulse::cdm::bind::eGate value);
  public:

  // .pulse.cdm.bind.eGate Valve = 6;
  void clear_valve();
  ::pulse::cdm::bind::eGate valve() const;
  void set_valve(::pulse::cdm::bind::eGate value);
  private:
  ::pulse::cdm::bind::eGate _internal_valve() const;
  void _internal_set_valve(::pulse::cdm::bind::eGate value);
  public:

  // .pulse.cdm.bind.eGate NextValve = 7;
  void clear_nextvalve();
  ::pulse::cdm::bind::eGate nextvalve() const;
  void set_nextvalve(::pulse::cdm::bind::eGate value);
  private:
  ::pulse::cdm::bind::eGate _internal_nextvalve() const;
  void _internal_set_nextvalve(::pulse::cdm::bind::eGate value);
  public:

  // .pulse.cdm.bind.eGate PolarizedState = 8;
  void clear_polarizedstate();
  ::pulse::cdm::bind::eGate polarizedstate() const;
  void set_polarizedstate(::pulse::cdm::bind::eGate value);
  private:
  ::pulse::cdm::bind::eGate _internal_polarizedstate() const;
  void _internal_set_polarizedstate(::pulse::cdm::bind::eGate value);
  public:

  // .pulse.cdm.bind.eGate NextPolarizedState = 9;
  void clear_nextpolarizedstate();
  ::pulse::cdm::bind::eGate nextpolarizedstate() const;
  void set_nextpolarizedstate(::pulse::cdm::bind::eGate value);
  private:
  ::pulse::cdm::bind::eGate _internal_nextpolarizedstate() const;
  void _internal_set_nextpolarizedstate(::pulse::cdm::bind::eGate value);
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.CircuitPathData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcenode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetnode_;
  int switch__;
  int nextswitch_;
  int valve_;
  int nextvalve_;
  int polarizedstate_;
  int nextpolarizedstate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class ElectricalCircuitData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.ElectricalCircuitData) */ {
 public:
  inline ElectricalCircuitData() : ElectricalCircuitData(nullptr) {}
  virtual ~ElectricalCircuitData();

  ElectricalCircuitData(const ElectricalCircuitData& from);
  ElectricalCircuitData(ElectricalCircuitData&& from) noexcept
    : ElectricalCircuitData() {
    *this = ::std::move(from);
  }

  inline ElectricalCircuitData& operator=(const ElectricalCircuitData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElectricalCircuitData& operator=(ElectricalCircuitData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ElectricalCircuitData& default_instance();

  static inline const ElectricalCircuitData* internal_default_instance() {
    return reinterpret_cast<const ElectricalCircuitData*>(
               &_ElectricalCircuitData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ElectricalCircuitData& a, ElectricalCircuitData& b) {
    a.Swap(&b);
  }
  inline void Swap(ElectricalCircuitData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElectricalCircuitData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ElectricalCircuitData* New() const final {
    return CreateMaybeMessage<ElectricalCircuitData>(nullptr);
  }

  ElectricalCircuitData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ElectricalCircuitData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ElectricalCircuitData& from);
  void MergeFrom(const ElectricalCircuitData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElectricalCircuitData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.ElectricalCircuitData";
  }
  protected:
  explicit ElectricalCircuitData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircuitFieldNumber = 1,
  };
  // .pulse.cdm.bind.CircuitData Circuit = 1;
  bool has_circuit() const;
  private:
  bool _internal_has_circuit() const;
  public:
  void clear_circuit();
  const ::pulse::cdm::bind::CircuitData& circuit() const;
  ::pulse::cdm::bind::CircuitData* release_circuit();
  ::pulse::cdm::bind::CircuitData* mutable_circuit();
  void set_allocated_circuit(::pulse::cdm::bind::CircuitData* circuit);
  private:
  const ::pulse::cdm::bind::CircuitData& _internal_circuit() const;
  ::pulse::cdm::bind::CircuitData* _internal_mutable_circuit();
  public:
  void unsafe_arena_set_allocated_circuit(
      ::pulse::cdm::bind::CircuitData* circuit);
  ::pulse::cdm::bind::CircuitData* unsafe_arena_release_circuit();

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.ElectricalCircuitData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pulse::cdm::bind::CircuitData* circuit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class ElectricalCircuitNodeData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.ElectricalCircuitNodeData) */ {
 public:
  inline ElectricalCircuitNodeData() : ElectricalCircuitNodeData(nullptr) {}
  virtual ~ElectricalCircuitNodeData();

  ElectricalCircuitNodeData(const ElectricalCircuitNodeData& from);
  ElectricalCircuitNodeData(ElectricalCircuitNodeData&& from) noexcept
    : ElectricalCircuitNodeData() {
    *this = ::std::move(from);
  }

  inline ElectricalCircuitNodeData& operator=(const ElectricalCircuitNodeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElectricalCircuitNodeData& operator=(ElectricalCircuitNodeData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ElectricalCircuitNodeData& default_instance();

  static inline const ElectricalCircuitNodeData* internal_default_instance() {
    return reinterpret_cast<const ElectricalCircuitNodeData*>(
               &_ElectricalCircuitNodeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ElectricalCircuitNodeData& a, ElectricalCircuitNodeData& b) {
    a.Swap(&b);
  }
  inline void Swap(ElectricalCircuitNodeData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElectricalCircuitNodeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ElectricalCircuitNodeData* New() const final {
    return CreateMaybeMessage<ElectricalCircuitNodeData>(nullptr);
  }

  ElectricalCircuitNodeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ElectricalCircuitNodeData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ElectricalCircuitNodeData& from);
  void MergeFrom(const ElectricalCircuitNodeData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElectricalCircuitNodeData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.ElectricalCircuitNodeData";
  }
  protected:
  explicit ElectricalCircuitNodeData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircuitNodeFieldNumber = 1,
    kVoltageFieldNumber = 2,
    kNextVoltageFieldNumber = 3,
    kChargeFieldNumber = 4,
    kNextChargeFieldNumber = 5,
    kChargeBaselineFieldNumber = 6,
  };
  // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
  bool has_circuitnode() const;
  private:
  bool _internal_has_circuitnode() const;
  public:
  void clear_circuitnode();
  const ::pulse::cdm::bind::CircuitNodeData& circuitnode() const;
  ::pulse::cdm::bind::CircuitNodeData* release_circuitnode();
  ::pulse::cdm::bind::CircuitNodeData* mutable_circuitnode();
  void set_allocated_circuitnode(::pulse::cdm::bind::CircuitNodeData* circuitnode);
  private:
  const ::pulse::cdm::bind::CircuitNodeData& _internal_circuitnode() const;
  ::pulse::cdm::bind::CircuitNodeData* _internal_mutable_circuitnode();
  public:
  void unsafe_arena_set_allocated_circuitnode(
      ::pulse::cdm::bind::CircuitNodeData* circuitnode);
  ::pulse::cdm::bind::CircuitNodeData* unsafe_arena_release_circuitnode();

  // .pulse.cdm.bind.ScalarElectricPotentialData Voltage = 2;
  bool has_voltage() const;
  private:
  bool _internal_has_voltage() const;
  public:
  void clear_voltage();
  const ::pulse::cdm::bind::ScalarElectricPotentialData& voltage() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* release_voltage();
  ::pulse::cdm::bind::ScalarElectricPotentialData* mutable_voltage();
  void set_allocated_voltage(::pulse::cdm::bind::ScalarElectricPotentialData* voltage);
  private:
  const ::pulse::cdm::bind::ScalarElectricPotentialData& _internal_voltage() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* _internal_mutable_voltage();
  public:
  void unsafe_arena_set_allocated_voltage(
      ::pulse::cdm::bind::ScalarElectricPotentialData* voltage);
  ::pulse::cdm::bind::ScalarElectricPotentialData* unsafe_arena_release_voltage();

  // .pulse.cdm.bind.ScalarElectricPotentialData NextVoltage = 3;
  bool has_nextvoltage() const;
  private:
  bool _internal_has_nextvoltage() const;
  public:
  void clear_nextvoltage();
  const ::pulse::cdm::bind::ScalarElectricPotentialData& nextvoltage() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* release_nextvoltage();
  ::pulse::cdm::bind::ScalarElectricPotentialData* mutable_nextvoltage();
  void set_allocated_nextvoltage(::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltage);
  private:
  const ::pulse::cdm::bind::ScalarElectricPotentialData& _internal_nextvoltage() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* _internal_mutable_nextvoltage();
  public:
  void unsafe_arena_set_allocated_nextvoltage(
      ::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltage);
  ::pulse::cdm::bind::ScalarElectricPotentialData* unsafe_arena_release_nextvoltage();

  // .pulse.cdm.bind.ScalarElectricChargeData Charge = 4;
  bool has_charge() const;
  private:
  bool _internal_has_charge() const;
  public:
  void clear_charge();
  const ::pulse::cdm::bind::ScalarElectricChargeData& charge() const;
  ::pulse::cdm::bind::ScalarElectricChargeData* release_charge();
  ::pulse::cdm::bind::ScalarElectricChargeData* mutable_charge();
  void set_allocated_charge(::pulse::cdm::bind::ScalarElectricChargeData* charge);
  private:
  const ::pulse::cdm::bind::ScalarElectricChargeData& _internal_charge() const;
  ::pulse::cdm::bind::ScalarElectricChargeData* _internal_mutable_charge();
  public:
  void unsafe_arena_set_allocated_charge(
      ::pulse::cdm::bind::ScalarElectricChargeData* charge);
  ::pulse::cdm::bind::ScalarElectricChargeData* unsafe_arena_release_charge();

  // .pulse.cdm.bind.ScalarElectricChargeData NextCharge = 5;
  bool has_nextcharge() const;
  private:
  bool _internal_has_nextcharge() const;
  public:
  void clear_nextcharge();
  const ::pulse::cdm::bind::ScalarElectricChargeData& nextcharge() const;
  ::pulse::cdm::bind::ScalarElectricChargeData* release_nextcharge();
  ::pulse::cdm::bind::ScalarElectricChargeData* mutable_nextcharge();
  void set_allocated_nextcharge(::pulse::cdm::bind::ScalarElectricChargeData* nextcharge);
  private:
  const ::pulse::cdm::bind::ScalarElectricChargeData& _internal_nextcharge() const;
  ::pulse::cdm::bind::ScalarElectricChargeData* _internal_mutable_nextcharge();
  public:
  void unsafe_arena_set_allocated_nextcharge(
      ::pulse::cdm::bind::ScalarElectricChargeData* nextcharge);
  ::pulse::cdm::bind::ScalarElectricChargeData* unsafe_arena_release_nextcharge();

  // .pulse.cdm.bind.ScalarElectricChargeData ChargeBaseline = 6;
  bool has_chargebaseline() const;
  private:
  bool _internal_has_chargebaseline() const;
  public:
  void clear_chargebaseline();
  const ::pulse::cdm::bind::ScalarElectricChargeData& chargebaseline() const;
  ::pulse::cdm::bind::ScalarElectricChargeData* release_chargebaseline();
  ::pulse::cdm::bind::ScalarElectricChargeData* mutable_chargebaseline();
  void set_allocated_chargebaseline(::pulse::cdm::bind::ScalarElectricChargeData* chargebaseline);
  private:
  const ::pulse::cdm::bind::ScalarElectricChargeData& _internal_chargebaseline() const;
  ::pulse::cdm::bind::ScalarElectricChargeData* _internal_mutable_chargebaseline();
  public:
  void unsafe_arena_set_allocated_chargebaseline(
      ::pulse::cdm::bind::ScalarElectricChargeData* chargebaseline);
  ::pulse::cdm::bind::ScalarElectricChargeData* unsafe_arena_release_chargebaseline();

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.ElectricalCircuitNodeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pulse::cdm::bind::CircuitNodeData* circuitnode_;
  ::pulse::cdm::bind::ScalarElectricPotentialData* voltage_;
  ::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltage_;
  ::pulse::cdm::bind::ScalarElectricChargeData* charge_;
  ::pulse::cdm::bind::ScalarElectricChargeData* nextcharge_;
  ::pulse::cdm::bind::ScalarElectricChargeData* chargebaseline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class ElectricalCircuitPathData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.ElectricalCircuitPathData) */ {
 public:
  inline ElectricalCircuitPathData() : ElectricalCircuitPathData(nullptr) {}
  virtual ~ElectricalCircuitPathData();

  ElectricalCircuitPathData(const ElectricalCircuitPathData& from);
  ElectricalCircuitPathData(ElectricalCircuitPathData&& from) noexcept
    : ElectricalCircuitPathData() {
    *this = ::std::move(from);
  }

  inline ElectricalCircuitPathData& operator=(const ElectricalCircuitPathData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElectricalCircuitPathData& operator=(ElectricalCircuitPathData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ElectricalCircuitPathData& default_instance();

  static inline const ElectricalCircuitPathData* internal_default_instance() {
    return reinterpret_cast<const ElectricalCircuitPathData*>(
               &_ElectricalCircuitPathData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ElectricalCircuitPathData& a, ElectricalCircuitPathData& b) {
    a.Swap(&b);
  }
  inline void Swap(ElectricalCircuitPathData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElectricalCircuitPathData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ElectricalCircuitPathData* New() const final {
    return CreateMaybeMessage<ElectricalCircuitPathData>(nullptr);
  }

  ElectricalCircuitPathData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ElectricalCircuitPathData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ElectricalCircuitPathData& from);
  void MergeFrom(const ElectricalCircuitPathData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElectricalCircuitPathData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.ElectricalCircuitPathData";
  }
  protected:
  explicit ElectricalCircuitPathData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircuitPathFieldNumber = 1,
    kResistanceFieldNumber = 2,
    kNextResistanceFieldNumber = 3,
    kResistanceBaselineFieldNumber = 4,
    kCapacitanceFieldNumber = 5,
    kNextCapacitanceFieldNumber = 6,
    kCapacitanceBaselineFieldNumber = 7,
    kInductanceFieldNumber = 8,
    kNextInductanceFieldNumber = 9,
    kInductanceBaselineFieldNumber = 10,
    kCurrentFieldNumber = 11,
    kNextCurrentFieldNumber = 12,
    kCurrentSourceFieldNumber = 13,
    kNextCurrentSourceFieldNumber = 14,
    kCurrentSourceBaselineFieldNumber = 15,
    kVoltageSourceFieldNumber = 16,
    kNextVoltageSourceFieldNumber = 17,
    kVoltageSourceBaselineFieldNumber = 18,
    kValveBreakdownVoltageFieldNumber = 19,
  };
  // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
  bool has_circuitpath() const;
  private:
  bool _internal_has_circuitpath() const;
  public:
  void clear_circuitpath();
  const ::pulse::cdm::bind::CircuitPathData& circuitpath() const;
  ::pulse::cdm::bind::CircuitPathData* release_circuitpath();
  ::pulse::cdm::bind::CircuitPathData* mutable_circuitpath();
  void set_allocated_circuitpath(::pulse::cdm::bind::CircuitPathData* circuitpath);
  private:
  const ::pulse::cdm::bind::CircuitPathData& _internal_circuitpath() const;
  ::pulse::cdm::bind::CircuitPathData* _internal_mutable_circuitpath();
  public:
  void unsafe_arena_set_allocated_circuitpath(
      ::pulse::cdm::bind::CircuitPathData* circuitpath);
  ::pulse::cdm::bind::CircuitPathData* unsafe_arena_release_circuitpath();

  // .pulse.cdm.bind.ScalarElectricResistanceData Resistance = 2;
  bool has_resistance() const;
  private:
  bool _internal_has_resistance() const;
  public:
  void clear_resistance();
  const ::pulse::cdm::bind::ScalarElectricResistanceData& resistance() const;
  ::pulse::cdm::bind::ScalarElectricResistanceData* release_resistance();
  ::pulse::cdm::bind::ScalarElectricResistanceData* mutable_resistance();
  void set_allocated_resistance(::pulse::cdm::bind::ScalarElectricResistanceData* resistance);
  private:
  const ::pulse::cdm::bind::ScalarElectricResistanceData& _internal_resistance() const;
  ::pulse::cdm::bind::ScalarElectricResistanceData* _internal_mutable_resistance();
  public:
  void unsafe_arena_set_allocated_resistance(
      ::pulse::cdm::bind::ScalarElectricResistanceData* resistance);
  ::pulse::cdm::bind::ScalarElectricResistanceData* unsafe_arena_release_resistance();

  // .pulse.cdm.bind.ScalarElectricResistanceData NextResistance = 3;
  bool has_nextresistance() const;
  private:
  bool _internal_has_nextresistance() const;
  public:
  void clear_nextresistance();
  const ::pulse::cdm::bind::ScalarElectricResistanceData& nextresistance() const;
  ::pulse::cdm::bind::ScalarElectricResistanceData* release_nextresistance();
  ::pulse::cdm::bind::ScalarElectricResistanceData* mutable_nextresistance();
  void set_allocated_nextresistance(::pulse::cdm::bind::ScalarElectricResistanceData* nextresistance);
  private:
  const ::pulse::cdm::bind::ScalarElectricResistanceData& _internal_nextresistance() const;
  ::pulse::cdm::bind::ScalarElectricResistanceData* _internal_mutable_nextresistance();
  public:
  void unsafe_arena_set_allocated_nextresistance(
      ::pulse::cdm::bind::ScalarElectricResistanceData* nextresistance);
  ::pulse::cdm::bind::ScalarElectricResistanceData* unsafe_arena_release_nextresistance();

  // .pulse.cdm.bind.ScalarElectricResistanceData ResistanceBaseline = 4;
  bool has_resistancebaseline() const;
  private:
  bool _internal_has_resistancebaseline() const;
  public:
  void clear_resistancebaseline();
  const ::pulse::cdm::bind::ScalarElectricResistanceData& resistancebaseline() const;
  ::pulse::cdm::bind::ScalarElectricResistanceData* release_resistancebaseline();
  ::pulse::cdm::bind::ScalarElectricResistanceData* mutable_resistancebaseline();
  void set_allocated_resistancebaseline(::pulse::cdm::bind::ScalarElectricResistanceData* resistancebaseline);
  private:
  const ::pulse::cdm::bind::ScalarElectricResistanceData& _internal_resistancebaseline() const;
  ::pulse::cdm::bind::ScalarElectricResistanceData* _internal_mutable_resistancebaseline();
  public:
  void unsafe_arena_set_allocated_resistancebaseline(
      ::pulse::cdm::bind::ScalarElectricResistanceData* resistancebaseline);
  ::pulse::cdm::bind::ScalarElectricResistanceData* unsafe_arena_release_resistancebaseline();

  // .pulse.cdm.bind.ScalarElectricCapacitanceData Capacitance = 5;
  bool has_capacitance() const;
  private:
  bool _internal_has_capacitance() const;
  public:
  void clear_capacitance();
  const ::pulse::cdm::bind::ScalarElectricCapacitanceData& capacitance() const;
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* release_capacitance();
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* mutable_capacitance();
  void set_allocated_capacitance(::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitance);
  private:
  const ::pulse::cdm::bind::ScalarElectricCapacitanceData& _internal_capacitance() const;
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* _internal_mutable_capacitance();
  public:
  void unsafe_arena_set_allocated_capacitance(
      ::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitance);
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* unsafe_arena_release_capacitance();

  // .pulse.cdm.bind.ScalarElectricCapacitanceData NextCapacitance = 6;
  bool has_nextcapacitance() const;
  private:
  bool _internal_has_nextcapacitance() const;
  public:
  void clear_nextcapacitance();
  const ::pulse::cdm::bind::ScalarElectricCapacitanceData& nextcapacitance() const;
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* release_nextcapacitance();
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* mutable_nextcapacitance();
  void set_allocated_nextcapacitance(::pulse::cdm::bind::ScalarElectricCapacitanceData* nextcapacitance);
  private:
  const ::pulse::cdm::bind::ScalarElectricCapacitanceData& _internal_nextcapacitance() const;
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* _internal_mutable_nextcapacitance();
  public:
  void unsafe_arena_set_allocated_nextcapacitance(
      ::pulse::cdm::bind::ScalarElectricCapacitanceData* nextcapacitance);
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* unsafe_arena_release_nextcapacitance();

  // .pulse.cdm.bind.ScalarElectricCapacitanceData CapacitanceBaseline = 7;
  bool has_capacitancebaseline() const;
  private:
  bool _internal_has_capacitancebaseline() const;
  public:
  void clear_capacitancebaseline();
  const ::pulse::cdm::bind::ScalarElectricCapacitanceData& capacitancebaseline() const;
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* release_capacitancebaseline();
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* mutable_capacitancebaseline();
  void set_allocated_capacitancebaseline(::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitancebaseline);
  private:
  const ::pulse::cdm::bind::ScalarElectricCapacitanceData& _internal_capacitancebaseline() const;
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* _internal_mutable_capacitancebaseline();
  public:
  void unsafe_arena_set_allocated_capacitancebaseline(
      ::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitancebaseline);
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* unsafe_arena_release_capacitancebaseline();

  // .pulse.cdm.bind.ScalarElectricInductanceData Inductance = 8;
  bool has_inductance() const;
  private:
  bool _internal_has_inductance() const;
  public:
  void clear_inductance();
  const ::pulse::cdm::bind::ScalarElectricInductanceData& inductance() const;
  ::pulse::cdm::bind::ScalarElectricInductanceData* release_inductance();
  ::pulse::cdm::bind::ScalarElectricInductanceData* mutable_inductance();
  void set_allocated_inductance(::pulse::cdm::bind::ScalarElectricInductanceData* inductance);
  private:
  const ::pulse::cdm::bind::ScalarElectricInductanceData& _internal_inductance() const;
  ::pulse::cdm::bind::ScalarElectricInductanceData* _internal_mutable_inductance();
  public:
  void unsafe_arena_set_allocated_inductance(
      ::pulse::cdm::bind::ScalarElectricInductanceData* inductance);
  ::pulse::cdm::bind::ScalarElectricInductanceData* unsafe_arena_release_inductance();

  // .pulse.cdm.bind.ScalarElectricInductanceData NextInductance = 9;
  bool has_nextinductance() const;
  private:
  bool _internal_has_nextinductance() const;
  public:
  void clear_nextinductance();
  const ::pulse::cdm::bind::ScalarElectricInductanceData& nextinductance() const;
  ::pulse::cdm::bind::ScalarElectricInductanceData* release_nextinductance();
  ::pulse::cdm::bind::ScalarElectricInductanceData* mutable_nextinductance();
  void set_allocated_nextinductance(::pulse::cdm::bind::ScalarElectricInductanceData* nextinductance);
  private:
  const ::pulse::cdm::bind::ScalarElectricInductanceData& _internal_nextinductance() const;
  ::pulse::cdm::bind::ScalarElectricInductanceData* _internal_mutable_nextinductance();
  public:
  void unsafe_arena_set_allocated_nextinductance(
      ::pulse::cdm::bind::ScalarElectricInductanceData* nextinductance);
  ::pulse::cdm::bind::ScalarElectricInductanceData* unsafe_arena_release_nextinductance();

  // .pulse.cdm.bind.ScalarElectricInductanceData InductanceBaseline = 10;
  bool has_inductancebaseline() const;
  private:
  bool _internal_has_inductancebaseline() const;
  public:
  void clear_inductancebaseline();
  const ::pulse::cdm::bind::ScalarElectricInductanceData& inductancebaseline() const;
  ::pulse::cdm::bind::ScalarElectricInductanceData* release_inductancebaseline();
  ::pulse::cdm::bind::ScalarElectricInductanceData* mutable_inductancebaseline();
  void set_allocated_inductancebaseline(::pulse::cdm::bind::ScalarElectricInductanceData* inductancebaseline);
  private:
  const ::pulse::cdm::bind::ScalarElectricInductanceData& _internal_inductancebaseline() const;
  ::pulse::cdm::bind::ScalarElectricInductanceData* _internal_mutable_inductancebaseline();
  public:
  void unsafe_arena_set_allocated_inductancebaseline(
      ::pulse::cdm::bind::ScalarElectricInductanceData* inductancebaseline);
  ::pulse::cdm::bind::ScalarElectricInductanceData* unsafe_arena_release_inductancebaseline();

  // .pulse.cdm.bind.ScalarElectricCurrentData Current = 11;
  bool has_current() const;
  private:
  bool _internal_has_current() const;
  public:
  void clear_current();
  const ::pulse::cdm::bind::ScalarElectricCurrentData& current() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* release_current();
  ::pulse::cdm::bind::ScalarElectricCurrentData* mutable_current();
  void set_allocated_current(::pulse::cdm::bind::ScalarElectricCurrentData* current);
  private:
  const ::pulse::cdm::bind::ScalarElectricCurrentData& _internal_current() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* _internal_mutable_current();
  public:
  void unsafe_arena_set_allocated_current(
      ::pulse::cdm::bind::ScalarElectricCurrentData* current);
  ::pulse::cdm::bind::ScalarElectricCurrentData* unsafe_arena_release_current();

  // .pulse.cdm.bind.ScalarElectricCurrentData NextCurrent = 12;
  bool has_nextcurrent() const;
  private:
  bool _internal_has_nextcurrent() const;
  public:
  void clear_nextcurrent();
  const ::pulse::cdm::bind::ScalarElectricCurrentData& nextcurrent() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* release_nextcurrent();
  ::pulse::cdm::bind::ScalarElectricCurrentData* mutable_nextcurrent();
  void set_allocated_nextcurrent(::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrent);
  private:
  const ::pulse::cdm::bind::ScalarElectricCurrentData& _internal_nextcurrent() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* _internal_mutable_nextcurrent();
  public:
  void unsafe_arena_set_allocated_nextcurrent(
      ::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrent);
  ::pulse::cdm::bind::ScalarElectricCurrentData* unsafe_arena_release_nextcurrent();

  // .pulse.cdm.bind.ScalarElectricCurrentData CurrentSource = 13;
  bool has_currentsource() const;
  private:
  bool _internal_has_currentsource() const;
  public:
  void clear_currentsource();
  const ::pulse::cdm::bind::ScalarElectricCurrentData& currentsource() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* release_currentsource();
  ::pulse::cdm::bind::ScalarElectricCurrentData* mutable_currentsource();
  void set_allocated_currentsource(::pulse::cdm::bind::ScalarElectricCurrentData* currentsource);
  private:
  const ::pulse::cdm::bind::ScalarElectricCurrentData& _internal_currentsource() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* _internal_mutable_currentsource();
  public:
  void unsafe_arena_set_allocated_currentsource(
      ::pulse::cdm::bind::ScalarElectricCurrentData* currentsource);
  ::pulse::cdm::bind::ScalarElectricCurrentData* unsafe_arena_release_currentsource();

  // .pulse.cdm.bind.ScalarElectricCurrentData NextCurrentSource = 14;
  bool has_nextcurrentsource() const;
  private:
  bool _internal_has_nextcurrentsource() const;
  public:
  void clear_nextcurrentsource();
  const ::pulse::cdm::bind::ScalarElectricCurrentData& nextcurrentsource() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* release_nextcurrentsource();
  ::pulse::cdm::bind::ScalarElectricCurrentData* mutable_nextcurrentsource();
  void set_allocated_nextcurrentsource(::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrentsource);
  private:
  const ::pulse::cdm::bind::ScalarElectricCurrentData& _internal_nextcurrentsource() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* _internal_mutable_nextcurrentsource();
  public:
  void unsafe_arena_set_allocated_nextcurrentsource(
      ::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrentsource);
  ::pulse::cdm::bind::ScalarElectricCurrentData* unsafe_arena_release_nextcurrentsource();

  // .pulse.cdm.bind.ScalarElectricCurrentData CurrentSourceBaseline = 15;
  bool has_currentsourcebaseline() const;
  private:
  bool _internal_has_currentsourcebaseline() const;
  public:
  void clear_currentsourcebaseline();
  const ::pulse::cdm::bind::ScalarElectricCurrentData& currentsourcebaseline() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* release_currentsourcebaseline();
  ::pulse::cdm::bind::ScalarElectricCurrentData* mutable_currentsourcebaseline();
  void set_allocated_currentsourcebaseline(::pulse::cdm::bind::ScalarElectricCurrentData* currentsourcebaseline);
  private:
  const ::pulse::cdm::bind::ScalarElectricCurrentData& _internal_currentsourcebaseline() const;
  ::pulse::cdm::bind::ScalarElectricCurrentData* _internal_mutable_currentsourcebaseline();
  public:
  void unsafe_arena_set_allocated_currentsourcebaseline(
      ::pulse::cdm::bind::ScalarElectricCurrentData* currentsourcebaseline);
  ::pulse::cdm::bind::ScalarElectricCurrentData* unsafe_arena_release_currentsourcebaseline();

  // .pulse.cdm.bind.ScalarElectricPotentialData VoltageSource = 16;
  bool has_voltagesource() const;
  private:
  bool _internal_has_voltagesource() const;
  public:
  void clear_voltagesource();
  const ::pulse::cdm::bind::ScalarElectricPotentialData& voltagesource() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* release_voltagesource();
  ::pulse::cdm::bind::ScalarElectricPotentialData* mutable_voltagesource();
  void set_allocated_voltagesource(::pulse::cdm::bind::ScalarElectricPotentialData* voltagesource);
  private:
  const ::pulse::cdm::bind::ScalarElectricPotentialData& _internal_voltagesource() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* _internal_mutable_voltagesource();
  public:
  void unsafe_arena_set_allocated_voltagesource(
      ::pulse::cdm::bind::ScalarElectricPotentialData* voltagesource);
  ::pulse::cdm::bind::ScalarElectricPotentialData* unsafe_arena_release_voltagesource();

  // .pulse.cdm.bind.ScalarElectricPotentialData NextVoltageSource = 17;
  bool has_nextvoltagesource() const;
  private:
  bool _internal_has_nextvoltagesource() const;
  public:
  void clear_nextvoltagesource();
  const ::pulse::cdm::bind::ScalarElectricPotentialData& nextvoltagesource() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* release_nextvoltagesource();
  ::pulse::cdm::bind::ScalarElectricPotentialData* mutable_nextvoltagesource();
  void set_allocated_nextvoltagesource(::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltagesource);
  private:
  const ::pulse::cdm::bind::ScalarElectricPotentialData& _internal_nextvoltagesource() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* _internal_mutable_nextvoltagesource();
  public:
  void unsafe_arena_set_allocated_nextvoltagesource(
      ::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltagesource);
  ::pulse::cdm::bind::ScalarElectricPotentialData* unsafe_arena_release_nextvoltagesource();

  // .pulse.cdm.bind.ScalarElectricPotentialData VoltageSourceBaseline = 18;
  bool has_voltagesourcebaseline() const;
  private:
  bool _internal_has_voltagesourcebaseline() const;
  public:
  void clear_voltagesourcebaseline();
  const ::pulse::cdm::bind::ScalarElectricPotentialData& voltagesourcebaseline() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* release_voltagesourcebaseline();
  ::pulse::cdm::bind::ScalarElectricPotentialData* mutable_voltagesourcebaseline();
  void set_allocated_voltagesourcebaseline(::pulse::cdm::bind::ScalarElectricPotentialData* voltagesourcebaseline);
  private:
  const ::pulse::cdm::bind::ScalarElectricPotentialData& _internal_voltagesourcebaseline() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* _internal_mutable_voltagesourcebaseline();
  public:
  void unsafe_arena_set_allocated_voltagesourcebaseline(
      ::pulse::cdm::bind::ScalarElectricPotentialData* voltagesourcebaseline);
  ::pulse::cdm::bind::ScalarElectricPotentialData* unsafe_arena_release_voltagesourcebaseline();

  // .pulse.cdm.bind.ScalarElectricPotentialData ValveBreakdownVoltage = 19;
  bool has_valvebreakdownvoltage() const;
  private:
  bool _internal_has_valvebreakdownvoltage() const;
  public:
  void clear_valvebreakdownvoltage();
  const ::pulse::cdm::bind::ScalarElectricPotentialData& valvebreakdownvoltage() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* release_valvebreakdownvoltage();
  ::pulse::cdm::bind::ScalarElectricPotentialData* mutable_valvebreakdownvoltage();
  void set_allocated_valvebreakdownvoltage(::pulse::cdm::bind::ScalarElectricPotentialData* valvebreakdownvoltage);
  private:
  const ::pulse::cdm::bind::ScalarElectricPotentialData& _internal_valvebreakdownvoltage() const;
  ::pulse::cdm::bind::ScalarElectricPotentialData* _internal_mutable_valvebreakdownvoltage();
  public:
  void unsafe_arena_set_allocated_valvebreakdownvoltage(
      ::pulse::cdm::bind::ScalarElectricPotentialData* valvebreakdownvoltage);
  ::pulse::cdm::bind::ScalarElectricPotentialData* unsafe_arena_release_valvebreakdownvoltage();

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.ElectricalCircuitPathData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pulse::cdm::bind::CircuitPathData* circuitpath_;
  ::pulse::cdm::bind::ScalarElectricResistanceData* resistance_;
  ::pulse::cdm::bind::ScalarElectricResistanceData* nextresistance_;
  ::pulse::cdm::bind::ScalarElectricResistanceData* resistancebaseline_;
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitance_;
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* nextcapacitance_;
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitancebaseline_;
  ::pulse::cdm::bind::ScalarElectricInductanceData* inductance_;
  ::pulse::cdm::bind::ScalarElectricInductanceData* nextinductance_;
  ::pulse::cdm::bind::ScalarElectricInductanceData* inductancebaseline_;
  ::pulse::cdm::bind::ScalarElectricCurrentData* current_;
  ::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrent_;
  ::pulse::cdm::bind::ScalarElectricCurrentData* currentsource_;
  ::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrentsource_;
  ::pulse::cdm::bind::ScalarElectricCurrentData* currentsourcebaseline_;
  ::pulse::cdm::bind::ScalarElectricPotentialData* voltagesource_;
  ::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltagesource_;
  ::pulse::cdm::bind::ScalarElectricPotentialData* voltagesourcebaseline_;
  ::pulse::cdm::bind::ScalarElectricPotentialData* valvebreakdownvoltage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class FluidCircuitData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.FluidCircuitData) */ {
 public:
  inline FluidCircuitData() : FluidCircuitData(nullptr) {}
  virtual ~FluidCircuitData();

  FluidCircuitData(const FluidCircuitData& from);
  FluidCircuitData(FluidCircuitData&& from) noexcept
    : FluidCircuitData() {
    *this = ::std::move(from);
  }

  inline FluidCircuitData& operator=(const FluidCircuitData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FluidCircuitData& operator=(FluidCircuitData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FluidCircuitData& default_instance();

  static inline const FluidCircuitData* internal_default_instance() {
    return reinterpret_cast<const FluidCircuitData*>(
               &_FluidCircuitData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FluidCircuitData& a, FluidCircuitData& b) {
    a.Swap(&b);
  }
  inline void Swap(FluidCircuitData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FluidCircuitData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FluidCircuitData* New() const final {
    return CreateMaybeMessage<FluidCircuitData>(nullptr);
  }

  FluidCircuitData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FluidCircuitData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FluidCircuitData& from);
  void MergeFrom(const FluidCircuitData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FluidCircuitData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.FluidCircuitData";
  }
  protected:
  explicit FluidCircuitData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircuitFieldNumber = 1,
  };
  // .pulse.cdm.bind.CircuitData Circuit = 1;
  bool has_circuit() const;
  private:
  bool _internal_has_circuit() const;
  public:
  void clear_circuit();
  const ::pulse::cdm::bind::CircuitData& circuit() const;
  ::pulse::cdm::bind::CircuitData* release_circuit();
  ::pulse::cdm::bind::CircuitData* mutable_circuit();
  void set_allocated_circuit(::pulse::cdm::bind::CircuitData* circuit);
  private:
  const ::pulse::cdm::bind::CircuitData& _internal_circuit() const;
  ::pulse::cdm::bind::CircuitData* _internal_mutable_circuit();
  public:
  void unsafe_arena_set_allocated_circuit(
      ::pulse::cdm::bind::CircuitData* circuit);
  ::pulse::cdm::bind::CircuitData* unsafe_arena_release_circuit();

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.FluidCircuitData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pulse::cdm::bind::CircuitData* circuit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class FluidCircuitNodeData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.FluidCircuitNodeData) */ {
 public:
  inline FluidCircuitNodeData() : FluidCircuitNodeData(nullptr) {}
  virtual ~FluidCircuitNodeData();

  FluidCircuitNodeData(const FluidCircuitNodeData& from);
  FluidCircuitNodeData(FluidCircuitNodeData&& from) noexcept
    : FluidCircuitNodeData() {
    *this = ::std::move(from);
  }

  inline FluidCircuitNodeData& operator=(const FluidCircuitNodeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FluidCircuitNodeData& operator=(FluidCircuitNodeData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FluidCircuitNodeData& default_instance();

  static inline const FluidCircuitNodeData* internal_default_instance() {
    return reinterpret_cast<const FluidCircuitNodeData*>(
               &_FluidCircuitNodeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FluidCircuitNodeData& a, FluidCircuitNodeData& b) {
    a.Swap(&b);
  }
  inline void Swap(FluidCircuitNodeData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FluidCircuitNodeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FluidCircuitNodeData* New() const final {
    return CreateMaybeMessage<FluidCircuitNodeData>(nullptr);
  }

  FluidCircuitNodeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FluidCircuitNodeData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FluidCircuitNodeData& from);
  void MergeFrom(const FluidCircuitNodeData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FluidCircuitNodeData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.FluidCircuitNodeData";
  }
  protected:
  explicit FluidCircuitNodeData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircuitNodeFieldNumber = 1,
    kPressureFieldNumber = 2,
    kNextPressureFieldNumber = 3,
    kVolumeFieldNumber = 4,
    kNextVolumeFieldNumber = 5,
    kVolumeBaselineFieldNumber = 6,
  };
  // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
  bool has_circuitnode() const;
  private:
  bool _internal_has_circuitnode() const;
  public:
  void clear_circuitnode();
  const ::pulse::cdm::bind::CircuitNodeData& circuitnode() const;
  ::pulse::cdm::bind::CircuitNodeData* release_circuitnode();
  ::pulse::cdm::bind::CircuitNodeData* mutable_circuitnode();
  void set_allocated_circuitnode(::pulse::cdm::bind::CircuitNodeData* circuitnode);
  private:
  const ::pulse::cdm::bind::CircuitNodeData& _internal_circuitnode() const;
  ::pulse::cdm::bind::CircuitNodeData* _internal_mutable_circuitnode();
  public:
  void unsafe_arena_set_allocated_circuitnode(
      ::pulse::cdm::bind::CircuitNodeData* circuitnode);
  ::pulse::cdm::bind::CircuitNodeData* unsafe_arena_release_circuitnode();

  // .pulse.cdm.bind.ScalarPressureData Pressure = 2;
  bool has_pressure() const;
  private:
  bool _internal_has_pressure() const;
  public:
  void clear_pressure();
  const ::pulse::cdm::bind::ScalarPressureData& pressure() const;
  ::pulse::cdm::bind::ScalarPressureData* release_pressure();
  ::pulse::cdm::bind::ScalarPressureData* mutable_pressure();
  void set_allocated_pressure(::pulse::cdm::bind::ScalarPressureData* pressure);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_pressure() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_pressure();
  public:
  void unsafe_arena_set_allocated_pressure(
      ::pulse::cdm::bind::ScalarPressureData* pressure);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_pressure();

  // .pulse.cdm.bind.ScalarPressureData NextPressure = 3;
  bool has_nextpressure() const;
  private:
  bool _internal_has_nextpressure() const;
  public:
  void clear_nextpressure();
  const ::pulse::cdm::bind::ScalarPressureData& nextpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* release_nextpressure();
  ::pulse::cdm::bind::ScalarPressureData* mutable_nextpressure();
  void set_allocated_nextpressure(::pulse::cdm::bind::ScalarPressureData* nextpressure);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_nextpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_nextpressure();
  public:
  void unsafe_arena_set_allocated_nextpressure(
      ::pulse::cdm::bind::ScalarPressureData* nextpressure);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_nextpressure();

  // .pulse.cdm.bind.ScalarVolumeData Volume = 4;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  const ::pulse::cdm::bind::ScalarVolumeData& volume() const;
  ::pulse::cdm::bind::ScalarVolumeData* release_volume();
  ::pulse::cdm::bind::ScalarVolumeData* mutable_volume();
  void set_allocated_volume(::pulse::cdm::bind::ScalarVolumeData* volume);
  private:
  const ::pulse::cdm::bind::ScalarVolumeData& _internal_volume() const;
  ::pulse::cdm::bind::ScalarVolumeData* _internal_mutable_volume();
  public:
  void unsafe_arena_set_allocated_volume(
      ::pulse::cdm::bind::ScalarVolumeData* volume);
  ::pulse::cdm::bind::ScalarVolumeData* unsafe_arena_release_volume();

  // .pulse.cdm.bind.ScalarVolumeData NextVolume = 5;
  bool has_nextvolume() const;
  private:
  bool _internal_has_nextvolume() const;
  public:
  void clear_nextvolume();
  const ::pulse::cdm::bind::ScalarVolumeData& nextvolume() const;
  ::pulse::cdm::bind::ScalarVolumeData* release_nextvolume();
  ::pulse::cdm::bind::ScalarVolumeData* mutable_nextvolume();
  void set_allocated_nextvolume(::pulse::cdm::bind::ScalarVolumeData* nextvolume);
  private:
  const ::pulse::cdm::bind::ScalarVolumeData& _internal_nextvolume() const;
  ::pulse::cdm::bind::ScalarVolumeData* _internal_mutable_nextvolume();
  public:
  void unsafe_arena_set_allocated_nextvolume(
      ::pulse::cdm::bind::ScalarVolumeData* nextvolume);
  ::pulse::cdm::bind::ScalarVolumeData* unsafe_arena_release_nextvolume();

  // .pulse.cdm.bind.ScalarVolumeData VolumeBaseline = 6;
  bool has_volumebaseline() const;
  private:
  bool _internal_has_volumebaseline() const;
  public:
  void clear_volumebaseline();
  const ::pulse::cdm::bind::ScalarVolumeData& volumebaseline() const;
  ::pulse::cdm::bind::ScalarVolumeData* release_volumebaseline();
  ::pulse::cdm::bind::ScalarVolumeData* mutable_volumebaseline();
  void set_allocated_volumebaseline(::pulse::cdm::bind::ScalarVolumeData* volumebaseline);
  private:
  const ::pulse::cdm::bind::ScalarVolumeData& _internal_volumebaseline() const;
  ::pulse::cdm::bind::ScalarVolumeData* _internal_mutable_volumebaseline();
  public:
  void unsafe_arena_set_allocated_volumebaseline(
      ::pulse::cdm::bind::ScalarVolumeData* volumebaseline);
  ::pulse::cdm::bind::ScalarVolumeData* unsafe_arena_release_volumebaseline();

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.FluidCircuitNodeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pulse::cdm::bind::CircuitNodeData* circuitnode_;
  ::pulse::cdm::bind::ScalarPressureData* pressure_;
  ::pulse::cdm::bind::ScalarPressureData* nextpressure_;
  ::pulse::cdm::bind::ScalarVolumeData* volume_;
  ::pulse::cdm::bind::ScalarVolumeData* nextvolume_;
  ::pulse::cdm::bind::ScalarVolumeData* volumebaseline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class FluidCircuitPathData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.FluidCircuitPathData) */ {
 public:
  inline FluidCircuitPathData() : FluidCircuitPathData(nullptr) {}
  virtual ~FluidCircuitPathData();

  FluidCircuitPathData(const FluidCircuitPathData& from);
  FluidCircuitPathData(FluidCircuitPathData&& from) noexcept
    : FluidCircuitPathData() {
    *this = ::std::move(from);
  }

  inline FluidCircuitPathData& operator=(const FluidCircuitPathData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FluidCircuitPathData& operator=(FluidCircuitPathData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FluidCircuitPathData& default_instance();

  static inline const FluidCircuitPathData* internal_default_instance() {
    return reinterpret_cast<const FluidCircuitPathData*>(
               &_FluidCircuitPathData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FluidCircuitPathData& a, FluidCircuitPathData& b) {
    a.Swap(&b);
  }
  inline void Swap(FluidCircuitPathData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FluidCircuitPathData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FluidCircuitPathData* New() const final {
    return CreateMaybeMessage<FluidCircuitPathData>(nullptr);
  }

  FluidCircuitPathData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FluidCircuitPathData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FluidCircuitPathData& from);
  void MergeFrom(const FluidCircuitPathData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FluidCircuitPathData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.FluidCircuitPathData";
  }
  protected:
  explicit FluidCircuitPathData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircuitPathFieldNumber = 1,
    kResistanceFieldNumber = 2,
    kNextResistanceFieldNumber = 3,
    kResistanceBaselineFieldNumber = 4,
    kComplianceFieldNumber = 5,
    kNextComplianceFieldNumber = 6,
    kComplianceBaselineFieldNumber = 7,
    kInertanceFieldNumber = 8,
    kNextInertanceFieldNumber = 9,
    kInertanceBaselineFieldNumber = 10,
    kFlowFieldNumber = 11,
    kNextFlowFieldNumber = 12,
    kFlowSourceFieldNumber = 13,
    kNextFlowSourceFieldNumber = 14,
    kFlowSourceBaselineFieldNumber = 15,
    kPressureSourceFieldNumber = 16,
    kNextPressureSourceFieldNumber = 17,
    kPressureSourceBaselineFieldNumber = 18,
    kValveBreakdownPressureFieldNumber = 19,
  };
  // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
  bool has_circuitpath() const;
  private:
  bool _internal_has_circuitpath() const;
  public:
  void clear_circuitpath();
  const ::pulse::cdm::bind::CircuitPathData& circuitpath() const;
  ::pulse::cdm::bind::CircuitPathData* release_circuitpath();
  ::pulse::cdm::bind::CircuitPathData* mutable_circuitpath();
  void set_allocated_circuitpath(::pulse::cdm::bind::CircuitPathData* circuitpath);
  private:
  const ::pulse::cdm::bind::CircuitPathData& _internal_circuitpath() const;
  ::pulse::cdm::bind::CircuitPathData* _internal_mutable_circuitpath();
  public:
  void unsafe_arena_set_allocated_circuitpath(
      ::pulse::cdm::bind::CircuitPathData* circuitpath);
  ::pulse::cdm::bind::CircuitPathData* unsafe_arena_release_circuitpath();

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData Resistance = 2;
  bool has_resistance() const;
  private:
  bool _internal_has_resistance() const;
  public:
  void clear_resistance();
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& resistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* release_resistance();
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* mutable_resistance();
  void set_allocated_resistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistance);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& _internal_resistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* _internal_mutable_resistance();
  public:
  void unsafe_arena_set_allocated_resistance(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistance);
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* unsafe_arena_release_resistance();

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData NextResistance = 3;
  bool has_nextresistance() const;
  private:
  bool _internal_has_nextresistance() const;
  public:
  void clear_nextresistance();
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& nextresistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* release_nextresistance();
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* mutable_nextresistance();
  void set_allocated_nextresistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* nextresistance);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& _internal_nextresistance() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* _internal_mutable_nextresistance();
  public:
  void unsafe_arena_set_allocated_nextresistance(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* nextresistance);
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* unsafe_arena_release_nextresistance();

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData ResistanceBaseline = 4;
  bool has_resistancebaseline() const;
  private:
  bool _internal_has_resistancebaseline() const;
  public:
  void clear_resistancebaseline();
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& resistancebaseline() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* release_resistancebaseline();
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* mutable_resistancebaseline();
  void set_allocated_resistancebaseline(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistancebaseline);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& _internal_resistancebaseline() const;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* _internal_mutable_resistancebaseline();
  public:
  void unsafe_arena_set_allocated_resistancebaseline(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistancebaseline);
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* unsafe_arena_release_resistancebaseline();

  // .pulse.cdm.bind.ScalarVolumePerPressureData Compliance = 5;
  bool has_compliance() const;
  private:
  bool _internal_has_compliance() const;
  public:
  void clear_compliance();
  const ::pulse::cdm::bind::ScalarVolumePerPressureData& compliance() const;
  ::pulse::cdm::bind::ScalarVolumePerPressureData* release_compliance();
  ::pulse::cdm::bind::ScalarVolumePerPressureData* mutable_compliance();
  void set_allocated_compliance(::pulse::cdm::bind::ScalarVolumePerPressureData* compliance);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerPressureData& _internal_compliance() const;
  ::pulse::cdm::bind::ScalarVolumePerPressureData* _internal_mutable_compliance();
  public:
  void unsafe_arena_set_allocated_compliance(
      ::pulse::cdm::bind::ScalarVolumePerPressureData* compliance);
  ::pulse::cdm::bind::ScalarVolumePerPressureData* unsafe_arena_release_compliance();

  // .pulse.cdm.bind.ScalarVolumePerPressureData NextCompliance = 6;
  bool has_nextcompliance() const;
  private:
  bool _internal_has_nextcompliance() const;
  public:
  void clear_nextcompliance();
  const ::pulse::cdm::bind::ScalarVolumePerPressureData& nextcompliance() const;
  ::pulse::cdm::bind::ScalarVolumePerPressureData* release_nextcompliance();
  ::pulse::cdm::bind::ScalarVolumePerPressureData* mutable_nextcompliance();
  void set_allocated_nextcompliance(::pulse::cdm::bind::ScalarVolumePerPressureData* nextcompliance);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerPressureData& _internal_nextcompliance() const;
  ::pulse::cdm::bind::ScalarVolumePerPressureData* _internal_mutable_nextcompliance();
  public:
  void unsafe_arena_set_allocated_nextcompliance(
      ::pulse::cdm::bind::ScalarVolumePerPressureData* nextcompliance);
  ::pulse::cdm::bind::ScalarVolumePerPressureData* unsafe_arena_release_nextcompliance();

  // .pulse.cdm.bind.ScalarVolumePerPressureData ComplianceBaseline = 7;
  bool has_compliancebaseline() const;
  private:
  bool _internal_has_compliancebaseline() const;
  public:
  void clear_compliancebaseline();
  const ::pulse::cdm::bind::ScalarVolumePerPressureData& compliancebaseline() const;
  ::pulse::cdm::bind::ScalarVolumePerPressureData* release_compliancebaseline();
  ::pulse::cdm::bind::ScalarVolumePerPressureData* mutable_compliancebaseline();
  void set_allocated_compliancebaseline(::pulse::cdm::bind::ScalarVolumePerPressureData* compliancebaseline);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerPressureData& _internal_compliancebaseline() const;
  ::pulse::cdm::bind::ScalarVolumePerPressureData* _internal_mutable_compliancebaseline();
  public:
  void unsafe_arena_set_allocated_compliancebaseline(
      ::pulse::cdm::bind::ScalarVolumePerPressureData* compliancebaseline);
  ::pulse::cdm::bind::ScalarVolumePerPressureData* unsafe_arena_release_compliancebaseline();

  // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData Inertance = 8;
  bool has_inertance() const;
  private:
  bool _internal_has_inertance() const;
  public:
  void clear_inertance();
  const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& inertance() const;
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* release_inertance();
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* mutable_inertance();
  void set_allocated_inertance(::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertance);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& _internal_inertance() const;
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* _internal_mutable_inertance();
  public:
  void unsafe_arena_set_allocated_inertance(
      ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertance);
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* unsafe_arena_release_inertance();

  // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData NextInertance = 9;
  bool has_nextinertance() const;
  private:
  bool _internal_has_nextinertance() const;
  public:
  void clear_nextinertance();
  const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& nextinertance() const;
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* release_nextinertance();
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* mutable_nextinertance();
  void set_allocated_nextinertance(::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* nextinertance);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& _internal_nextinertance() const;
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* _internal_mutable_nextinertance();
  public:
  void unsafe_arena_set_allocated_nextinertance(
      ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* nextinertance);
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* unsafe_arena_release_nextinertance();

  // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData InertanceBaseline = 10;
  bool has_inertancebaseline() const;
  private:
  bool _internal_has_inertancebaseline() const;
  public:
  void clear_inertancebaseline();
  const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& inertancebaseline() const;
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* release_inertancebaseline();
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* mutable_inertancebaseline();
  void set_allocated_inertancebaseline(::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertancebaseline);
  private:
  const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& _internal_inertancebaseline() const;
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* _internal_mutable_inertancebaseline();
  public:
  void unsafe_arena_set_allocated_inertancebaseline(
      ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertancebaseline);
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* unsafe_arena_release_inertancebaseline();

  // .pulse.cdm.bind.ScalarVolumePerTimeData Flow = 11;
  bool has_flow() const;
  private:
  bool _internal_has_flow() const;
  public:
  void clear_flow();
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& flow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* release_flow();
  ::pulse::cdm::bind::ScalarVolumePerTimeData* mutable_flow();
  void set_allocated_flow(::pulse::cdm::bind::ScalarVolumePerTimeData* flow);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& _internal_flow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* _internal_mutable_flow();
  public:
  void unsafe_arena_set_allocated_flow(
      ::pulse::cdm::bind::ScalarVolumePerTimeData* flow);
  ::pulse::cdm::bind::ScalarVolumePerTimeData* unsafe_arena_release_flow();

  // .pulse.cdm.bind.ScalarVolumePerTimeData NextFlow = 12;
  bool has_nextflow() const;
  private:
  bool _internal_has_nextflow() const;
  public:
  void clear_nextflow();
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& nextflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* release_nextflow();
  ::pulse::cdm::bind::ScalarVolumePerTimeData* mutable_nextflow();
  void set_allocated_nextflow(::pulse::cdm::bind::ScalarVolumePerTimeData* nextflow);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& _internal_nextflow() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* _internal_mutable_nextflow();
  public:
  void unsafe_arena_set_allocated_nextflow(
      ::pulse::cdm::bind::ScalarVolumePerTimeData* nextflow);
  ::pulse::cdm::bind::ScalarVolumePerTimeData* unsafe_arena_release_nextflow();

  // .pulse.cdm.bind.ScalarVolumePerTimeData FlowSource = 13;
  bool has_flowsource() const;
  private:
  bool _internal_has_flowsource() const;
  public:
  void clear_flowsource();
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& flowsource() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* release_flowsource();
  ::pulse::cdm::bind::ScalarVolumePerTimeData* mutable_flowsource();
  void set_allocated_flowsource(::pulse::cdm::bind::ScalarVolumePerTimeData* flowsource);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& _internal_flowsource() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* _internal_mutable_flowsource();
  public:
  void unsafe_arena_set_allocated_flowsource(
      ::pulse::cdm::bind::ScalarVolumePerTimeData* flowsource);
  ::pulse::cdm::bind::ScalarVolumePerTimeData* unsafe_arena_release_flowsource();

  // .pulse.cdm.bind.ScalarVolumePerTimeData NextFlowSource = 14;
  bool has_nextflowsource() const;
  private:
  bool _internal_has_nextflowsource() const;
  public:
  void clear_nextflowsource();
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& nextflowsource() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* release_nextflowsource();
  ::pulse::cdm::bind::ScalarVolumePerTimeData* mutable_nextflowsource();
  void set_allocated_nextflowsource(::pulse::cdm::bind::ScalarVolumePerTimeData* nextflowsource);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& _internal_nextflowsource() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* _internal_mutable_nextflowsource();
  public:
  void unsafe_arena_set_allocated_nextflowsource(
      ::pulse::cdm::bind::ScalarVolumePerTimeData* nextflowsource);
  ::pulse::cdm::bind::ScalarVolumePerTimeData* unsafe_arena_release_nextflowsource();

  // .pulse.cdm.bind.ScalarVolumePerTimeData FlowSourceBaseline = 15;
  bool has_flowsourcebaseline() const;
  private:
  bool _internal_has_flowsourcebaseline() const;
  public:
  void clear_flowsourcebaseline();
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& flowsourcebaseline() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* release_flowsourcebaseline();
  ::pulse::cdm::bind::ScalarVolumePerTimeData* mutable_flowsourcebaseline();
  void set_allocated_flowsourcebaseline(::pulse::cdm::bind::ScalarVolumePerTimeData* flowsourcebaseline);
  private:
  const ::pulse::cdm::bind::ScalarVolumePerTimeData& _internal_flowsourcebaseline() const;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* _internal_mutable_flowsourcebaseline();
  public:
  void unsafe_arena_set_allocated_flowsourcebaseline(
      ::pulse::cdm::bind::ScalarVolumePerTimeData* flowsourcebaseline);
  ::pulse::cdm::bind::ScalarVolumePerTimeData* unsafe_arena_release_flowsourcebaseline();

  // .pulse.cdm.bind.ScalarPressureData PressureSource = 16;
  bool has_pressuresource() const;
  private:
  bool _internal_has_pressuresource() const;
  public:
  void clear_pressuresource();
  const ::pulse::cdm::bind::ScalarPressureData& pressuresource() const;
  ::pulse::cdm::bind::ScalarPressureData* release_pressuresource();
  ::pulse::cdm::bind::ScalarPressureData* mutable_pressuresource();
  void set_allocated_pressuresource(::pulse::cdm::bind::ScalarPressureData* pressuresource);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_pressuresource() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_pressuresource();
  public:
  void unsafe_arena_set_allocated_pressuresource(
      ::pulse::cdm::bind::ScalarPressureData* pressuresource);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_pressuresource();

  // .pulse.cdm.bind.ScalarPressureData NextPressureSource = 17;
  bool has_nextpressuresource() const;
  private:
  bool _internal_has_nextpressuresource() const;
  public:
  void clear_nextpressuresource();
  const ::pulse::cdm::bind::ScalarPressureData& nextpressuresource() const;
  ::pulse::cdm::bind::ScalarPressureData* release_nextpressuresource();
  ::pulse::cdm::bind::ScalarPressureData* mutable_nextpressuresource();
  void set_allocated_nextpressuresource(::pulse::cdm::bind::ScalarPressureData* nextpressuresource);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_nextpressuresource() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_nextpressuresource();
  public:
  void unsafe_arena_set_allocated_nextpressuresource(
      ::pulse::cdm::bind::ScalarPressureData* nextpressuresource);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_nextpressuresource();

  // .pulse.cdm.bind.ScalarPressureData PressureSourceBaseline = 18;
  bool has_pressuresourcebaseline() const;
  private:
  bool _internal_has_pressuresourcebaseline() const;
  public:
  void clear_pressuresourcebaseline();
  const ::pulse::cdm::bind::ScalarPressureData& pressuresourcebaseline() const;
  ::pulse::cdm::bind::ScalarPressureData* release_pressuresourcebaseline();
  ::pulse::cdm::bind::ScalarPressureData* mutable_pressuresourcebaseline();
  void set_allocated_pressuresourcebaseline(::pulse::cdm::bind::ScalarPressureData* pressuresourcebaseline);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_pressuresourcebaseline() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_pressuresourcebaseline();
  public:
  void unsafe_arena_set_allocated_pressuresourcebaseline(
      ::pulse::cdm::bind::ScalarPressureData* pressuresourcebaseline);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_pressuresourcebaseline();

  // .pulse.cdm.bind.ScalarPressureData ValveBreakdownPressure = 19;
  bool has_valvebreakdownpressure() const;
  private:
  bool _internal_has_valvebreakdownpressure() const;
  public:
  void clear_valvebreakdownpressure();
  const ::pulse::cdm::bind::ScalarPressureData& valvebreakdownpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* release_valvebreakdownpressure();
  ::pulse::cdm::bind::ScalarPressureData* mutable_valvebreakdownpressure();
  void set_allocated_valvebreakdownpressure(::pulse::cdm::bind::ScalarPressureData* valvebreakdownpressure);
  private:
  const ::pulse::cdm::bind::ScalarPressureData& _internal_valvebreakdownpressure() const;
  ::pulse::cdm::bind::ScalarPressureData* _internal_mutable_valvebreakdownpressure();
  public:
  void unsafe_arena_set_allocated_valvebreakdownpressure(
      ::pulse::cdm::bind::ScalarPressureData* valvebreakdownpressure);
  ::pulse::cdm::bind::ScalarPressureData* unsafe_arena_release_valvebreakdownpressure();

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.FluidCircuitPathData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pulse::cdm::bind::CircuitPathData* circuitpath_;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistance_;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* nextresistance_;
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistancebaseline_;
  ::pulse::cdm::bind::ScalarVolumePerPressureData* compliance_;
  ::pulse::cdm::bind::ScalarVolumePerPressureData* nextcompliance_;
  ::pulse::cdm::bind::ScalarVolumePerPressureData* compliancebaseline_;
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertance_;
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* nextinertance_;
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertancebaseline_;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* flow_;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* nextflow_;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* flowsource_;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* nextflowsource_;
  ::pulse::cdm::bind::ScalarVolumePerTimeData* flowsourcebaseline_;
  ::pulse::cdm::bind::ScalarPressureData* pressuresource_;
  ::pulse::cdm::bind::ScalarPressureData* nextpressuresource_;
  ::pulse::cdm::bind::ScalarPressureData* pressuresourcebaseline_;
  ::pulse::cdm::bind::ScalarPressureData* valvebreakdownpressure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class ThermalCircuitData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.ThermalCircuitData) */ {
 public:
  inline ThermalCircuitData() : ThermalCircuitData(nullptr) {}
  virtual ~ThermalCircuitData();

  ThermalCircuitData(const ThermalCircuitData& from);
  ThermalCircuitData(ThermalCircuitData&& from) noexcept
    : ThermalCircuitData() {
    *this = ::std::move(from);
  }

  inline ThermalCircuitData& operator=(const ThermalCircuitData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThermalCircuitData& operator=(ThermalCircuitData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThermalCircuitData& default_instance();

  static inline const ThermalCircuitData* internal_default_instance() {
    return reinterpret_cast<const ThermalCircuitData*>(
               &_ThermalCircuitData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ThermalCircuitData& a, ThermalCircuitData& b) {
    a.Swap(&b);
  }
  inline void Swap(ThermalCircuitData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThermalCircuitData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThermalCircuitData* New() const final {
    return CreateMaybeMessage<ThermalCircuitData>(nullptr);
  }

  ThermalCircuitData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThermalCircuitData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThermalCircuitData& from);
  void MergeFrom(const ThermalCircuitData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThermalCircuitData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.ThermalCircuitData";
  }
  protected:
  explicit ThermalCircuitData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircuitFieldNumber = 1,
  };
  // .pulse.cdm.bind.CircuitData Circuit = 1;
  bool has_circuit() const;
  private:
  bool _internal_has_circuit() const;
  public:
  void clear_circuit();
  const ::pulse::cdm::bind::CircuitData& circuit() const;
  ::pulse::cdm::bind::CircuitData* release_circuit();
  ::pulse::cdm::bind::CircuitData* mutable_circuit();
  void set_allocated_circuit(::pulse::cdm::bind::CircuitData* circuit);
  private:
  const ::pulse::cdm::bind::CircuitData& _internal_circuit() const;
  ::pulse::cdm::bind::CircuitData* _internal_mutable_circuit();
  public:
  void unsafe_arena_set_allocated_circuit(
      ::pulse::cdm::bind::CircuitData* circuit);
  ::pulse::cdm::bind::CircuitData* unsafe_arena_release_circuit();

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.ThermalCircuitData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pulse::cdm::bind::CircuitData* circuit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class ThermalCircuitNodeData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.ThermalCircuitNodeData) */ {
 public:
  inline ThermalCircuitNodeData() : ThermalCircuitNodeData(nullptr) {}
  virtual ~ThermalCircuitNodeData();

  ThermalCircuitNodeData(const ThermalCircuitNodeData& from);
  ThermalCircuitNodeData(ThermalCircuitNodeData&& from) noexcept
    : ThermalCircuitNodeData() {
    *this = ::std::move(from);
  }

  inline ThermalCircuitNodeData& operator=(const ThermalCircuitNodeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThermalCircuitNodeData& operator=(ThermalCircuitNodeData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThermalCircuitNodeData& default_instance();

  static inline const ThermalCircuitNodeData* internal_default_instance() {
    return reinterpret_cast<const ThermalCircuitNodeData*>(
               &_ThermalCircuitNodeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ThermalCircuitNodeData& a, ThermalCircuitNodeData& b) {
    a.Swap(&b);
  }
  inline void Swap(ThermalCircuitNodeData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThermalCircuitNodeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThermalCircuitNodeData* New() const final {
    return CreateMaybeMessage<ThermalCircuitNodeData>(nullptr);
  }

  ThermalCircuitNodeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThermalCircuitNodeData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThermalCircuitNodeData& from);
  void MergeFrom(const ThermalCircuitNodeData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThermalCircuitNodeData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.ThermalCircuitNodeData";
  }
  protected:
  explicit ThermalCircuitNodeData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircuitNodeFieldNumber = 1,
    kTemperatureFieldNumber = 2,
    kNextTemperatureFieldNumber = 3,
    kHeatFieldNumber = 4,
    kNextHeatFieldNumber = 5,
    kHeatBaselineFieldNumber = 6,
  };
  // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
  bool has_circuitnode() const;
  private:
  bool _internal_has_circuitnode() const;
  public:
  void clear_circuitnode();
  const ::pulse::cdm::bind::CircuitNodeData& circuitnode() const;
  ::pulse::cdm::bind::CircuitNodeData* release_circuitnode();
  ::pulse::cdm::bind::CircuitNodeData* mutable_circuitnode();
  void set_allocated_circuitnode(::pulse::cdm::bind::CircuitNodeData* circuitnode);
  private:
  const ::pulse::cdm::bind::CircuitNodeData& _internal_circuitnode() const;
  ::pulse::cdm::bind::CircuitNodeData* _internal_mutable_circuitnode();
  public:
  void unsafe_arena_set_allocated_circuitnode(
      ::pulse::cdm::bind::CircuitNodeData* circuitnode);
  ::pulse::cdm::bind::CircuitNodeData* unsafe_arena_release_circuitnode();

  // .pulse.cdm.bind.ScalarTemperatureData Temperature = 2;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  const ::pulse::cdm::bind::ScalarTemperatureData& temperature() const;
  ::pulse::cdm::bind::ScalarTemperatureData* release_temperature();
  ::pulse::cdm::bind::ScalarTemperatureData* mutable_temperature();
  void set_allocated_temperature(::pulse::cdm::bind::ScalarTemperatureData* temperature);
  private:
  const ::pulse::cdm::bind::ScalarTemperatureData& _internal_temperature() const;
  ::pulse::cdm::bind::ScalarTemperatureData* _internal_mutable_temperature();
  public:
  void unsafe_arena_set_allocated_temperature(
      ::pulse::cdm::bind::ScalarTemperatureData* temperature);
  ::pulse::cdm::bind::ScalarTemperatureData* unsafe_arena_release_temperature();

  // .pulse.cdm.bind.ScalarTemperatureData NextTemperature = 3;
  bool has_nexttemperature() const;
  private:
  bool _internal_has_nexttemperature() const;
  public:
  void clear_nexttemperature();
  const ::pulse::cdm::bind::ScalarTemperatureData& nexttemperature() const;
  ::pulse::cdm::bind::ScalarTemperatureData* release_nexttemperature();
  ::pulse::cdm::bind::ScalarTemperatureData* mutable_nexttemperature();
  void set_allocated_nexttemperature(::pulse::cdm::bind::ScalarTemperatureData* nexttemperature);
  private:
  const ::pulse::cdm::bind::ScalarTemperatureData& _internal_nexttemperature() const;
  ::pulse::cdm::bind::ScalarTemperatureData* _internal_mutable_nexttemperature();
  public:
  void unsafe_arena_set_allocated_nexttemperature(
      ::pulse::cdm::bind::ScalarTemperatureData* nexttemperature);
  ::pulse::cdm::bind::ScalarTemperatureData* unsafe_arena_release_nexttemperature();

  // .pulse.cdm.bind.ScalarEnergyData Heat = 4;
  bool has_heat() const;
  private:
  bool _internal_has_heat() const;
  public:
  void clear_heat();
  const ::pulse::cdm::bind::ScalarEnergyData& heat() const;
  ::pulse::cdm::bind::ScalarEnergyData* release_heat();
  ::pulse::cdm::bind::ScalarEnergyData* mutable_heat();
  void set_allocated_heat(::pulse::cdm::bind::ScalarEnergyData* heat);
  private:
  const ::pulse::cdm::bind::ScalarEnergyData& _internal_heat() const;
  ::pulse::cdm::bind::ScalarEnergyData* _internal_mutable_heat();
  public:
  void unsafe_arena_set_allocated_heat(
      ::pulse::cdm::bind::ScalarEnergyData* heat);
  ::pulse::cdm::bind::ScalarEnergyData* unsafe_arena_release_heat();

  // .pulse.cdm.bind.ScalarEnergyData NextHeat = 5;
  bool has_nextheat() const;
  private:
  bool _internal_has_nextheat() const;
  public:
  void clear_nextheat();
  const ::pulse::cdm::bind::ScalarEnergyData& nextheat() const;
  ::pulse::cdm::bind::ScalarEnergyData* release_nextheat();
  ::pulse::cdm::bind::ScalarEnergyData* mutable_nextheat();
  void set_allocated_nextheat(::pulse::cdm::bind::ScalarEnergyData* nextheat);
  private:
  const ::pulse::cdm::bind::ScalarEnergyData& _internal_nextheat() const;
  ::pulse::cdm::bind::ScalarEnergyData* _internal_mutable_nextheat();
  public:
  void unsafe_arena_set_allocated_nextheat(
      ::pulse::cdm::bind::ScalarEnergyData* nextheat);
  ::pulse::cdm::bind::ScalarEnergyData* unsafe_arena_release_nextheat();

  // .pulse.cdm.bind.ScalarEnergyData HeatBaseline = 6;
  bool has_heatbaseline() const;
  private:
  bool _internal_has_heatbaseline() const;
  public:
  void clear_heatbaseline();
  const ::pulse::cdm::bind::ScalarEnergyData& heatbaseline() const;
  ::pulse::cdm::bind::ScalarEnergyData* release_heatbaseline();
  ::pulse::cdm::bind::ScalarEnergyData* mutable_heatbaseline();
  void set_allocated_heatbaseline(::pulse::cdm::bind::ScalarEnergyData* heatbaseline);
  private:
  const ::pulse::cdm::bind::ScalarEnergyData& _internal_heatbaseline() const;
  ::pulse::cdm::bind::ScalarEnergyData* _internal_mutable_heatbaseline();
  public:
  void unsafe_arena_set_allocated_heatbaseline(
      ::pulse::cdm::bind::ScalarEnergyData* heatbaseline);
  ::pulse::cdm::bind::ScalarEnergyData* unsafe_arena_release_heatbaseline();

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.ThermalCircuitNodeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pulse::cdm::bind::CircuitNodeData* circuitnode_;
  ::pulse::cdm::bind::ScalarTemperatureData* temperature_;
  ::pulse::cdm::bind::ScalarTemperatureData* nexttemperature_;
  ::pulse::cdm::bind::ScalarEnergyData* heat_;
  ::pulse::cdm::bind::ScalarEnergyData* nextheat_;
  ::pulse::cdm::bind::ScalarEnergyData* heatbaseline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class ThermalCircuitPathData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.ThermalCircuitPathData) */ {
 public:
  inline ThermalCircuitPathData() : ThermalCircuitPathData(nullptr) {}
  virtual ~ThermalCircuitPathData();

  ThermalCircuitPathData(const ThermalCircuitPathData& from);
  ThermalCircuitPathData(ThermalCircuitPathData&& from) noexcept
    : ThermalCircuitPathData() {
    *this = ::std::move(from);
  }

  inline ThermalCircuitPathData& operator=(const ThermalCircuitPathData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThermalCircuitPathData& operator=(ThermalCircuitPathData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThermalCircuitPathData& default_instance();

  static inline const ThermalCircuitPathData* internal_default_instance() {
    return reinterpret_cast<const ThermalCircuitPathData*>(
               &_ThermalCircuitPathData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ThermalCircuitPathData& a, ThermalCircuitPathData& b) {
    a.Swap(&b);
  }
  inline void Swap(ThermalCircuitPathData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThermalCircuitPathData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThermalCircuitPathData* New() const final {
    return CreateMaybeMessage<ThermalCircuitPathData>(nullptr);
  }

  ThermalCircuitPathData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThermalCircuitPathData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThermalCircuitPathData& from);
  void MergeFrom(const ThermalCircuitPathData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThermalCircuitPathData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.ThermalCircuitPathData";
  }
  protected:
  explicit ThermalCircuitPathData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircuitPathFieldNumber = 1,
    kResistanceFieldNumber = 2,
    kNextResistanceFieldNumber = 3,
    kResistanceBaselineFieldNumber = 4,
    kCapacitanceFieldNumber = 5,
    kNextCapacitanceFieldNumber = 6,
    kCapacitanceBaselineFieldNumber = 7,
    kInductanceFieldNumber = 8,
    kNextInductanceFieldNumber = 9,
    kInductanceBaselineFieldNumber = 10,
    kHeatTransferRateFieldNumber = 11,
    kNextHeatTransferRateFieldNumber = 12,
    kHeatSourceFieldNumber = 13,
    kNextHeatSourceFieldNumber = 14,
    kHeatSourceBaselineFieldNumber = 15,
    kTemperatureSourceFieldNumber = 16,
    kNextTemperatureSourceFieldNumber = 17,
    kTemperatureSourceBaselineFieldNumber = 18,
    kValveBreakdownTemperatureFieldNumber = 19,
  };
  // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
  bool has_circuitpath() const;
  private:
  bool _internal_has_circuitpath() const;
  public:
  void clear_circuitpath();
  const ::pulse::cdm::bind::CircuitPathData& circuitpath() const;
  ::pulse::cdm::bind::CircuitPathData* release_circuitpath();
  ::pulse::cdm::bind::CircuitPathData* mutable_circuitpath();
  void set_allocated_circuitpath(::pulse::cdm::bind::CircuitPathData* circuitpath);
  private:
  const ::pulse::cdm::bind::CircuitPathData& _internal_circuitpath() const;
  ::pulse::cdm::bind::CircuitPathData* _internal_mutable_circuitpath();
  public:
  void unsafe_arena_set_allocated_circuitpath(
      ::pulse::cdm::bind::CircuitPathData* circuitpath);
  ::pulse::cdm::bind::CircuitPathData* unsafe_arena_release_circuitpath();

  // .pulse.cdm.bind.ScalarHeatResistanceData Resistance = 2;
  bool has_resistance() const;
  private:
  bool _internal_has_resistance() const;
  public:
  void clear_resistance();
  const ::pulse::cdm::bind::ScalarHeatResistanceData& resistance() const;
  ::pulse::cdm::bind::ScalarHeatResistanceData* release_resistance();
  ::pulse::cdm::bind::ScalarHeatResistanceData* mutable_resistance();
  void set_allocated_resistance(::pulse::cdm::bind::ScalarHeatResistanceData* resistance);
  private:
  const ::pulse::cdm::bind::ScalarHeatResistanceData& _internal_resistance() const;
  ::pulse::cdm::bind::ScalarHeatResistanceData* _internal_mutable_resistance();
  public:
  void unsafe_arena_set_allocated_resistance(
      ::pulse::cdm::bind::ScalarHeatResistanceData* resistance);
  ::pulse::cdm::bind::ScalarHeatResistanceData* unsafe_arena_release_resistance();

  // .pulse.cdm.bind.ScalarHeatResistanceData NextResistance = 3;
  bool has_nextresistance() const;
  private:
  bool _internal_has_nextresistance() const;
  public:
  void clear_nextresistance();
  const ::pulse::cdm::bind::ScalarHeatResistanceData& nextresistance() const;
  ::pulse::cdm::bind::ScalarHeatResistanceData* release_nextresistance();
  ::pulse::cdm::bind::ScalarHeatResistanceData* mutable_nextresistance();
  void set_allocated_nextresistance(::pulse::cdm::bind::ScalarHeatResistanceData* nextresistance);
  private:
  const ::pulse::cdm::bind::ScalarHeatResistanceData& _internal_nextresistance() const;
  ::pulse::cdm::bind::ScalarHeatResistanceData* _internal_mutable_nextresistance();
  public:
  void unsafe_arena_set_allocated_nextresistance(
      ::pulse::cdm::bind::ScalarHeatResistanceData* nextresistance);
  ::pulse::cdm::bind::ScalarHeatResistanceData* unsafe_arena_release_nextresistance();

  // .pulse.cdm.bind.ScalarHeatResistanceData ResistanceBaseline = 4;
  bool has_resistancebaseline() const;
  private:
  bool _internal_has_resistancebaseline() const;
  public:
  void clear_resistancebaseline();
  const ::pulse::cdm::bind::ScalarHeatResistanceData& resistancebaseline() const;
  ::pulse::cdm::bind::ScalarHeatResistanceData* release_resistancebaseline();
  ::pulse::cdm::bind::ScalarHeatResistanceData* mutable_resistancebaseline();
  void set_allocated_resistancebaseline(::pulse::cdm::bind::ScalarHeatResistanceData* resistancebaseline);
  private:
  const ::pulse::cdm::bind::ScalarHeatResistanceData& _internal_resistancebaseline() const;
  ::pulse::cdm::bind::ScalarHeatResistanceData* _internal_mutable_resistancebaseline();
  public:
  void unsafe_arena_set_allocated_resistancebaseline(
      ::pulse::cdm::bind::ScalarHeatResistanceData* resistancebaseline);
  ::pulse::cdm::bind::ScalarHeatResistanceData* unsafe_arena_release_resistancebaseline();

  // .pulse.cdm.bind.ScalarHeatCapacitanceData Capacitance = 5;
  bool has_capacitance() const;
  private:
  bool _internal_has_capacitance() const;
  public:
  void clear_capacitance();
  const ::pulse::cdm::bind::ScalarHeatCapacitanceData& capacitance() const;
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* release_capacitance();
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* mutable_capacitance();
  void set_allocated_capacitance(::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitance);
  private:
  const ::pulse::cdm::bind::ScalarHeatCapacitanceData& _internal_capacitance() const;
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* _internal_mutable_capacitance();
  public:
  void unsafe_arena_set_allocated_capacitance(
      ::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitance);
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* unsafe_arena_release_capacitance();

  // .pulse.cdm.bind.ScalarHeatCapacitanceData NextCapacitance = 6;
  bool has_nextcapacitance() const;
  private:
  bool _internal_has_nextcapacitance() const;
  public:
  void clear_nextcapacitance();
  const ::pulse::cdm::bind::ScalarHeatCapacitanceData& nextcapacitance() const;
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* release_nextcapacitance();
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* mutable_nextcapacitance();
  void set_allocated_nextcapacitance(::pulse::cdm::bind::ScalarHeatCapacitanceData* nextcapacitance);
  private:
  const ::pulse::cdm::bind::ScalarHeatCapacitanceData& _internal_nextcapacitance() const;
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* _internal_mutable_nextcapacitance();
  public:
  void unsafe_arena_set_allocated_nextcapacitance(
      ::pulse::cdm::bind::ScalarHeatCapacitanceData* nextcapacitance);
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* unsafe_arena_release_nextcapacitance();

  // .pulse.cdm.bind.ScalarHeatCapacitanceData CapacitanceBaseline = 7;
  bool has_capacitancebaseline() const;
  private:
  bool _internal_has_capacitancebaseline() const;
  public:
  void clear_capacitancebaseline();
  const ::pulse::cdm::bind::ScalarHeatCapacitanceData& capacitancebaseline() const;
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* release_capacitancebaseline();
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* mutable_capacitancebaseline();
  void set_allocated_capacitancebaseline(::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitancebaseline);
  private:
  const ::pulse::cdm::bind::ScalarHeatCapacitanceData& _internal_capacitancebaseline() const;
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* _internal_mutable_capacitancebaseline();
  public:
  void unsafe_arena_set_allocated_capacitancebaseline(
      ::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitancebaseline);
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* unsafe_arena_release_capacitancebaseline();

  // .pulse.cdm.bind.ScalarHeatInductanceData Inductance = 8;
  bool has_inductance() const;
  private:
  bool _internal_has_inductance() const;
  public:
  void clear_inductance();
  const ::pulse::cdm::bind::ScalarHeatInductanceData& inductance() const;
  ::pulse::cdm::bind::ScalarHeatInductanceData* release_inductance();
  ::pulse::cdm::bind::ScalarHeatInductanceData* mutable_inductance();
  void set_allocated_inductance(::pulse::cdm::bind::ScalarHeatInductanceData* inductance);
  private:
  const ::pulse::cdm::bind::ScalarHeatInductanceData& _internal_inductance() const;
  ::pulse::cdm::bind::ScalarHeatInductanceData* _internal_mutable_inductance();
  public:
  void unsafe_arena_set_allocated_inductance(
      ::pulse::cdm::bind::ScalarHeatInductanceData* inductance);
  ::pulse::cdm::bind::ScalarHeatInductanceData* unsafe_arena_release_inductance();

  // .pulse.cdm.bind.ScalarHeatInductanceData NextInductance = 9;
  bool has_nextinductance() const;
  private:
  bool _internal_has_nextinductance() const;
  public:
  void clear_nextinductance();
  const ::pulse::cdm::bind::ScalarHeatInductanceData& nextinductance() const;
  ::pulse::cdm::bind::ScalarHeatInductanceData* release_nextinductance();
  ::pulse::cdm::bind::ScalarHeatInductanceData* mutable_nextinductance();
  void set_allocated_nextinductance(::pulse::cdm::bind::ScalarHeatInductanceData* nextinductance);
  private:
  const ::pulse::cdm::bind::ScalarHeatInductanceData& _internal_nextinductance() const;
  ::pulse::cdm::bind::ScalarHeatInductanceData* _internal_mutable_nextinductance();
  public:
  void unsafe_arena_set_allocated_nextinductance(
      ::pulse::cdm::bind::ScalarHeatInductanceData* nextinductance);
  ::pulse::cdm::bind::ScalarHeatInductanceData* unsafe_arena_release_nextinductance();

  // .pulse.cdm.bind.ScalarHeatInductanceData InductanceBaseline = 10;
  bool has_inductancebaseline() const;
  private:
  bool _internal_has_inductancebaseline() const;
  public:
  void clear_inductancebaseline();
  const ::pulse::cdm::bind::ScalarHeatInductanceData& inductancebaseline() const;
  ::pulse::cdm::bind::ScalarHeatInductanceData* release_inductancebaseline();
  ::pulse::cdm::bind::ScalarHeatInductanceData* mutable_inductancebaseline();
  void set_allocated_inductancebaseline(::pulse::cdm::bind::ScalarHeatInductanceData* inductancebaseline);
  private:
  const ::pulse::cdm::bind::ScalarHeatInductanceData& _internal_inductancebaseline() const;
  ::pulse::cdm::bind::ScalarHeatInductanceData* _internal_mutable_inductancebaseline();
  public:
  void unsafe_arena_set_allocated_inductancebaseline(
      ::pulse::cdm::bind::ScalarHeatInductanceData* inductancebaseline);
  ::pulse::cdm::bind::ScalarHeatInductanceData* unsafe_arena_release_inductancebaseline();

  // .pulse.cdm.bind.ScalarPowerData HeatTransferRate = 11;
  bool has_heattransferrate() const;
  private:
  bool _internal_has_heattransferrate() const;
  public:
  void clear_heattransferrate();
  const ::pulse::cdm::bind::ScalarPowerData& heattransferrate() const;
  ::pulse::cdm::bind::ScalarPowerData* release_heattransferrate();
  ::pulse::cdm::bind::ScalarPowerData* mutable_heattransferrate();
  void set_allocated_heattransferrate(::pulse::cdm::bind::ScalarPowerData* heattransferrate);
  private:
  const ::pulse::cdm::bind::ScalarPowerData& _internal_heattransferrate() const;
  ::pulse::cdm::bind::ScalarPowerData* _internal_mutable_heattransferrate();
  public:
  void unsafe_arena_set_allocated_heattransferrate(
      ::pulse::cdm::bind::ScalarPowerData* heattransferrate);
  ::pulse::cdm::bind::ScalarPowerData* unsafe_arena_release_heattransferrate();

  // .pulse.cdm.bind.ScalarPowerData NextHeatTransferRate = 12;
  bool has_nextheattransferrate() const;
  private:
  bool _internal_has_nextheattransferrate() const;
  public:
  void clear_nextheattransferrate();
  const ::pulse::cdm::bind::ScalarPowerData& nextheattransferrate() const;
  ::pulse::cdm::bind::ScalarPowerData* release_nextheattransferrate();
  ::pulse::cdm::bind::ScalarPowerData* mutable_nextheattransferrate();
  void set_allocated_nextheattransferrate(::pulse::cdm::bind::ScalarPowerData* nextheattransferrate);
  private:
  const ::pulse::cdm::bind::ScalarPowerData& _internal_nextheattransferrate() const;
  ::pulse::cdm::bind::ScalarPowerData* _internal_mutable_nextheattransferrate();
  public:
  void unsafe_arena_set_allocated_nextheattransferrate(
      ::pulse::cdm::bind::ScalarPowerData* nextheattransferrate);
  ::pulse::cdm::bind::ScalarPowerData* unsafe_arena_release_nextheattransferrate();

  // .pulse.cdm.bind.ScalarPowerData HeatSource = 13;
  bool has_heatsource() const;
  private:
  bool _internal_has_heatsource() const;
  public:
  void clear_heatsource();
  const ::pulse::cdm::bind::ScalarPowerData& heatsource() const;
  ::pulse::cdm::bind::ScalarPowerData* release_heatsource();
  ::pulse::cdm::bind::ScalarPowerData* mutable_heatsource();
  void set_allocated_heatsource(::pulse::cdm::bind::ScalarPowerData* heatsource);
  private:
  const ::pulse::cdm::bind::ScalarPowerData& _internal_heatsource() const;
  ::pulse::cdm::bind::ScalarPowerData* _internal_mutable_heatsource();
  public:
  void unsafe_arena_set_allocated_heatsource(
      ::pulse::cdm::bind::ScalarPowerData* heatsource);
  ::pulse::cdm::bind::ScalarPowerData* unsafe_arena_release_heatsource();

  // .pulse.cdm.bind.ScalarPowerData NextHeatSource = 14;
  bool has_nextheatsource() const;
  private:
  bool _internal_has_nextheatsource() const;
  public:
  void clear_nextheatsource();
  const ::pulse::cdm::bind::ScalarPowerData& nextheatsource() const;
  ::pulse::cdm::bind::ScalarPowerData* release_nextheatsource();
  ::pulse::cdm::bind::ScalarPowerData* mutable_nextheatsource();
  void set_allocated_nextheatsource(::pulse::cdm::bind::ScalarPowerData* nextheatsource);
  private:
  const ::pulse::cdm::bind::ScalarPowerData& _internal_nextheatsource() const;
  ::pulse::cdm::bind::ScalarPowerData* _internal_mutable_nextheatsource();
  public:
  void unsafe_arena_set_allocated_nextheatsource(
      ::pulse::cdm::bind::ScalarPowerData* nextheatsource);
  ::pulse::cdm::bind::ScalarPowerData* unsafe_arena_release_nextheatsource();

  // .pulse.cdm.bind.ScalarPowerData HeatSourceBaseline = 15;
  bool has_heatsourcebaseline() const;
  private:
  bool _internal_has_heatsourcebaseline() const;
  public:
  void clear_heatsourcebaseline();
  const ::pulse::cdm::bind::ScalarPowerData& heatsourcebaseline() const;
  ::pulse::cdm::bind::ScalarPowerData* release_heatsourcebaseline();
  ::pulse::cdm::bind::ScalarPowerData* mutable_heatsourcebaseline();
  void set_allocated_heatsourcebaseline(::pulse::cdm::bind::ScalarPowerData* heatsourcebaseline);
  private:
  const ::pulse::cdm::bind::ScalarPowerData& _internal_heatsourcebaseline() const;
  ::pulse::cdm::bind::ScalarPowerData* _internal_mutable_heatsourcebaseline();
  public:
  void unsafe_arena_set_allocated_heatsourcebaseline(
      ::pulse::cdm::bind::ScalarPowerData* heatsourcebaseline);
  ::pulse::cdm::bind::ScalarPowerData* unsafe_arena_release_heatsourcebaseline();

  // .pulse.cdm.bind.ScalarTemperatureData TemperatureSource = 16;
  bool has_temperaturesource() const;
  private:
  bool _internal_has_temperaturesource() const;
  public:
  void clear_temperaturesource();
  const ::pulse::cdm::bind::ScalarTemperatureData& temperaturesource() const;
  ::pulse::cdm::bind::ScalarTemperatureData* release_temperaturesource();
  ::pulse::cdm::bind::ScalarTemperatureData* mutable_temperaturesource();
  void set_allocated_temperaturesource(::pulse::cdm::bind::ScalarTemperatureData* temperaturesource);
  private:
  const ::pulse::cdm::bind::ScalarTemperatureData& _internal_temperaturesource() const;
  ::pulse::cdm::bind::ScalarTemperatureData* _internal_mutable_temperaturesource();
  public:
  void unsafe_arena_set_allocated_temperaturesource(
      ::pulse::cdm::bind::ScalarTemperatureData* temperaturesource);
  ::pulse::cdm::bind::ScalarTemperatureData* unsafe_arena_release_temperaturesource();

  // .pulse.cdm.bind.ScalarTemperatureData NextTemperatureSource = 17;
  bool has_nexttemperaturesource() const;
  private:
  bool _internal_has_nexttemperaturesource() const;
  public:
  void clear_nexttemperaturesource();
  const ::pulse::cdm::bind::ScalarTemperatureData& nexttemperaturesource() const;
  ::pulse::cdm::bind::ScalarTemperatureData* release_nexttemperaturesource();
  ::pulse::cdm::bind::ScalarTemperatureData* mutable_nexttemperaturesource();
  void set_allocated_nexttemperaturesource(::pulse::cdm::bind::ScalarTemperatureData* nexttemperaturesource);
  private:
  const ::pulse::cdm::bind::ScalarTemperatureData& _internal_nexttemperaturesource() const;
  ::pulse::cdm::bind::ScalarTemperatureData* _internal_mutable_nexttemperaturesource();
  public:
  void unsafe_arena_set_allocated_nexttemperaturesource(
      ::pulse::cdm::bind::ScalarTemperatureData* nexttemperaturesource);
  ::pulse::cdm::bind::ScalarTemperatureData* unsafe_arena_release_nexttemperaturesource();

  // .pulse.cdm.bind.ScalarTemperatureData TemperatureSourceBaseline = 18;
  bool has_temperaturesourcebaseline() const;
  private:
  bool _internal_has_temperaturesourcebaseline() const;
  public:
  void clear_temperaturesourcebaseline();
  const ::pulse::cdm::bind::ScalarTemperatureData& temperaturesourcebaseline() const;
  ::pulse::cdm::bind::ScalarTemperatureData* release_temperaturesourcebaseline();
  ::pulse::cdm::bind::ScalarTemperatureData* mutable_temperaturesourcebaseline();
  void set_allocated_temperaturesourcebaseline(::pulse::cdm::bind::ScalarTemperatureData* temperaturesourcebaseline);
  private:
  const ::pulse::cdm::bind::ScalarTemperatureData& _internal_temperaturesourcebaseline() const;
  ::pulse::cdm::bind::ScalarTemperatureData* _internal_mutable_temperaturesourcebaseline();
  public:
  void unsafe_arena_set_allocated_temperaturesourcebaseline(
      ::pulse::cdm::bind::ScalarTemperatureData* temperaturesourcebaseline);
  ::pulse::cdm::bind::ScalarTemperatureData* unsafe_arena_release_temperaturesourcebaseline();

  // .pulse.cdm.bind.ScalarTemperatureData ValveBreakdownTemperature = 19;
  bool has_valvebreakdowntemperature() const;
  private:
  bool _internal_has_valvebreakdowntemperature() const;
  public:
  void clear_valvebreakdowntemperature();
  const ::pulse::cdm::bind::ScalarTemperatureData& valvebreakdowntemperature() const;
  ::pulse::cdm::bind::ScalarTemperatureData* release_valvebreakdowntemperature();
  ::pulse::cdm::bind::ScalarTemperatureData* mutable_valvebreakdowntemperature();
  void set_allocated_valvebreakdowntemperature(::pulse::cdm::bind::ScalarTemperatureData* valvebreakdowntemperature);
  private:
  const ::pulse::cdm::bind::ScalarTemperatureData& _internal_valvebreakdowntemperature() const;
  ::pulse::cdm::bind::ScalarTemperatureData* _internal_mutable_valvebreakdowntemperature();
  public:
  void unsafe_arena_set_allocated_valvebreakdowntemperature(
      ::pulse::cdm::bind::ScalarTemperatureData* valvebreakdowntemperature);
  ::pulse::cdm::bind::ScalarTemperatureData* unsafe_arena_release_valvebreakdowntemperature();

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.ThermalCircuitPathData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pulse::cdm::bind::CircuitPathData* circuitpath_;
  ::pulse::cdm::bind::ScalarHeatResistanceData* resistance_;
  ::pulse::cdm::bind::ScalarHeatResistanceData* nextresistance_;
  ::pulse::cdm::bind::ScalarHeatResistanceData* resistancebaseline_;
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitance_;
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* nextcapacitance_;
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitancebaseline_;
  ::pulse::cdm::bind::ScalarHeatInductanceData* inductance_;
  ::pulse::cdm::bind::ScalarHeatInductanceData* nextinductance_;
  ::pulse::cdm::bind::ScalarHeatInductanceData* inductancebaseline_;
  ::pulse::cdm::bind::ScalarPowerData* heattransferrate_;
  ::pulse::cdm::bind::ScalarPowerData* nextheattransferrate_;
  ::pulse::cdm::bind::ScalarPowerData* heatsource_;
  ::pulse::cdm::bind::ScalarPowerData* nextheatsource_;
  ::pulse::cdm::bind::ScalarPowerData* heatsourcebaseline_;
  ::pulse::cdm::bind::ScalarTemperatureData* temperaturesource_;
  ::pulse::cdm::bind::ScalarTemperatureData* nexttemperaturesource_;
  ::pulse::cdm::bind::ScalarTemperatureData* temperaturesourcebaseline_;
  ::pulse::cdm::bind::ScalarTemperatureData* valvebreakdowntemperature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// -------------------------------------------------------------------

class CircuitManagerData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.CircuitManagerData) */ {
 public:
  inline CircuitManagerData() : CircuitManagerData(nullptr) {}
  virtual ~CircuitManagerData();

  CircuitManagerData(const CircuitManagerData& from);
  CircuitManagerData(CircuitManagerData&& from) noexcept
    : CircuitManagerData() {
    *this = ::std::move(from);
  }

  inline CircuitManagerData& operator=(const CircuitManagerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitManagerData& operator=(CircuitManagerData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircuitManagerData& default_instance();

  static inline const CircuitManagerData* internal_default_instance() {
    return reinterpret_cast<const CircuitManagerData*>(
               &_CircuitManagerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CircuitManagerData& a, CircuitManagerData& b) {
    a.Swap(&b);
  }
  inline void Swap(CircuitManagerData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitManagerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircuitManagerData* New() const final {
    return CreateMaybeMessage<CircuitManagerData>(nullptr);
  }

  CircuitManagerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircuitManagerData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircuitManagerData& from);
  void MergeFrom(const CircuitManagerData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircuitManagerData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.CircuitManagerData";
  }
  protected:
  explicit CircuitManagerData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElectricalNodeFieldNumber = 1,
    kElectricalPathFieldNumber = 2,
    kElectricalCircuitFieldNumber = 3,
    kFluidNodeFieldNumber = 4,
    kFluidPathFieldNumber = 5,
    kFluidCircuitFieldNumber = 6,
    kThermalNodeFieldNumber = 7,
    kThermalPathFieldNumber = 8,
    kThermalCircuitFieldNumber = 9,
  };
  // repeated .pulse.cdm.bind.ElectricalCircuitNodeData ElectricalNode = 1;
  int electricalnode_size() const;
  private:
  int _internal_electricalnode_size() const;
  public:
  void clear_electricalnode();
  ::pulse::cdm::bind::ElectricalCircuitNodeData* mutable_electricalnode(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitNodeData >*
      mutable_electricalnode();
  private:
  const ::pulse::cdm::bind::ElectricalCircuitNodeData& _internal_electricalnode(int index) const;
  ::pulse::cdm::bind::ElectricalCircuitNodeData* _internal_add_electricalnode();
  public:
  const ::pulse::cdm::bind::ElectricalCircuitNodeData& electricalnode(int index) const;
  ::pulse::cdm::bind::ElectricalCircuitNodeData* add_electricalnode();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitNodeData >&
      electricalnode() const;

  // repeated .pulse.cdm.bind.ElectricalCircuitPathData ElectricalPath = 2;
  int electricalpath_size() const;
  private:
  int _internal_electricalpath_size() const;
  public:
  void clear_electricalpath();
  ::pulse::cdm::bind::ElectricalCircuitPathData* mutable_electricalpath(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitPathData >*
      mutable_electricalpath();
  private:
  const ::pulse::cdm::bind::ElectricalCircuitPathData& _internal_electricalpath(int index) const;
  ::pulse::cdm::bind::ElectricalCircuitPathData* _internal_add_electricalpath();
  public:
  const ::pulse::cdm::bind::ElectricalCircuitPathData& electricalpath(int index) const;
  ::pulse::cdm::bind::ElectricalCircuitPathData* add_electricalpath();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitPathData >&
      electricalpath() const;

  // repeated .pulse.cdm.bind.ElectricalCircuitData ElectricalCircuit = 3;
  int electricalcircuit_size() const;
  private:
  int _internal_electricalcircuit_size() const;
  public:
  void clear_electricalcircuit();
  ::pulse::cdm::bind::ElectricalCircuitData* mutable_electricalcircuit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitData >*
      mutable_electricalcircuit();
  private:
  const ::pulse::cdm::bind::ElectricalCircuitData& _internal_electricalcircuit(int index) const;
  ::pulse::cdm::bind::ElectricalCircuitData* _internal_add_electricalcircuit();
  public:
  const ::pulse::cdm::bind::ElectricalCircuitData& electricalcircuit(int index) const;
  ::pulse::cdm::bind::ElectricalCircuitData* add_electricalcircuit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitData >&
      electricalcircuit() const;

  // repeated .pulse.cdm.bind.FluidCircuitNodeData FluidNode = 4;
  int fluidnode_size() const;
  private:
  int _internal_fluidnode_size() const;
  public:
  void clear_fluidnode();
  ::pulse::cdm::bind::FluidCircuitNodeData* mutable_fluidnode(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitNodeData >*
      mutable_fluidnode();
  private:
  const ::pulse::cdm::bind::FluidCircuitNodeData& _internal_fluidnode(int index) const;
  ::pulse::cdm::bind::FluidCircuitNodeData* _internal_add_fluidnode();
  public:
  const ::pulse::cdm::bind::FluidCircuitNodeData& fluidnode(int index) const;
  ::pulse::cdm::bind::FluidCircuitNodeData* add_fluidnode();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitNodeData >&
      fluidnode() const;

  // repeated .pulse.cdm.bind.FluidCircuitPathData FluidPath = 5;
  int fluidpath_size() const;
  private:
  int _internal_fluidpath_size() const;
  public:
  void clear_fluidpath();
  ::pulse::cdm::bind::FluidCircuitPathData* mutable_fluidpath(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitPathData >*
      mutable_fluidpath();
  private:
  const ::pulse::cdm::bind::FluidCircuitPathData& _internal_fluidpath(int index) const;
  ::pulse::cdm::bind::FluidCircuitPathData* _internal_add_fluidpath();
  public:
  const ::pulse::cdm::bind::FluidCircuitPathData& fluidpath(int index) const;
  ::pulse::cdm::bind::FluidCircuitPathData* add_fluidpath();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitPathData >&
      fluidpath() const;

  // repeated .pulse.cdm.bind.FluidCircuitData FluidCircuit = 6;
  int fluidcircuit_size() const;
  private:
  int _internal_fluidcircuit_size() const;
  public:
  void clear_fluidcircuit();
  ::pulse::cdm::bind::FluidCircuitData* mutable_fluidcircuit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitData >*
      mutable_fluidcircuit();
  private:
  const ::pulse::cdm::bind::FluidCircuitData& _internal_fluidcircuit(int index) const;
  ::pulse::cdm::bind::FluidCircuitData* _internal_add_fluidcircuit();
  public:
  const ::pulse::cdm::bind::FluidCircuitData& fluidcircuit(int index) const;
  ::pulse::cdm::bind::FluidCircuitData* add_fluidcircuit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitData >&
      fluidcircuit() const;

  // repeated .pulse.cdm.bind.ThermalCircuitNodeData ThermalNode = 7;
  int thermalnode_size() const;
  private:
  int _internal_thermalnode_size() const;
  public:
  void clear_thermalnode();
  ::pulse::cdm::bind::ThermalCircuitNodeData* mutable_thermalnode(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitNodeData >*
      mutable_thermalnode();
  private:
  const ::pulse::cdm::bind::ThermalCircuitNodeData& _internal_thermalnode(int index) const;
  ::pulse::cdm::bind::ThermalCircuitNodeData* _internal_add_thermalnode();
  public:
  const ::pulse::cdm::bind::ThermalCircuitNodeData& thermalnode(int index) const;
  ::pulse::cdm::bind::ThermalCircuitNodeData* add_thermalnode();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitNodeData >&
      thermalnode() const;

  // repeated .pulse.cdm.bind.ThermalCircuitPathData ThermalPath = 8;
  int thermalpath_size() const;
  private:
  int _internal_thermalpath_size() const;
  public:
  void clear_thermalpath();
  ::pulse::cdm::bind::ThermalCircuitPathData* mutable_thermalpath(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitPathData >*
      mutable_thermalpath();
  private:
  const ::pulse::cdm::bind::ThermalCircuitPathData& _internal_thermalpath(int index) const;
  ::pulse::cdm::bind::ThermalCircuitPathData* _internal_add_thermalpath();
  public:
  const ::pulse::cdm::bind::ThermalCircuitPathData& thermalpath(int index) const;
  ::pulse::cdm::bind::ThermalCircuitPathData* add_thermalpath();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitPathData >&
      thermalpath() const;

  // repeated .pulse.cdm.bind.ThermalCircuitData ThermalCircuit = 9;
  int thermalcircuit_size() const;
  private:
  int _internal_thermalcircuit_size() const;
  public:
  void clear_thermalcircuit();
  ::pulse::cdm::bind::ThermalCircuitData* mutable_thermalcircuit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitData >*
      mutable_thermalcircuit();
  private:
  const ::pulse::cdm::bind::ThermalCircuitData& _internal_thermalcircuit(int index) const;
  ::pulse::cdm::bind::ThermalCircuitData* _internal_add_thermalcircuit();
  public:
  const ::pulse::cdm::bind::ThermalCircuitData& thermalcircuit(int index) const;
  ::pulse::cdm::bind::ThermalCircuitData* add_thermalcircuit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitData >&
      thermalcircuit() const;

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.CircuitManagerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitNodeData > electricalnode_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitPathData > electricalpath_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitData > electricalcircuit_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitNodeData > fluidnode_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitPathData > fluidpath_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitData > fluidcircuit_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitNodeData > thermalnode_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitPathData > thermalpath_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitData > thermalcircuit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CircuitData

// string Name = 1;
inline void CircuitData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CircuitData::name() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitData.Name)
  return _internal_name();
}
inline void CircuitData::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitData.Name)
}
inline std::string* CircuitData::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitData.Name)
  return _internal_mutable_name();
}
inline const std::string& CircuitData::_internal_name() const {
  return name_.Get();
}
inline void CircuitData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CircuitData::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pulse.cdm.bind.CircuitData.Name)
}
inline void CircuitData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pulse.cdm.bind.CircuitData.Name)
}
inline void CircuitData::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pulse.cdm.bind.CircuitData.Name)
}
inline std::string* CircuitData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CircuitData::release_name() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.CircuitData.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CircuitData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.CircuitData.Name)
}

// repeated string Node = 2;
inline int CircuitData::_internal_node_size() const {
  return node_.size();
}
inline int CircuitData::node_size() const {
  return _internal_node_size();
}
inline void CircuitData::clear_node() {
  node_.Clear();
}
inline std::string* CircuitData::add_node() {
  // @@protoc_insertion_point(field_add_mutable:pulse.cdm.bind.CircuitData.Node)
  return _internal_add_node();
}
inline const std::string& CircuitData::_internal_node(int index) const {
  return node_.Get(index);
}
inline const std::string& CircuitData::node(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitData.Node)
  return _internal_node(index);
}
inline std::string* CircuitData::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitData.Node)
  return node_.Mutable(index);
}
inline void CircuitData::set_node(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitData.Node)
  node_.Mutable(index)->assign(value);
}
inline void CircuitData::set_node(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitData.Node)
  node_.Mutable(index)->assign(std::move(value));
}
inline void CircuitData::set_node(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  node_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulse.cdm.bind.CircuitData.Node)
}
inline void CircuitData::set_node(int index, const char* value, size_t size) {
  node_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulse.cdm.bind.CircuitData.Node)
}
inline std::string* CircuitData::_internal_add_node() {
  return node_.Add();
}
inline void CircuitData::add_node(const std::string& value) {
  node_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitData.Node)
}
inline void CircuitData::add_node(std::string&& value) {
  node_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitData.Node)
}
inline void CircuitData::add_node(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  node_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulse.cdm.bind.CircuitData.Node)
}
inline void CircuitData::add_node(const char* value, size_t size) {
  node_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulse.cdm.bind.CircuitData.Node)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CircuitData::node() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitData.Node)
  return node_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CircuitData::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitData.Node)
  return &node_;
}

// repeated string Path = 3;
inline int CircuitData::_internal_path_size() const {
  return path_.size();
}
inline int CircuitData::path_size() const {
  return _internal_path_size();
}
inline void CircuitData::clear_path() {
  path_.Clear();
}
inline std::string* CircuitData::add_path() {
  // @@protoc_insertion_point(field_add_mutable:pulse.cdm.bind.CircuitData.Path)
  return _internal_add_path();
}
inline const std::string& CircuitData::_internal_path(int index) const {
  return path_.Get(index);
}
inline const std::string& CircuitData::path(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitData.Path)
  return _internal_path(index);
}
inline std::string* CircuitData::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitData.Path)
  return path_.Mutable(index);
}
inline void CircuitData::set_path(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitData.Path)
  path_.Mutable(index)->assign(value);
}
inline void CircuitData::set_path(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitData.Path)
  path_.Mutable(index)->assign(std::move(value));
}
inline void CircuitData::set_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulse.cdm.bind.CircuitData.Path)
}
inline void CircuitData::set_path(int index, const char* value, size_t size) {
  path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulse.cdm.bind.CircuitData.Path)
}
inline std::string* CircuitData::_internal_add_path() {
  return path_.Add();
}
inline void CircuitData::add_path(const std::string& value) {
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitData.Path)
}
inline void CircuitData::add_path(std::string&& value) {
  path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitData.Path)
}
inline void CircuitData::add_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulse.cdm.bind.CircuitData.Path)
}
inline void CircuitData::add_path(const char* value, size_t size) {
  path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulse.cdm.bind.CircuitData.Path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CircuitData::path() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitData.Path)
  return path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CircuitData::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitData.Path)
  return &path_;
}

// -------------------------------------------------------------------

// CircuitNodeData

// string Name = 1;
inline void CircuitNodeData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CircuitNodeData::name() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitNodeData.Name)
  return _internal_name();
}
inline void CircuitNodeData::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitNodeData.Name)
}
inline std::string* CircuitNodeData::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitNodeData.Name)
  return _internal_mutable_name();
}
inline const std::string& CircuitNodeData::_internal_name() const {
  return name_.Get();
}
inline void CircuitNodeData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CircuitNodeData::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pulse.cdm.bind.CircuitNodeData.Name)
}
inline void CircuitNodeData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pulse.cdm.bind.CircuitNodeData.Name)
}
inline void CircuitNodeData::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pulse.cdm.bind.CircuitNodeData.Name)
}
inline std::string* CircuitNodeData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CircuitNodeData::release_name() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.CircuitNodeData.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CircuitNodeData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.CircuitNodeData.Name)
}

// bool ReferenceNode = 2;
inline void CircuitNodeData::clear_referencenode() {
  referencenode_ = false;
}
inline bool CircuitNodeData::_internal_referencenode() const {
  return referencenode_;
}
inline bool CircuitNodeData::referencenode() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitNodeData.ReferenceNode)
  return _internal_referencenode();
}
inline void CircuitNodeData::_internal_set_referencenode(bool value) {
  
  referencenode_ = value;
}
inline void CircuitNodeData::set_referencenode(bool value) {
  _internal_set_referencenode(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitNodeData.ReferenceNode)
}

// -------------------------------------------------------------------

// CircuitPathData

// string Name = 1;
inline void CircuitPathData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CircuitPathData::name() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitPathData.Name)
  return _internal_name();
}
inline void CircuitPathData::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitPathData.Name)
}
inline std::string* CircuitPathData::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitPathData.Name)
  return _internal_mutable_name();
}
inline const std::string& CircuitPathData::_internal_name() const {
  return name_.Get();
}
inline void CircuitPathData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CircuitPathData::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pulse.cdm.bind.CircuitPathData.Name)
}
inline void CircuitPathData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pulse.cdm.bind.CircuitPathData.Name)
}
inline void CircuitPathData::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pulse.cdm.bind.CircuitPathData.Name)
}
inline std::string* CircuitPathData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CircuitPathData::release_name() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.CircuitPathData.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CircuitPathData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.CircuitPathData.Name)
}

// string SourceNode = 2;
inline void CircuitPathData::clear_sourcenode() {
  sourcenode_.ClearToEmpty();
}
inline const std::string& CircuitPathData::sourcenode() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitPathData.SourceNode)
  return _internal_sourcenode();
}
inline void CircuitPathData::set_sourcenode(const std::string& value) {
  _internal_set_sourcenode(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitPathData.SourceNode)
}
inline std::string* CircuitPathData::mutable_sourcenode() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitPathData.SourceNode)
  return _internal_mutable_sourcenode();
}
inline const std::string& CircuitPathData::_internal_sourcenode() const {
  return sourcenode_.Get();
}
inline void CircuitPathData::_internal_set_sourcenode(const std::string& value) {
  
  sourcenode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CircuitPathData::set_sourcenode(std::string&& value) {
  
  sourcenode_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pulse.cdm.bind.CircuitPathData.SourceNode)
}
inline void CircuitPathData::set_sourcenode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sourcenode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pulse.cdm.bind.CircuitPathData.SourceNode)
}
inline void CircuitPathData::set_sourcenode(const char* value,
    size_t size) {
  
  sourcenode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pulse.cdm.bind.CircuitPathData.SourceNode)
}
inline std::string* CircuitPathData::_internal_mutable_sourcenode() {
  
  return sourcenode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CircuitPathData::release_sourcenode() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.CircuitPathData.SourceNode)
  return sourcenode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CircuitPathData::set_allocated_sourcenode(std::string* sourcenode) {
  if (sourcenode != nullptr) {
    
  } else {
    
  }
  sourcenode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourcenode,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.CircuitPathData.SourceNode)
}

// string TargetNode = 3;
inline void CircuitPathData::clear_targetnode() {
  targetnode_.ClearToEmpty();
}
inline const std::string& CircuitPathData::targetnode() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitPathData.TargetNode)
  return _internal_targetnode();
}
inline void CircuitPathData::set_targetnode(const std::string& value) {
  _internal_set_targetnode(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitPathData.TargetNode)
}
inline std::string* CircuitPathData::mutable_targetnode() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitPathData.TargetNode)
  return _internal_mutable_targetnode();
}
inline const std::string& CircuitPathData::_internal_targetnode() const {
  return targetnode_.Get();
}
inline void CircuitPathData::_internal_set_targetnode(const std::string& value) {
  
  targetnode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CircuitPathData::set_targetnode(std::string&& value) {
  
  targetnode_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pulse.cdm.bind.CircuitPathData.TargetNode)
}
inline void CircuitPathData::set_targetnode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  targetnode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pulse.cdm.bind.CircuitPathData.TargetNode)
}
inline void CircuitPathData::set_targetnode(const char* value,
    size_t size) {
  
  targetnode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pulse.cdm.bind.CircuitPathData.TargetNode)
}
inline std::string* CircuitPathData::_internal_mutable_targetnode() {
  
  return targetnode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CircuitPathData::release_targetnode() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.CircuitPathData.TargetNode)
  return targetnode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CircuitPathData::set_allocated_targetnode(std::string* targetnode) {
  if (targetnode != nullptr) {
    
  } else {
    
  }
  targetnode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), targetnode,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.CircuitPathData.TargetNode)
}

// .pulse.cdm.bind.eGate Switch = 4;
inline void CircuitPathData::clear_switch_() {
  switch__ = 0;
}
inline ::pulse::cdm::bind::eGate CircuitPathData::_internal_switch_() const {
  return static_cast< ::pulse::cdm::bind::eGate >(switch__);
}
inline ::pulse::cdm::bind::eGate CircuitPathData::switch_() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitPathData.Switch)
  return _internal_switch_();
}
inline void CircuitPathData::_internal_set_switch_(::pulse::cdm::bind::eGate value) {
  
  switch__ = value;
}
inline void CircuitPathData::set_switch_(::pulse::cdm::bind::eGate value) {
  _internal_set_switch_(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitPathData.Switch)
}

// .pulse.cdm.bind.eGate NextSwitch = 5;
inline void CircuitPathData::clear_nextswitch() {
  nextswitch_ = 0;
}
inline ::pulse::cdm::bind::eGate CircuitPathData::_internal_nextswitch() const {
  return static_cast< ::pulse::cdm::bind::eGate >(nextswitch_);
}
inline ::pulse::cdm::bind::eGate CircuitPathData::nextswitch() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitPathData.NextSwitch)
  return _internal_nextswitch();
}
inline void CircuitPathData::_internal_set_nextswitch(::pulse::cdm::bind::eGate value) {
  
  nextswitch_ = value;
}
inline void CircuitPathData::set_nextswitch(::pulse::cdm::bind::eGate value) {
  _internal_set_nextswitch(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitPathData.NextSwitch)
}

// .pulse.cdm.bind.eGate Valve = 6;
inline void CircuitPathData::clear_valve() {
  valve_ = 0;
}
inline ::pulse::cdm::bind::eGate CircuitPathData::_internal_valve() const {
  return static_cast< ::pulse::cdm::bind::eGate >(valve_);
}
inline ::pulse::cdm::bind::eGate CircuitPathData::valve() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitPathData.Valve)
  return _internal_valve();
}
inline void CircuitPathData::_internal_set_valve(::pulse::cdm::bind::eGate value) {
  
  valve_ = value;
}
inline void CircuitPathData::set_valve(::pulse::cdm::bind::eGate value) {
  _internal_set_valve(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitPathData.Valve)
}

// .pulse.cdm.bind.eGate NextValve = 7;
inline void CircuitPathData::clear_nextvalve() {
  nextvalve_ = 0;
}
inline ::pulse::cdm::bind::eGate CircuitPathData::_internal_nextvalve() const {
  return static_cast< ::pulse::cdm::bind::eGate >(nextvalve_);
}
inline ::pulse::cdm::bind::eGate CircuitPathData::nextvalve() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitPathData.NextValve)
  return _internal_nextvalve();
}
inline void CircuitPathData::_internal_set_nextvalve(::pulse::cdm::bind::eGate value) {
  
  nextvalve_ = value;
}
inline void CircuitPathData::set_nextvalve(::pulse::cdm::bind::eGate value) {
  _internal_set_nextvalve(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitPathData.NextValve)
}

// .pulse.cdm.bind.eGate PolarizedState = 8;
inline void CircuitPathData::clear_polarizedstate() {
  polarizedstate_ = 0;
}
inline ::pulse::cdm::bind::eGate CircuitPathData::_internal_polarizedstate() const {
  return static_cast< ::pulse::cdm::bind::eGate >(polarizedstate_);
}
inline ::pulse::cdm::bind::eGate CircuitPathData::polarizedstate() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitPathData.PolarizedState)
  return _internal_polarizedstate();
}
inline void CircuitPathData::_internal_set_polarizedstate(::pulse::cdm::bind::eGate value) {
  
  polarizedstate_ = value;
}
inline void CircuitPathData::set_polarizedstate(::pulse::cdm::bind::eGate value) {
  _internal_set_polarizedstate(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitPathData.PolarizedState)
}

// .pulse.cdm.bind.eGate NextPolarizedState = 9;
inline void CircuitPathData::clear_nextpolarizedstate() {
  nextpolarizedstate_ = 0;
}
inline ::pulse::cdm::bind::eGate CircuitPathData::_internal_nextpolarizedstate() const {
  return static_cast< ::pulse::cdm::bind::eGate >(nextpolarizedstate_);
}
inline ::pulse::cdm::bind::eGate CircuitPathData::nextpolarizedstate() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitPathData.NextPolarizedState)
  return _internal_nextpolarizedstate();
}
inline void CircuitPathData::_internal_set_nextpolarizedstate(::pulse::cdm::bind::eGate value) {
  
  nextpolarizedstate_ = value;
}
inline void CircuitPathData::set_nextpolarizedstate(::pulse::cdm::bind::eGate value) {
  _internal_set_nextpolarizedstate(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.CircuitPathData.NextPolarizedState)
}

// -------------------------------------------------------------------

// ElectricalCircuitData

// .pulse.cdm.bind.CircuitData Circuit = 1;
inline bool ElectricalCircuitData::_internal_has_circuit() const {
  return this != internal_default_instance() && circuit_ != nullptr;
}
inline bool ElectricalCircuitData::has_circuit() const {
  return _internal_has_circuit();
}
inline void ElectricalCircuitData::clear_circuit() {
  if (GetArena() == nullptr && circuit_ != nullptr) {
    delete circuit_;
  }
  circuit_ = nullptr;
}
inline const ::pulse::cdm::bind::CircuitData& ElectricalCircuitData::_internal_circuit() const {
  const ::pulse::cdm::bind::CircuitData* p = circuit_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::CircuitData&>(
      ::pulse::cdm::bind::_CircuitData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitData& ElectricalCircuitData::circuit() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitData.Circuit)
  return _internal_circuit();
}
inline void ElectricalCircuitData::unsafe_arena_set_allocated_circuit(
    ::pulse::cdm::bind::CircuitData* circuit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuit_);
  }
  circuit_ = circuit;
  if (circuit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitData.Circuit)
}
inline ::pulse::cdm::bind::CircuitData* ElectricalCircuitData::release_circuit() {
  
  ::pulse::cdm::bind::CircuitData* temp = circuit_;
  circuit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::CircuitData* ElectricalCircuitData::unsafe_arena_release_circuit() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitData.Circuit)
  
  ::pulse::cdm::bind::CircuitData* temp = circuit_;
  circuit_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitData* ElectricalCircuitData::_internal_mutable_circuit() {
  
  if (circuit_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitData>(GetArena());
    circuit_ = p;
  }
  return circuit_;
}
inline ::pulse::cdm::bind::CircuitData* ElectricalCircuitData::mutable_circuit() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitData.Circuit)
  return _internal_mutable_circuit();
}
inline void ElectricalCircuitData::set_allocated_circuit(::pulse::cdm::bind::CircuitData* circuit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuit_;
  }
  if (circuit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuit);
    if (message_arena != submessage_arena) {
      circuit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuit, submessage_arena);
    }
    
  } else {
    
  }
  circuit_ = circuit;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitData.Circuit)
}

// -------------------------------------------------------------------

// ElectricalCircuitNodeData

// .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
inline bool ElectricalCircuitNodeData::_internal_has_circuitnode() const {
  return this != internal_default_instance() && circuitnode_ != nullptr;
}
inline bool ElectricalCircuitNodeData::has_circuitnode() const {
  return _internal_has_circuitnode();
}
inline void ElectricalCircuitNodeData::clear_circuitnode() {
  if (GetArena() == nullptr && circuitnode_ != nullptr) {
    delete circuitnode_;
  }
  circuitnode_ = nullptr;
}
inline const ::pulse::cdm::bind::CircuitNodeData& ElectricalCircuitNodeData::_internal_circuitnode() const {
  const ::pulse::cdm::bind::CircuitNodeData* p = circuitnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::CircuitNodeData&>(
      ::pulse::cdm::bind::_CircuitNodeData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitNodeData& ElectricalCircuitNodeData::circuitnode() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitNodeData.CircuitNode)
  return _internal_circuitnode();
}
inline void ElectricalCircuitNodeData::unsafe_arena_set_allocated_circuitnode(
    ::pulse::cdm::bind::CircuitNodeData* circuitnode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitnode_);
  }
  circuitnode_ = circuitnode;
  if (circuitnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.CircuitNode)
}
inline ::pulse::cdm::bind::CircuitNodeData* ElectricalCircuitNodeData::release_circuitnode() {
  
  ::pulse::cdm::bind::CircuitNodeData* temp = circuitnode_;
  circuitnode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::CircuitNodeData* ElectricalCircuitNodeData::unsafe_arena_release_circuitnode() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitNodeData.CircuitNode)
  
  ::pulse::cdm::bind::CircuitNodeData* temp = circuitnode_;
  circuitnode_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitNodeData* ElectricalCircuitNodeData::_internal_mutable_circuitnode() {
  
  if (circuitnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitNodeData>(GetArena());
    circuitnode_ = p;
  }
  return circuitnode_;
}
inline ::pulse::cdm::bind::CircuitNodeData* ElectricalCircuitNodeData::mutable_circuitnode() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitNodeData.CircuitNode)
  return _internal_mutable_circuitnode();
}
inline void ElectricalCircuitNodeData::set_allocated_circuitnode(::pulse::cdm::bind::CircuitNodeData* circuitnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitnode_;
  }
  if (circuitnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitnode);
    if (message_arena != submessage_arena) {
      circuitnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitnode, submessage_arena);
    }
    
  } else {
    
  }
  circuitnode_ = circuitnode;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.CircuitNode)
}

// .pulse.cdm.bind.ScalarElectricPotentialData Voltage = 2;
inline bool ElectricalCircuitNodeData::_internal_has_voltage() const {
  return this != internal_default_instance() && voltage_ != nullptr;
}
inline bool ElectricalCircuitNodeData::has_voltage() const {
  return _internal_has_voltage();
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitNodeData::_internal_voltage() const {
  const ::pulse::cdm::bind::ScalarElectricPotentialData* p = voltage_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricPotentialData&>(
      ::pulse::cdm::bind::_ScalarElectricPotentialData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitNodeData::voltage() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitNodeData.Voltage)
  return _internal_voltage();
}
inline void ElectricalCircuitNodeData::unsafe_arena_set_allocated_voltage(
    ::pulse::cdm::bind::ScalarElectricPotentialData* voltage) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltage_);
  }
  voltage_ = voltage;
  if (voltage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.Voltage)
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitNodeData::release_voltage() {
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = voltage_;
  voltage_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitNodeData::unsafe_arena_release_voltage() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitNodeData.Voltage)
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = voltage_;
  voltage_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitNodeData::_internal_mutable_voltage() {
  
  if (voltage_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricPotentialData>(GetArena());
    voltage_ = p;
  }
  return voltage_;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitNodeData::mutable_voltage() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitNodeData.Voltage)
  return _internal_mutable_voltage();
}
inline void ElectricalCircuitNodeData::set_allocated_voltage(::pulse::cdm::bind::ScalarElectricPotentialData* voltage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltage_);
  }
  if (voltage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltage)->GetArena();
    if (message_arena != submessage_arena) {
      voltage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltage, submessage_arena);
    }
    
  } else {
    
  }
  voltage_ = voltage;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.Voltage)
}

// .pulse.cdm.bind.ScalarElectricPotentialData NextVoltage = 3;
inline bool ElectricalCircuitNodeData::_internal_has_nextvoltage() const {
  return this != internal_default_instance() && nextvoltage_ != nullptr;
}
inline bool ElectricalCircuitNodeData::has_nextvoltage() const {
  return _internal_has_nextvoltage();
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitNodeData::_internal_nextvoltage() const {
  const ::pulse::cdm::bind::ScalarElectricPotentialData* p = nextvoltage_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricPotentialData&>(
      ::pulse::cdm::bind::_ScalarElectricPotentialData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitNodeData::nextvoltage() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitNodeData.NextVoltage)
  return _internal_nextvoltage();
}
inline void ElectricalCircuitNodeData::unsafe_arena_set_allocated_nextvoltage(
    ::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltage) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextvoltage_);
  }
  nextvoltage_ = nextvoltage;
  if (nextvoltage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.NextVoltage)
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitNodeData::release_nextvoltage() {
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = nextvoltage_;
  nextvoltage_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitNodeData::unsafe_arena_release_nextvoltage() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitNodeData.NextVoltage)
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = nextvoltage_;
  nextvoltage_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitNodeData::_internal_mutable_nextvoltage() {
  
  if (nextvoltage_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricPotentialData>(GetArena());
    nextvoltage_ = p;
  }
  return nextvoltage_;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitNodeData::mutable_nextvoltage() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitNodeData.NextVoltage)
  return _internal_mutable_nextvoltage();
}
inline void ElectricalCircuitNodeData::set_allocated_nextvoltage(::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextvoltage_);
  }
  if (nextvoltage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextvoltage)->GetArena();
    if (message_arena != submessage_arena) {
      nextvoltage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextvoltage, submessage_arena);
    }
    
  } else {
    
  }
  nextvoltage_ = nextvoltage;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.NextVoltage)
}

// .pulse.cdm.bind.ScalarElectricChargeData Charge = 4;
inline bool ElectricalCircuitNodeData::_internal_has_charge() const {
  return this != internal_default_instance() && charge_ != nullptr;
}
inline bool ElectricalCircuitNodeData::has_charge() const {
  return _internal_has_charge();
}
inline const ::pulse::cdm::bind::ScalarElectricChargeData& ElectricalCircuitNodeData::_internal_charge() const {
  const ::pulse::cdm::bind::ScalarElectricChargeData* p = charge_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricChargeData&>(
      ::pulse::cdm::bind::_ScalarElectricChargeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricChargeData& ElectricalCircuitNodeData::charge() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitNodeData.Charge)
  return _internal_charge();
}
inline void ElectricalCircuitNodeData::unsafe_arena_set_allocated_charge(
    ::pulse::cdm::bind::ScalarElectricChargeData* charge) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(charge_);
  }
  charge_ = charge;
  if (charge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.Charge)
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::release_charge() {
  
  ::pulse::cdm::bind::ScalarElectricChargeData* temp = charge_;
  charge_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::unsafe_arena_release_charge() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitNodeData.Charge)
  
  ::pulse::cdm::bind::ScalarElectricChargeData* temp = charge_;
  charge_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::_internal_mutable_charge() {
  
  if (charge_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricChargeData>(GetArena());
    charge_ = p;
  }
  return charge_;
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::mutable_charge() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitNodeData.Charge)
  return _internal_mutable_charge();
}
inline void ElectricalCircuitNodeData::set_allocated_charge(::pulse::cdm::bind::ScalarElectricChargeData* charge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(charge_);
  }
  if (charge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(charge)->GetArena();
    if (message_arena != submessage_arena) {
      charge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, charge, submessage_arena);
    }
    
  } else {
    
  }
  charge_ = charge;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.Charge)
}

// .pulse.cdm.bind.ScalarElectricChargeData NextCharge = 5;
inline bool ElectricalCircuitNodeData::_internal_has_nextcharge() const {
  return this != internal_default_instance() && nextcharge_ != nullptr;
}
inline bool ElectricalCircuitNodeData::has_nextcharge() const {
  return _internal_has_nextcharge();
}
inline const ::pulse::cdm::bind::ScalarElectricChargeData& ElectricalCircuitNodeData::_internal_nextcharge() const {
  const ::pulse::cdm::bind::ScalarElectricChargeData* p = nextcharge_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricChargeData&>(
      ::pulse::cdm::bind::_ScalarElectricChargeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricChargeData& ElectricalCircuitNodeData::nextcharge() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitNodeData.NextCharge)
  return _internal_nextcharge();
}
inline void ElectricalCircuitNodeData::unsafe_arena_set_allocated_nextcharge(
    ::pulse::cdm::bind::ScalarElectricChargeData* nextcharge) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcharge_);
  }
  nextcharge_ = nextcharge;
  if (nextcharge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.NextCharge)
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::release_nextcharge() {
  
  ::pulse::cdm::bind::ScalarElectricChargeData* temp = nextcharge_;
  nextcharge_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::unsafe_arena_release_nextcharge() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitNodeData.NextCharge)
  
  ::pulse::cdm::bind::ScalarElectricChargeData* temp = nextcharge_;
  nextcharge_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::_internal_mutable_nextcharge() {
  
  if (nextcharge_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricChargeData>(GetArena());
    nextcharge_ = p;
  }
  return nextcharge_;
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::mutable_nextcharge() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitNodeData.NextCharge)
  return _internal_mutable_nextcharge();
}
inline void ElectricalCircuitNodeData::set_allocated_nextcharge(::pulse::cdm::bind::ScalarElectricChargeData* nextcharge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcharge_);
  }
  if (nextcharge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcharge)->GetArena();
    if (message_arena != submessage_arena) {
      nextcharge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextcharge, submessage_arena);
    }
    
  } else {
    
  }
  nextcharge_ = nextcharge;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.NextCharge)
}

// .pulse.cdm.bind.ScalarElectricChargeData ChargeBaseline = 6;
inline bool ElectricalCircuitNodeData::_internal_has_chargebaseline() const {
  return this != internal_default_instance() && chargebaseline_ != nullptr;
}
inline bool ElectricalCircuitNodeData::has_chargebaseline() const {
  return _internal_has_chargebaseline();
}
inline const ::pulse::cdm::bind::ScalarElectricChargeData& ElectricalCircuitNodeData::_internal_chargebaseline() const {
  const ::pulse::cdm::bind::ScalarElectricChargeData* p = chargebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricChargeData&>(
      ::pulse::cdm::bind::_ScalarElectricChargeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricChargeData& ElectricalCircuitNodeData::chargebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitNodeData.ChargeBaseline)
  return _internal_chargebaseline();
}
inline void ElectricalCircuitNodeData::unsafe_arena_set_allocated_chargebaseline(
    ::pulse::cdm::bind::ScalarElectricChargeData* chargebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chargebaseline_);
  }
  chargebaseline_ = chargebaseline;
  if (chargebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.ChargeBaseline)
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::release_chargebaseline() {
  
  ::pulse::cdm::bind::ScalarElectricChargeData* temp = chargebaseline_;
  chargebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::unsafe_arena_release_chargebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitNodeData.ChargeBaseline)
  
  ::pulse::cdm::bind::ScalarElectricChargeData* temp = chargebaseline_;
  chargebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::_internal_mutable_chargebaseline() {
  
  if (chargebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricChargeData>(GetArena());
    chargebaseline_ = p;
  }
  return chargebaseline_;
}
inline ::pulse::cdm::bind::ScalarElectricChargeData* ElectricalCircuitNodeData::mutable_chargebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitNodeData.ChargeBaseline)
  return _internal_mutable_chargebaseline();
}
inline void ElectricalCircuitNodeData::set_allocated_chargebaseline(::pulse::cdm::bind::ScalarElectricChargeData* chargebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(chargebaseline_);
  }
  if (chargebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chargebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      chargebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chargebaseline, submessage_arena);
    }
    
  } else {
    
  }
  chargebaseline_ = chargebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitNodeData.ChargeBaseline)
}

// -------------------------------------------------------------------

// ElectricalCircuitPathData

// .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
inline bool ElectricalCircuitPathData::_internal_has_circuitpath() const {
  return this != internal_default_instance() && circuitpath_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_circuitpath() const {
  return _internal_has_circuitpath();
}
inline void ElectricalCircuitPathData::clear_circuitpath() {
  if (GetArena() == nullptr && circuitpath_ != nullptr) {
    delete circuitpath_;
  }
  circuitpath_ = nullptr;
}
inline const ::pulse::cdm::bind::CircuitPathData& ElectricalCircuitPathData::_internal_circuitpath() const {
  const ::pulse::cdm::bind::CircuitPathData* p = circuitpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::CircuitPathData&>(
      ::pulse::cdm::bind::_CircuitPathData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitPathData& ElectricalCircuitPathData::circuitpath() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.CircuitPath)
  return _internal_circuitpath();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_circuitpath(
    ::pulse::cdm::bind::CircuitPathData* circuitpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitpath_);
  }
  circuitpath_ = circuitpath;
  if (circuitpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.CircuitPath)
}
inline ::pulse::cdm::bind::CircuitPathData* ElectricalCircuitPathData::release_circuitpath() {
  
  ::pulse::cdm::bind::CircuitPathData* temp = circuitpath_;
  circuitpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::CircuitPathData* ElectricalCircuitPathData::unsafe_arena_release_circuitpath() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.CircuitPath)
  
  ::pulse::cdm::bind::CircuitPathData* temp = circuitpath_;
  circuitpath_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitPathData* ElectricalCircuitPathData::_internal_mutable_circuitpath() {
  
  if (circuitpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitPathData>(GetArena());
    circuitpath_ = p;
  }
  return circuitpath_;
}
inline ::pulse::cdm::bind::CircuitPathData* ElectricalCircuitPathData::mutable_circuitpath() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.CircuitPath)
  return _internal_mutable_circuitpath();
}
inline void ElectricalCircuitPathData::set_allocated_circuitpath(::pulse::cdm::bind::CircuitPathData* circuitpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitpath_;
  }
  if (circuitpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitpath);
    if (message_arena != submessage_arena) {
      circuitpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitpath, submessage_arena);
    }
    
  } else {
    
  }
  circuitpath_ = circuitpath;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.CircuitPath)
}

// .pulse.cdm.bind.ScalarElectricResistanceData Resistance = 2;
inline bool ElectricalCircuitPathData::_internal_has_resistance() const {
  return this != internal_default_instance() && resistance_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_resistance() const {
  return _internal_has_resistance();
}
inline const ::pulse::cdm::bind::ScalarElectricResistanceData& ElectricalCircuitPathData::_internal_resistance() const {
  const ::pulse::cdm::bind::ScalarElectricResistanceData* p = resistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricResistanceData&>(
      ::pulse::cdm::bind::_ScalarElectricResistanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricResistanceData& ElectricalCircuitPathData::resistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.Resistance)
  return _internal_resistance();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_resistance(
    ::pulse::cdm::bind::ScalarElectricResistanceData* resistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistance_);
  }
  resistance_ = resistance;
  if (resistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.Resistance)
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::release_resistance() {
  
  ::pulse::cdm::bind::ScalarElectricResistanceData* temp = resistance_;
  resistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::unsafe_arena_release_resistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.Resistance)
  
  ::pulse::cdm::bind::ScalarElectricResistanceData* temp = resistance_;
  resistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::_internal_mutable_resistance() {
  
  if (resistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricResistanceData>(GetArena());
    resistance_ = p;
  }
  return resistance_;
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::mutable_resistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.Resistance)
  return _internal_mutable_resistance();
}
inline void ElectricalCircuitPathData::set_allocated_resistance(::pulse::cdm::bind::ScalarElectricResistanceData* resistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistance_);
  }
  if (resistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistance)->GetArena();
    if (message_arena != submessage_arena) {
      resistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resistance, submessage_arena);
    }
    
  } else {
    
  }
  resistance_ = resistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.Resistance)
}

// .pulse.cdm.bind.ScalarElectricResistanceData NextResistance = 3;
inline bool ElectricalCircuitPathData::_internal_has_nextresistance() const {
  return this != internal_default_instance() && nextresistance_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_nextresistance() const {
  return _internal_has_nextresistance();
}
inline const ::pulse::cdm::bind::ScalarElectricResistanceData& ElectricalCircuitPathData::_internal_nextresistance() const {
  const ::pulse::cdm::bind::ScalarElectricResistanceData* p = nextresistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricResistanceData&>(
      ::pulse::cdm::bind::_ScalarElectricResistanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricResistanceData& ElectricalCircuitPathData::nextresistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.NextResistance)
  return _internal_nextresistance();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_nextresistance(
    ::pulse::cdm::bind::ScalarElectricResistanceData* nextresistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextresistance_);
  }
  nextresistance_ = nextresistance;
  if (nextresistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextResistance)
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::release_nextresistance() {
  
  ::pulse::cdm::bind::ScalarElectricResistanceData* temp = nextresistance_;
  nextresistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::unsafe_arena_release_nextresistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.NextResistance)
  
  ::pulse::cdm::bind::ScalarElectricResistanceData* temp = nextresistance_;
  nextresistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::_internal_mutable_nextresistance() {
  
  if (nextresistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricResistanceData>(GetArena());
    nextresistance_ = p;
  }
  return nextresistance_;
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::mutable_nextresistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.NextResistance)
  return _internal_mutable_nextresistance();
}
inline void ElectricalCircuitPathData::set_allocated_nextresistance(::pulse::cdm::bind::ScalarElectricResistanceData* nextresistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextresistance_);
  }
  if (nextresistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextresistance)->GetArena();
    if (message_arena != submessage_arena) {
      nextresistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextresistance, submessage_arena);
    }
    
  } else {
    
  }
  nextresistance_ = nextresistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextResistance)
}

// .pulse.cdm.bind.ScalarElectricResistanceData ResistanceBaseline = 4;
inline bool ElectricalCircuitPathData::_internal_has_resistancebaseline() const {
  return this != internal_default_instance() && resistancebaseline_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_resistancebaseline() const {
  return _internal_has_resistancebaseline();
}
inline const ::pulse::cdm::bind::ScalarElectricResistanceData& ElectricalCircuitPathData::_internal_resistancebaseline() const {
  const ::pulse::cdm::bind::ScalarElectricResistanceData* p = resistancebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricResistanceData&>(
      ::pulse::cdm::bind::_ScalarElectricResistanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricResistanceData& ElectricalCircuitPathData::resistancebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.ResistanceBaseline)
  return _internal_resistancebaseline();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_resistancebaseline(
    ::pulse::cdm::bind::ScalarElectricResistanceData* resistancebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancebaseline_);
  }
  resistancebaseline_ = resistancebaseline;
  if (resistancebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.ResistanceBaseline)
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::release_resistancebaseline() {
  
  ::pulse::cdm::bind::ScalarElectricResistanceData* temp = resistancebaseline_;
  resistancebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::unsafe_arena_release_resistancebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.ResistanceBaseline)
  
  ::pulse::cdm::bind::ScalarElectricResistanceData* temp = resistancebaseline_;
  resistancebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::_internal_mutable_resistancebaseline() {
  
  if (resistancebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricResistanceData>(GetArena());
    resistancebaseline_ = p;
  }
  return resistancebaseline_;
}
inline ::pulse::cdm::bind::ScalarElectricResistanceData* ElectricalCircuitPathData::mutable_resistancebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.ResistanceBaseline)
  return _internal_mutable_resistancebaseline();
}
inline void ElectricalCircuitPathData::set_allocated_resistancebaseline(::pulse::cdm::bind::ScalarElectricResistanceData* resistancebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancebaseline_);
  }
  if (resistancebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      resistancebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resistancebaseline, submessage_arena);
    }
    
  } else {
    
  }
  resistancebaseline_ = resistancebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.ResistanceBaseline)
}

// .pulse.cdm.bind.ScalarElectricCapacitanceData Capacitance = 5;
inline bool ElectricalCircuitPathData::_internal_has_capacitance() const {
  return this != internal_default_instance() && capacitance_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_capacitance() const {
  return _internal_has_capacitance();
}
inline const ::pulse::cdm::bind::ScalarElectricCapacitanceData& ElectricalCircuitPathData::_internal_capacitance() const {
  const ::pulse::cdm::bind::ScalarElectricCapacitanceData* p = capacitance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricCapacitanceData&>(
      ::pulse::cdm::bind::_ScalarElectricCapacitanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricCapacitanceData& ElectricalCircuitPathData::capacitance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.Capacitance)
  return _internal_capacitance();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_capacitance(
    ::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitance_);
  }
  capacitance_ = capacitance;
  if (capacitance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.Capacitance)
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::release_capacitance() {
  
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* temp = capacitance_;
  capacitance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::unsafe_arena_release_capacitance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.Capacitance)
  
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* temp = capacitance_;
  capacitance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::_internal_mutable_capacitance() {
  
  if (capacitance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricCapacitanceData>(GetArena());
    capacitance_ = p;
  }
  return capacitance_;
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::mutable_capacitance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.Capacitance)
  return _internal_mutable_capacitance();
}
inline void ElectricalCircuitPathData::set_allocated_capacitance(::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitance_);
  }
  if (capacitance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitance)->GetArena();
    if (message_arena != submessage_arena) {
      capacitance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capacitance, submessage_arena);
    }
    
  } else {
    
  }
  capacitance_ = capacitance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.Capacitance)
}

// .pulse.cdm.bind.ScalarElectricCapacitanceData NextCapacitance = 6;
inline bool ElectricalCircuitPathData::_internal_has_nextcapacitance() const {
  return this != internal_default_instance() && nextcapacitance_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_nextcapacitance() const {
  return _internal_has_nextcapacitance();
}
inline const ::pulse::cdm::bind::ScalarElectricCapacitanceData& ElectricalCircuitPathData::_internal_nextcapacitance() const {
  const ::pulse::cdm::bind::ScalarElectricCapacitanceData* p = nextcapacitance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricCapacitanceData&>(
      ::pulse::cdm::bind::_ScalarElectricCapacitanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricCapacitanceData& ElectricalCircuitPathData::nextcapacitance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.NextCapacitance)
  return _internal_nextcapacitance();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_nextcapacitance(
    ::pulse::cdm::bind::ScalarElectricCapacitanceData* nextcapacitance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcapacitance_);
  }
  nextcapacitance_ = nextcapacitance;
  if (nextcapacitance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextCapacitance)
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::release_nextcapacitance() {
  
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* temp = nextcapacitance_;
  nextcapacitance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::unsafe_arena_release_nextcapacitance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.NextCapacitance)
  
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* temp = nextcapacitance_;
  nextcapacitance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::_internal_mutable_nextcapacitance() {
  
  if (nextcapacitance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricCapacitanceData>(GetArena());
    nextcapacitance_ = p;
  }
  return nextcapacitance_;
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::mutable_nextcapacitance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.NextCapacitance)
  return _internal_mutable_nextcapacitance();
}
inline void ElectricalCircuitPathData::set_allocated_nextcapacitance(::pulse::cdm::bind::ScalarElectricCapacitanceData* nextcapacitance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcapacitance_);
  }
  if (nextcapacitance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcapacitance)->GetArena();
    if (message_arena != submessage_arena) {
      nextcapacitance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextcapacitance, submessage_arena);
    }
    
  } else {
    
  }
  nextcapacitance_ = nextcapacitance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextCapacitance)
}

// .pulse.cdm.bind.ScalarElectricCapacitanceData CapacitanceBaseline = 7;
inline bool ElectricalCircuitPathData::_internal_has_capacitancebaseline() const {
  return this != internal_default_instance() && capacitancebaseline_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_capacitancebaseline() const {
  return _internal_has_capacitancebaseline();
}
inline const ::pulse::cdm::bind::ScalarElectricCapacitanceData& ElectricalCircuitPathData::_internal_capacitancebaseline() const {
  const ::pulse::cdm::bind::ScalarElectricCapacitanceData* p = capacitancebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricCapacitanceData&>(
      ::pulse::cdm::bind::_ScalarElectricCapacitanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricCapacitanceData& ElectricalCircuitPathData::capacitancebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.CapacitanceBaseline)
  return _internal_capacitancebaseline();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_capacitancebaseline(
    ::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitancebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitancebaseline_);
  }
  capacitancebaseline_ = capacitancebaseline;
  if (capacitancebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.CapacitanceBaseline)
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::release_capacitancebaseline() {
  
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* temp = capacitancebaseline_;
  capacitancebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::unsafe_arena_release_capacitancebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.CapacitanceBaseline)
  
  ::pulse::cdm::bind::ScalarElectricCapacitanceData* temp = capacitancebaseline_;
  capacitancebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::_internal_mutable_capacitancebaseline() {
  
  if (capacitancebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricCapacitanceData>(GetArena());
    capacitancebaseline_ = p;
  }
  return capacitancebaseline_;
}
inline ::pulse::cdm::bind::ScalarElectricCapacitanceData* ElectricalCircuitPathData::mutable_capacitancebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.CapacitanceBaseline)
  return _internal_mutable_capacitancebaseline();
}
inline void ElectricalCircuitPathData::set_allocated_capacitancebaseline(::pulse::cdm::bind::ScalarElectricCapacitanceData* capacitancebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitancebaseline_);
  }
  if (capacitancebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitancebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      capacitancebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capacitancebaseline, submessage_arena);
    }
    
  } else {
    
  }
  capacitancebaseline_ = capacitancebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.CapacitanceBaseline)
}

// .pulse.cdm.bind.ScalarElectricInductanceData Inductance = 8;
inline bool ElectricalCircuitPathData::_internal_has_inductance() const {
  return this != internal_default_instance() && inductance_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_inductance() const {
  return _internal_has_inductance();
}
inline const ::pulse::cdm::bind::ScalarElectricInductanceData& ElectricalCircuitPathData::_internal_inductance() const {
  const ::pulse::cdm::bind::ScalarElectricInductanceData* p = inductance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricInductanceData&>(
      ::pulse::cdm::bind::_ScalarElectricInductanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricInductanceData& ElectricalCircuitPathData::inductance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.Inductance)
  return _internal_inductance();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_inductance(
    ::pulse::cdm::bind::ScalarElectricInductanceData* inductance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductance_);
  }
  inductance_ = inductance;
  if (inductance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.Inductance)
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::release_inductance() {
  
  ::pulse::cdm::bind::ScalarElectricInductanceData* temp = inductance_;
  inductance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::unsafe_arena_release_inductance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.Inductance)
  
  ::pulse::cdm::bind::ScalarElectricInductanceData* temp = inductance_;
  inductance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::_internal_mutable_inductance() {
  
  if (inductance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricInductanceData>(GetArena());
    inductance_ = p;
  }
  return inductance_;
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::mutable_inductance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.Inductance)
  return _internal_mutable_inductance();
}
inline void ElectricalCircuitPathData::set_allocated_inductance(::pulse::cdm::bind::ScalarElectricInductanceData* inductance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductance_);
  }
  if (inductance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductance)->GetArena();
    if (message_arena != submessage_arena) {
      inductance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inductance, submessage_arena);
    }
    
  } else {
    
  }
  inductance_ = inductance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.Inductance)
}

// .pulse.cdm.bind.ScalarElectricInductanceData NextInductance = 9;
inline bool ElectricalCircuitPathData::_internal_has_nextinductance() const {
  return this != internal_default_instance() && nextinductance_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_nextinductance() const {
  return _internal_has_nextinductance();
}
inline const ::pulse::cdm::bind::ScalarElectricInductanceData& ElectricalCircuitPathData::_internal_nextinductance() const {
  const ::pulse::cdm::bind::ScalarElectricInductanceData* p = nextinductance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricInductanceData&>(
      ::pulse::cdm::bind::_ScalarElectricInductanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricInductanceData& ElectricalCircuitPathData::nextinductance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.NextInductance)
  return _internal_nextinductance();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_nextinductance(
    ::pulse::cdm::bind::ScalarElectricInductanceData* nextinductance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextinductance_);
  }
  nextinductance_ = nextinductance;
  if (nextinductance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextInductance)
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::release_nextinductance() {
  
  ::pulse::cdm::bind::ScalarElectricInductanceData* temp = nextinductance_;
  nextinductance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::unsafe_arena_release_nextinductance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.NextInductance)
  
  ::pulse::cdm::bind::ScalarElectricInductanceData* temp = nextinductance_;
  nextinductance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::_internal_mutable_nextinductance() {
  
  if (nextinductance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricInductanceData>(GetArena());
    nextinductance_ = p;
  }
  return nextinductance_;
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::mutable_nextinductance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.NextInductance)
  return _internal_mutable_nextinductance();
}
inline void ElectricalCircuitPathData::set_allocated_nextinductance(::pulse::cdm::bind::ScalarElectricInductanceData* nextinductance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextinductance_);
  }
  if (nextinductance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextinductance)->GetArena();
    if (message_arena != submessage_arena) {
      nextinductance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextinductance, submessage_arena);
    }
    
  } else {
    
  }
  nextinductance_ = nextinductance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextInductance)
}

// .pulse.cdm.bind.ScalarElectricInductanceData InductanceBaseline = 10;
inline bool ElectricalCircuitPathData::_internal_has_inductancebaseline() const {
  return this != internal_default_instance() && inductancebaseline_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_inductancebaseline() const {
  return _internal_has_inductancebaseline();
}
inline const ::pulse::cdm::bind::ScalarElectricInductanceData& ElectricalCircuitPathData::_internal_inductancebaseline() const {
  const ::pulse::cdm::bind::ScalarElectricInductanceData* p = inductancebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricInductanceData&>(
      ::pulse::cdm::bind::_ScalarElectricInductanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricInductanceData& ElectricalCircuitPathData::inductancebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.InductanceBaseline)
  return _internal_inductancebaseline();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_inductancebaseline(
    ::pulse::cdm::bind::ScalarElectricInductanceData* inductancebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductancebaseline_);
  }
  inductancebaseline_ = inductancebaseline;
  if (inductancebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.InductanceBaseline)
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::release_inductancebaseline() {
  
  ::pulse::cdm::bind::ScalarElectricInductanceData* temp = inductancebaseline_;
  inductancebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::unsafe_arena_release_inductancebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.InductanceBaseline)
  
  ::pulse::cdm::bind::ScalarElectricInductanceData* temp = inductancebaseline_;
  inductancebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::_internal_mutable_inductancebaseline() {
  
  if (inductancebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricInductanceData>(GetArena());
    inductancebaseline_ = p;
  }
  return inductancebaseline_;
}
inline ::pulse::cdm::bind::ScalarElectricInductanceData* ElectricalCircuitPathData::mutable_inductancebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.InductanceBaseline)
  return _internal_mutable_inductancebaseline();
}
inline void ElectricalCircuitPathData::set_allocated_inductancebaseline(::pulse::cdm::bind::ScalarElectricInductanceData* inductancebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductancebaseline_);
  }
  if (inductancebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductancebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      inductancebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inductancebaseline, submessage_arena);
    }
    
  } else {
    
  }
  inductancebaseline_ = inductancebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.InductanceBaseline)
}

// .pulse.cdm.bind.ScalarElectricCurrentData Current = 11;
inline bool ElectricalCircuitPathData::_internal_has_current() const {
  return this != internal_default_instance() && current_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_current() const {
  return _internal_has_current();
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::_internal_current() const {
  const ::pulse::cdm::bind::ScalarElectricCurrentData* p = current_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricCurrentData&>(
      ::pulse::cdm::bind::_ScalarElectricCurrentData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::current() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.Current)
  return _internal_current();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_current(
    ::pulse::cdm::bind::ScalarElectricCurrentData* current) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_);
  }
  current_ = current;
  if (current) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.Current)
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::release_current() {
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = current_;
  current_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::unsafe_arena_release_current() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.Current)
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = current_;
  current_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::_internal_mutable_current() {
  
  if (current_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricCurrentData>(GetArena());
    current_ = p;
  }
  return current_;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::mutable_current() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.Current)
  return _internal_mutable_current();
}
inline void ElectricalCircuitPathData::set_allocated_current(::pulse::cdm::bind::ScalarElectricCurrentData* current) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_);
  }
  if (current) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current)->GetArena();
    if (message_arena != submessage_arena) {
      current = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current, submessage_arena);
    }
    
  } else {
    
  }
  current_ = current;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.Current)
}

// .pulse.cdm.bind.ScalarElectricCurrentData NextCurrent = 12;
inline bool ElectricalCircuitPathData::_internal_has_nextcurrent() const {
  return this != internal_default_instance() && nextcurrent_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_nextcurrent() const {
  return _internal_has_nextcurrent();
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::_internal_nextcurrent() const {
  const ::pulse::cdm::bind::ScalarElectricCurrentData* p = nextcurrent_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricCurrentData&>(
      ::pulse::cdm::bind::_ScalarElectricCurrentData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::nextcurrent() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrent)
  return _internal_nextcurrent();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_nextcurrent(
    ::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcurrent_);
  }
  nextcurrent_ = nextcurrent;
  if (nextcurrent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrent)
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::release_nextcurrent() {
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = nextcurrent_;
  nextcurrent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::unsafe_arena_release_nextcurrent() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrent)
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = nextcurrent_;
  nextcurrent_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::_internal_mutable_nextcurrent() {
  
  if (nextcurrent_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricCurrentData>(GetArena());
    nextcurrent_ = p;
  }
  return nextcurrent_;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::mutable_nextcurrent() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrent)
  return _internal_mutable_nextcurrent();
}
inline void ElectricalCircuitPathData::set_allocated_nextcurrent(::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcurrent_);
  }
  if (nextcurrent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcurrent)->GetArena();
    if (message_arena != submessage_arena) {
      nextcurrent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextcurrent, submessage_arena);
    }
    
  } else {
    
  }
  nextcurrent_ = nextcurrent;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrent)
}

// .pulse.cdm.bind.ScalarElectricCurrentData CurrentSource = 13;
inline bool ElectricalCircuitPathData::_internal_has_currentsource() const {
  return this != internal_default_instance() && currentsource_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_currentsource() const {
  return _internal_has_currentsource();
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::_internal_currentsource() const {
  const ::pulse::cdm::bind::ScalarElectricCurrentData* p = currentsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricCurrentData&>(
      ::pulse::cdm::bind::_ScalarElectricCurrentData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::currentsource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSource)
  return _internal_currentsource();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_currentsource(
    ::pulse::cdm::bind::ScalarElectricCurrentData* currentsource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(currentsource_);
  }
  currentsource_ = currentsource;
  if (currentsource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSource)
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::release_currentsource() {
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = currentsource_;
  currentsource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::unsafe_arena_release_currentsource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSource)
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = currentsource_;
  currentsource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::_internal_mutable_currentsource() {
  
  if (currentsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricCurrentData>(GetArena());
    currentsource_ = p;
  }
  return currentsource_;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::mutable_currentsource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSource)
  return _internal_mutable_currentsource();
}
inline void ElectricalCircuitPathData::set_allocated_currentsource(::pulse::cdm::bind::ScalarElectricCurrentData* currentsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(currentsource_);
  }
  if (currentsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(currentsource)->GetArena();
    if (message_arena != submessage_arena) {
      currentsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentsource, submessage_arena);
    }
    
  } else {
    
  }
  currentsource_ = currentsource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSource)
}

// .pulse.cdm.bind.ScalarElectricCurrentData NextCurrentSource = 14;
inline bool ElectricalCircuitPathData::_internal_has_nextcurrentsource() const {
  return this != internal_default_instance() && nextcurrentsource_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_nextcurrentsource() const {
  return _internal_has_nextcurrentsource();
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::_internal_nextcurrentsource() const {
  const ::pulse::cdm::bind::ScalarElectricCurrentData* p = nextcurrentsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricCurrentData&>(
      ::pulse::cdm::bind::_ScalarElectricCurrentData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::nextcurrentsource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrentSource)
  return _internal_nextcurrentsource();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_nextcurrentsource(
    ::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrentsource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcurrentsource_);
  }
  nextcurrentsource_ = nextcurrentsource;
  if (nextcurrentsource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrentSource)
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::release_nextcurrentsource() {
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = nextcurrentsource_;
  nextcurrentsource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::unsafe_arena_release_nextcurrentsource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrentSource)
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = nextcurrentsource_;
  nextcurrentsource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::_internal_mutable_nextcurrentsource() {
  
  if (nextcurrentsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricCurrentData>(GetArena());
    nextcurrentsource_ = p;
  }
  return nextcurrentsource_;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::mutable_nextcurrentsource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrentSource)
  return _internal_mutable_nextcurrentsource();
}
inline void ElectricalCircuitPathData::set_allocated_nextcurrentsource(::pulse::cdm::bind::ScalarElectricCurrentData* nextcurrentsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcurrentsource_);
  }
  if (nextcurrentsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcurrentsource)->GetArena();
    if (message_arena != submessage_arena) {
      nextcurrentsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextcurrentsource, submessage_arena);
    }
    
  } else {
    
  }
  nextcurrentsource_ = nextcurrentsource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextCurrentSource)
}

// .pulse.cdm.bind.ScalarElectricCurrentData CurrentSourceBaseline = 15;
inline bool ElectricalCircuitPathData::_internal_has_currentsourcebaseline() const {
  return this != internal_default_instance() && currentsourcebaseline_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_currentsourcebaseline() const {
  return _internal_has_currentsourcebaseline();
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::_internal_currentsourcebaseline() const {
  const ::pulse::cdm::bind::ScalarElectricCurrentData* p = currentsourcebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricCurrentData&>(
      ::pulse::cdm::bind::_ScalarElectricCurrentData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricCurrentData& ElectricalCircuitPathData::currentsourcebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSourceBaseline)
  return _internal_currentsourcebaseline();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_currentsourcebaseline(
    ::pulse::cdm::bind::ScalarElectricCurrentData* currentsourcebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(currentsourcebaseline_);
  }
  currentsourcebaseline_ = currentsourcebaseline;
  if (currentsourcebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSourceBaseline)
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::release_currentsourcebaseline() {
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = currentsourcebaseline_;
  currentsourcebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::unsafe_arena_release_currentsourcebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSourceBaseline)
  
  ::pulse::cdm::bind::ScalarElectricCurrentData* temp = currentsourcebaseline_;
  currentsourcebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::_internal_mutable_currentsourcebaseline() {
  
  if (currentsourcebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricCurrentData>(GetArena());
    currentsourcebaseline_ = p;
  }
  return currentsourcebaseline_;
}
inline ::pulse::cdm::bind::ScalarElectricCurrentData* ElectricalCircuitPathData::mutable_currentsourcebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSourceBaseline)
  return _internal_mutable_currentsourcebaseline();
}
inline void ElectricalCircuitPathData::set_allocated_currentsourcebaseline(::pulse::cdm::bind::ScalarElectricCurrentData* currentsourcebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(currentsourcebaseline_);
  }
  if (currentsourcebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(currentsourcebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      currentsourcebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentsourcebaseline, submessage_arena);
    }
    
  } else {
    
  }
  currentsourcebaseline_ = currentsourcebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.CurrentSourceBaseline)
}

// .pulse.cdm.bind.ScalarElectricPotentialData VoltageSource = 16;
inline bool ElectricalCircuitPathData::_internal_has_voltagesource() const {
  return this != internal_default_instance() && voltagesource_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_voltagesource() const {
  return _internal_has_voltagesource();
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitPathData::_internal_voltagesource() const {
  const ::pulse::cdm::bind::ScalarElectricPotentialData* p = voltagesource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricPotentialData&>(
      ::pulse::cdm::bind::_ScalarElectricPotentialData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitPathData::voltagesource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSource)
  return _internal_voltagesource();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_voltagesource(
    ::pulse::cdm::bind::ScalarElectricPotentialData* voltagesource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesource_);
  }
  voltagesource_ = voltagesource;
  if (voltagesource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSource)
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::release_voltagesource() {
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = voltagesource_;
  voltagesource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::unsafe_arena_release_voltagesource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSource)
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = voltagesource_;
  voltagesource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::_internal_mutable_voltagesource() {
  
  if (voltagesource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricPotentialData>(GetArena());
    voltagesource_ = p;
  }
  return voltagesource_;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::mutable_voltagesource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSource)
  return _internal_mutable_voltagesource();
}
inline void ElectricalCircuitPathData::set_allocated_voltagesource(::pulse::cdm::bind::ScalarElectricPotentialData* voltagesource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesource_);
  }
  if (voltagesource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesource)->GetArena();
    if (message_arena != submessage_arena) {
      voltagesource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagesource, submessage_arena);
    }
    
  } else {
    
  }
  voltagesource_ = voltagesource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSource)
}

// .pulse.cdm.bind.ScalarElectricPotentialData NextVoltageSource = 17;
inline bool ElectricalCircuitPathData::_internal_has_nextvoltagesource() const {
  return this != internal_default_instance() && nextvoltagesource_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_nextvoltagesource() const {
  return _internal_has_nextvoltagesource();
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitPathData::_internal_nextvoltagesource() const {
  const ::pulse::cdm::bind::ScalarElectricPotentialData* p = nextvoltagesource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricPotentialData&>(
      ::pulse::cdm::bind::_ScalarElectricPotentialData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitPathData::nextvoltagesource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.NextVoltageSource)
  return _internal_nextvoltagesource();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_nextvoltagesource(
    ::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltagesource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextvoltagesource_);
  }
  nextvoltagesource_ = nextvoltagesource;
  if (nextvoltagesource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextVoltageSource)
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::release_nextvoltagesource() {
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = nextvoltagesource_;
  nextvoltagesource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::unsafe_arena_release_nextvoltagesource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.NextVoltageSource)
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = nextvoltagesource_;
  nextvoltagesource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::_internal_mutable_nextvoltagesource() {
  
  if (nextvoltagesource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricPotentialData>(GetArena());
    nextvoltagesource_ = p;
  }
  return nextvoltagesource_;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::mutable_nextvoltagesource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.NextVoltageSource)
  return _internal_mutable_nextvoltagesource();
}
inline void ElectricalCircuitPathData::set_allocated_nextvoltagesource(::pulse::cdm::bind::ScalarElectricPotentialData* nextvoltagesource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextvoltagesource_);
  }
  if (nextvoltagesource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextvoltagesource)->GetArena();
    if (message_arena != submessage_arena) {
      nextvoltagesource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextvoltagesource, submessage_arena);
    }
    
  } else {
    
  }
  nextvoltagesource_ = nextvoltagesource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.NextVoltageSource)
}

// .pulse.cdm.bind.ScalarElectricPotentialData VoltageSourceBaseline = 18;
inline bool ElectricalCircuitPathData::_internal_has_voltagesourcebaseline() const {
  return this != internal_default_instance() && voltagesourcebaseline_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_voltagesourcebaseline() const {
  return _internal_has_voltagesourcebaseline();
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitPathData::_internal_voltagesourcebaseline() const {
  const ::pulse::cdm::bind::ScalarElectricPotentialData* p = voltagesourcebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricPotentialData&>(
      ::pulse::cdm::bind::_ScalarElectricPotentialData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitPathData::voltagesourcebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSourceBaseline)
  return _internal_voltagesourcebaseline();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_voltagesourcebaseline(
    ::pulse::cdm::bind::ScalarElectricPotentialData* voltagesourcebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesourcebaseline_);
  }
  voltagesourcebaseline_ = voltagesourcebaseline;
  if (voltagesourcebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSourceBaseline)
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::release_voltagesourcebaseline() {
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = voltagesourcebaseline_;
  voltagesourcebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::unsafe_arena_release_voltagesourcebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSourceBaseline)
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = voltagesourcebaseline_;
  voltagesourcebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::_internal_mutable_voltagesourcebaseline() {
  
  if (voltagesourcebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricPotentialData>(GetArena());
    voltagesourcebaseline_ = p;
  }
  return voltagesourcebaseline_;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::mutable_voltagesourcebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSourceBaseline)
  return _internal_mutable_voltagesourcebaseline();
}
inline void ElectricalCircuitPathData::set_allocated_voltagesourcebaseline(::pulse::cdm::bind::ScalarElectricPotentialData* voltagesourcebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesourcebaseline_);
  }
  if (voltagesourcebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltagesourcebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      voltagesourcebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltagesourcebaseline, submessage_arena);
    }
    
  } else {
    
  }
  voltagesourcebaseline_ = voltagesourcebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.VoltageSourceBaseline)
}

// .pulse.cdm.bind.ScalarElectricPotentialData ValveBreakdownVoltage = 19;
inline bool ElectricalCircuitPathData::_internal_has_valvebreakdownvoltage() const {
  return this != internal_default_instance() && valvebreakdownvoltage_ != nullptr;
}
inline bool ElectricalCircuitPathData::has_valvebreakdownvoltage() const {
  return _internal_has_valvebreakdownvoltage();
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitPathData::_internal_valvebreakdownvoltage() const {
  const ::pulse::cdm::bind::ScalarElectricPotentialData* p = valvebreakdownvoltage_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarElectricPotentialData&>(
      ::pulse::cdm::bind::_ScalarElectricPotentialData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarElectricPotentialData& ElectricalCircuitPathData::valvebreakdownvoltage() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ElectricalCircuitPathData.ValveBreakdownVoltage)
  return _internal_valvebreakdownvoltage();
}
inline void ElectricalCircuitPathData::unsafe_arena_set_allocated_valvebreakdownvoltage(
    ::pulse::cdm::bind::ScalarElectricPotentialData* valvebreakdownvoltage) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valvebreakdownvoltage_);
  }
  valvebreakdownvoltage_ = valvebreakdownvoltage;
  if (valvebreakdownvoltage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.ValveBreakdownVoltage)
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::release_valvebreakdownvoltage() {
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = valvebreakdownvoltage_;
  valvebreakdownvoltage_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::unsafe_arena_release_valvebreakdownvoltage() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ElectricalCircuitPathData.ValveBreakdownVoltage)
  
  ::pulse::cdm::bind::ScalarElectricPotentialData* temp = valvebreakdownvoltage_;
  valvebreakdownvoltage_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::_internal_mutable_valvebreakdownvoltage() {
  
  if (valvebreakdownvoltage_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarElectricPotentialData>(GetArena());
    valvebreakdownvoltage_ = p;
  }
  return valvebreakdownvoltage_;
}
inline ::pulse::cdm::bind::ScalarElectricPotentialData* ElectricalCircuitPathData::mutable_valvebreakdownvoltage() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ElectricalCircuitPathData.ValveBreakdownVoltage)
  return _internal_mutable_valvebreakdownvoltage();
}
inline void ElectricalCircuitPathData::set_allocated_valvebreakdownvoltage(::pulse::cdm::bind::ScalarElectricPotentialData* valvebreakdownvoltage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(valvebreakdownvoltage_);
  }
  if (valvebreakdownvoltage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valvebreakdownvoltage)->GetArena();
    if (message_arena != submessage_arena) {
      valvebreakdownvoltage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valvebreakdownvoltage, submessage_arena);
    }
    
  } else {
    
  }
  valvebreakdownvoltage_ = valvebreakdownvoltage;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ElectricalCircuitPathData.ValveBreakdownVoltage)
}

// -------------------------------------------------------------------

// FluidCircuitData

// .pulse.cdm.bind.CircuitData Circuit = 1;
inline bool FluidCircuitData::_internal_has_circuit() const {
  return this != internal_default_instance() && circuit_ != nullptr;
}
inline bool FluidCircuitData::has_circuit() const {
  return _internal_has_circuit();
}
inline void FluidCircuitData::clear_circuit() {
  if (GetArena() == nullptr && circuit_ != nullptr) {
    delete circuit_;
  }
  circuit_ = nullptr;
}
inline const ::pulse::cdm::bind::CircuitData& FluidCircuitData::_internal_circuit() const {
  const ::pulse::cdm::bind::CircuitData* p = circuit_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::CircuitData&>(
      ::pulse::cdm::bind::_CircuitData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitData& FluidCircuitData::circuit() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitData.Circuit)
  return _internal_circuit();
}
inline void FluidCircuitData::unsafe_arena_set_allocated_circuit(
    ::pulse::cdm::bind::CircuitData* circuit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuit_);
  }
  circuit_ = circuit;
  if (circuit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitData.Circuit)
}
inline ::pulse::cdm::bind::CircuitData* FluidCircuitData::release_circuit() {
  
  ::pulse::cdm::bind::CircuitData* temp = circuit_;
  circuit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::CircuitData* FluidCircuitData::unsafe_arena_release_circuit() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitData.Circuit)
  
  ::pulse::cdm::bind::CircuitData* temp = circuit_;
  circuit_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitData* FluidCircuitData::_internal_mutable_circuit() {
  
  if (circuit_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitData>(GetArena());
    circuit_ = p;
  }
  return circuit_;
}
inline ::pulse::cdm::bind::CircuitData* FluidCircuitData::mutable_circuit() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitData.Circuit)
  return _internal_mutable_circuit();
}
inline void FluidCircuitData::set_allocated_circuit(::pulse::cdm::bind::CircuitData* circuit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuit_;
  }
  if (circuit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuit);
    if (message_arena != submessage_arena) {
      circuit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuit, submessage_arena);
    }
    
  } else {
    
  }
  circuit_ = circuit;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitData.Circuit)
}

// -------------------------------------------------------------------

// FluidCircuitNodeData

// .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
inline bool FluidCircuitNodeData::_internal_has_circuitnode() const {
  return this != internal_default_instance() && circuitnode_ != nullptr;
}
inline bool FluidCircuitNodeData::has_circuitnode() const {
  return _internal_has_circuitnode();
}
inline void FluidCircuitNodeData::clear_circuitnode() {
  if (GetArena() == nullptr && circuitnode_ != nullptr) {
    delete circuitnode_;
  }
  circuitnode_ = nullptr;
}
inline const ::pulse::cdm::bind::CircuitNodeData& FluidCircuitNodeData::_internal_circuitnode() const {
  const ::pulse::cdm::bind::CircuitNodeData* p = circuitnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::CircuitNodeData&>(
      ::pulse::cdm::bind::_CircuitNodeData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitNodeData& FluidCircuitNodeData::circuitnode() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitNodeData.CircuitNode)
  return _internal_circuitnode();
}
inline void FluidCircuitNodeData::unsafe_arena_set_allocated_circuitnode(
    ::pulse::cdm::bind::CircuitNodeData* circuitnode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitnode_);
  }
  circuitnode_ = circuitnode;
  if (circuitnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.CircuitNode)
}
inline ::pulse::cdm::bind::CircuitNodeData* FluidCircuitNodeData::release_circuitnode() {
  
  ::pulse::cdm::bind::CircuitNodeData* temp = circuitnode_;
  circuitnode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::CircuitNodeData* FluidCircuitNodeData::unsafe_arena_release_circuitnode() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitNodeData.CircuitNode)
  
  ::pulse::cdm::bind::CircuitNodeData* temp = circuitnode_;
  circuitnode_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitNodeData* FluidCircuitNodeData::_internal_mutable_circuitnode() {
  
  if (circuitnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitNodeData>(GetArena());
    circuitnode_ = p;
  }
  return circuitnode_;
}
inline ::pulse::cdm::bind::CircuitNodeData* FluidCircuitNodeData::mutable_circuitnode() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitNodeData.CircuitNode)
  return _internal_mutable_circuitnode();
}
inline void FluidCircuitNodeData::set_allocated_circuitnode(::pulse::cdm::bind::CircuitNodeData* circuitnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitnode_;
  }
  if (circuitnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitnode);
    if (message_arena != submessage_arena) {
      circuitnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitnode, submessage_arena);
    }
    
  } else {
    
  }
  circuitnode_ = circuitnode;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.CircuitNode)
}

// .pulse.cdm.bind.ScalarPressureData Pressure = 2;
inline bool FluidCircuitNodeData::_internal_has_pressure() const {
  return this != internal_default_instance() && pressure_ != nullptr;
}
inline bool FluidCircuitNodeData::has_pressure() const {
  return _internal_has_pressure();
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitNodeData::_internal_pressure() const {
  const ::pulse::cdm::bind::ScalarPressureData* p = pressure_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureData&>(
      ::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitNodeData::pressure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitNodeData.Pressure)
  return _internal_pressure();
}
inline void FluidCircuitNodeData::unsafe_arena_set_allocated_pressure(
    ::pulse::cdm::bind::ScalarPressureData* pressure) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pressure_);
  }
  pressure_ = pressure;
  if (pressure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.Pressure)
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitNodeData::release_pressure() {
  
  ::pulse::cdm::bind::ScalarPressureData* temp = pressure_;
  pressure_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitNodeData::unsafe_arena_release_pressure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitNodeData.Pressure)
  
  ::pulse::cdm::bind::ScalarPressureData* temp = pressure_;
  pressure_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitNodeData::_internal_mutable_pressure() {
  
  if (pressure_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureData>(GetArena());
    pressure_ = p;
  }
  return pressure_;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitNodeData::mutable_pressure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitNodeData.Pressure)
  return _internal_mutable_pressure();
}
inline void FluidCircuitNodeData::set_allocated_pressure(::pulse::cdm::bind::ScalarPressureData* pressure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pressure_);
  }
  if (pressure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pressure)->GetArena();
    if (message_arena != submessage_arena) {
      pressure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pressure, submessage_arena);
    }
    
  } else {
    
  }
  pressure_ = pressure;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.Pressure)
}

// .pulse.cdm.bind.ScalarPressureData NextPressure = 3;
inline bool FluidCircuitNodeData::_internal_has_nextpressure() const {
  return this != internal_default_instance() && nextpressure_ != nullptr;
}
inline bool FluidCircuitNodeData::has_nextpressure() const {
  return _internal_has_nextpressure();
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitNodeData::_internal_nextpressure() const {
  const ::pulse::cdm::bind::ScalarPressureData* p = nextpressure_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureData&>(
      ::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitNodeData::nextpressure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitNodeData.NextPressure)
  return _internal_nextpressure();
}
inline void FluidCircuitNodeData::unsafe_arena_set_allocated_nextpressure(
    ::pulse::cdm::bind::ScalarPressureData* nextpressure) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextpressure_);
  }
  nextpressure_ = nextpressure;
  if (nextpressure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.NextPressure)
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitNodeData::release_nextpressure() {
  
  ::pulse::cdm::bind::ScalarPressureData* temp = nextpressure_;
  nextpressure_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitNodeData::unsafe_arena_release_nextpressure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitNodeData.NextPressure)
  
  ::pulse::cdm::bind::ScalarPressureData* temp = nextpressure_;
  nextpressure_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitNodeData::_internal_mutable_nextpressure() {
  
  if (nextpressure_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureData>(GetArena());
    nextpressure_ = p;
  }
  return nextpressure_;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitNodeData::mutable_nextpressure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitNodeData.NextPressure)
  return _internal_mutable_nextpressure();
}
inline void FluidCircuitNodeData::set_allocated_nextpressure(::pulse::cdm::bind::ScalarPressureData* nextpressure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextpressure_);
  }
  if (nextpressure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextpressure)->GetArena();
    if (message_arena != submessage_arena) {
      nextpressure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextpressure, submessage_arena);
    }
    
  } else {
    
  }
  nextpressure_ = nextpressure;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.NextPressure)
}

// .pulse.cdm.bind.ScalarVolumeData Volume = 4;
inline bool FluidCircuitNodeData::_internal_has_volume() const {
  return this != internal_default_instance() && volume_ != nullptr;
}
inline bool FluidCircuitNodeData::has_volume() const {
  return _internal_has_volume();
}
inline const ::pulse::cdm::bind::ScalarVolumeData& FluidCircuitNodeData::_internal_volume() const {
  const ::pulse::cdm::bind::ScalarVolumeData* p = volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumeData&>(
      ::pulse::cdm::bind::_ScalarVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumeData& FluidCircuitNodeData::volume() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitNodeData.Volume)
  return _internal_volume();
}
inline void FluidCircuitNodeData::unsafe_arena_set_allocated_volume(
    ::pulse::cdm::bind::ScalarVolumeData* volume) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_);
  }
  volume_ = volume;
  if (volume) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.Volume)
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::release_volume() {
  
  ::pulse::cdm::bind::ScalarVolumeData* temp = volume_;
  volume_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitNodeData.Volume)
  
  ::pulse::cdm::bind::ScalarVolumeData* temp = volume_;
  volume_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::_internal_mutable_volume() {
  
  if (volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumeData>(GetArena());
    volume_ = p;
  }
  return volume_;
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::mutable_volume() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitNodeData.Volume)
  return _internal_mutable_volume();
}
inline void FluidCircuitNodeData::set_allocated_volume(::pulse::cdm::bind::ScalarVolumeData* volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_);
  }
  if (volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume)->GetArena();
    if (message_arena != submessage_arena) {
      volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    
  } else {
    
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.Volume)
}

// .pulse.cdm.bind.ScalarVolumeData NextVolume = 5;
inline bool FluidCircuitNodeData::_internal_has_nextvolume() const {
  return this != internal_default_instance() && nextvolume_ != nullptr;
}
inline bool FluidCircuitNodeData::has_nextvolume() const {
  return _internal_has_nextvolume();
}
inline const ::pulse::cdm::bind::ScalarVolumeData& FluidCircuitNodeData::_internal_nextvolume() const {
  const ::pulse::cdm::bind::ScalarVolumeData* p = nextvolume_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumeData&>(
      ::pulse::cdm::bind::_ScalarVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumeData& FluidCircuitNodeData::nextvolume() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitNodeData.NextVolume)
  return _internal_nextvolume();
}
inline void FluidCircuitNodeData::unsafe_arena_set_allocated_nextvolume(
    ::pulse::cdm::bind::ScalarVolumeData* nextvolume) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextvolume_);
  }
  nextvolume_ = nextvolume;
  if (nextvolume) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.NextVolume)
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::release_nextvolume() {
  
  ::pulse::cdm::bind::ScalarVolumeData* temp = nextvolume_;
  nextvolume_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::unsafe_arena_release_nextvolume() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitNodeData.NextVolume)
  
  ::pulse::cdm::bind::ScalarVolumeData* temp = nextvolume_;
  nextvolume_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::_internal_mutable_nextvolume() {
  
  if (nextvolume_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumeData>(GetArena());
    nextvolume_ = p;
  }
  return nextvolume_;
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::mutable_nextvolume() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitNodeData.NextVolume)
  return _internal_mutable_nextvolume();
}
inline void FluidCircuitNodeData::set_allocated_nextvolume(::pulse::cdm::bind::ScalarVolumeData* nextvolume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextvolume_);
  }
  if (nextvolume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextvolume)->GetArena();
    if (message_arena != submessage_arena) {
      nextvolume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextvolume, submessage_arena);
    }
    
  } else {
    
  }
  nextvolume_ = nextvolume;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.NextVolume)
}

// .pulse.cdm.bind.ScalarVolumeData VolumeBaseline = 6;
inline bool FluidCircuitNodeData::_internal_has_volumebaseline() const {
  return this != internal_default_instance() && volumebaseline_ != nullptr;
}
inline bool FluidCircuitNodeData::has_volumebaseline() const {
  return _internal_has_volumebaseline();
}
inline const ::pulse::cdm::bind::ScalarVolumeData& FluidCircuitNodeData::_internal_volumebaseline() const {
  const ::pulse::cdm::bind::ScalarVolumeData* p = volumebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumeData&>(
      ::pulse::cdm::bind::_ScalarVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumeData& FluidCircuitNodeData::volumebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitNodeData.VolumeBaseline)
  return _internal_volumebaseline();
}
inline void FluidCircuitNodeData::unsafe_arena_set_allocated_volumebaseline(
    ::pulse::cdm::bind::ScalarVolumeData* volumebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volumebaseline_);
  }
  volumebaseline_ = volumebaseline;
  if (volumebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.VolumeBaseline)
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::release_volumebaseline() {
  
  ::pulse::cdm::bind::ScalarVolumeData* temp = volumebaseline_;
  volumebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::unsafe_arena_release_volumebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitNodeData.VolumeBaseline)
  
  ::pulse::cdm::bind::ScalarVolumeData* temp = volumebaseline_;
  volumebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::_internal_mutable_volumebaseline() {
  
  if (volumebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumeData>(GetArena());
    volumebaseline_ = p;
  }
  return volumebaseline_;
}
inline ::pulse::cdm::bind::ScalarVolumeData* FluidCircuitNodeData::mutable_volumebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitNodeData.VolumeBaseline)
  return _internal_mutable_volumebaseline();
}
inline void FluidCircuitNodeData::set_allocated_volumebaseline(::pulse::cdm::bind::ScalarVolumeData* volumebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(volumebaseline_);
  }
  if (volumebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volumebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      volumebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volumebaseline, submessage_arena);
    }
    
  } else {
    
  }
  volumebaseline_ = volumebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitNodeData.VolumeBaseline)
}

// -------------------------------------------------------------------

// FluidCircuitPathData

// .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
inline bool FluidCircuitPathData::_internal_has_circuitpath() const {
  return this != internal_default_instance() && circuitpath_ != nullptr;
}
inline bool FluidCircuitPathData::has_circuitpath() const {
  return _internal_has_circuitpath();
}
inline void FluidCircuitPathData::clear_circuitpath() {
  if (GetArena() == nullptr && circuitpath_ != nullptr) {
    delete circuitpath_;
  }
  circuitpath_ = nullptr;
}
inline const ::pulse::cdm::bind::CircuitPathData& FluidCircuitPathData::_internal_circuitpath() const {
  const ::pulse::cdm::bind::CircuitPathData* p = circuitpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::CircuitPathData&>(
      ::pulse::cdm::bind::_CircuitPathData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitPathData& FluidCircuitPathData::circuitpath() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.CircuitPath)
  return _internal_circuitpath();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_circuitpath(
    ::pulse::cdm::bind::CircuitPathData* circuitpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitpath_);
  }
  circuitpath_ = circuitpath;
  if (circuitpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.CircuitPath)
}
inline ::pulse::cdm::bind::CircuitPathData* FluidCircuitPathData::release_circuitpath() {
  
  ::pulse::cdm::bind::CircuitPathData* temp = circuitpath_;
  circuitpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::CircuitPathData* FluidCircuitPathData::unsafe_arena_release_circuitpath() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.CircuitPath)
  
  ::pulse::cdm::bind::CircuitPathData* temp = circuitpath_;
  circuitpath_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitPathData* FluidCircuitPathData::_internal_mutable_circuitpath() {
  
  if (circuitpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitPathData>(GetArena());
    circuitpath_ = p;
  }
  return circuitpath_;
}
inline ::pulse::cdm::bind::CircuitPathData* FluidCircuitPathData::mutable_circuitpath() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.CircuitPath)
  return _internal_mutable_circuitpath();
}
inline void FluidCircuitPathData::set_allocated_circuitpath(::pulse::cdm::bind::CircuitPathData* circuitpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitpath_;
  }
  if (circuitpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitpath);
    if (message_arena != submessage_arena) {
      circuitpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitpath, submessage_arena);
    }
    
  } else {
    
  }
  circuitpath_ = circuitpath;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.CircuitPath)
}

// .pulse.cdm.bind.ScalarPressureTimePerVolumeData Resistance = 2;
inline bool FluidCircuitPathData::_internal_has_resistance() const {
  return this != internal_default_instance() && resistance_ != nullptr;
}
inline bool FluidCircuitPathData::has_resistance() const {
  return _internal_has_resistance();
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& FluidCircuitPathData::_internal_resistance() const {
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* p = resistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimePerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& FluidCircuitPathData::resistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.Resistance)
  return _internal_resistance();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_resistance(
    ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistance_);
  }
  resistance_ = resistance;
  if (resistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.Resistance)
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::release_resistance() {
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = resistance_;
  resistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::unsafe_arena_release_resistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.Resistance)
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = resistance_;
  resistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::_internal_mutable_resistance() {
  
  if (resistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimePerVolumeData>(GetArena());
    resistance_ = p;
  }
  return resistance_;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::mutable_resistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.Resistance)
  return _internal_mutable_resistance();
}
inline void FluidCircuitPathData::set_allocated_resistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistance_);
  }
  if (resistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistance)->GetArena();
    if (message_arena != submessage_arena) {
      resistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resistance, submessage_arena);
    }
    
  } else {
    
  }
  resistance_ = resistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.Resistance)
}

// .pulse.cdm.bind.ScalarPressureTimePerVolumeData NextResistance = 3;
inline bool FluidCircuitPathData::_internal_has_nextresistance() const {
  return this != internal_default_instance() && nextresistance_ != nullptr;
}
inline bool FluidCircuitPathData::has_nextresistance() const {
  return _internal_has_nextresistance();
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& FluidCircuitPathData::_internal_nextresistance() const {
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* p = nextresistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimePerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& FluidCircuitPathData::nextresistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.NextResistance)
  return _internal_nextresistance();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_nextresistance(
    ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* nextresistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextresistance_);
  }
  nextresistance_ = nextresistance;
  if (nextresistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextResistance)
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::release_nextresistance() {
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = nextresistance_;
  nextresistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::unsafe_arena_release_nextresistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.NextResistance)
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = nextresistance_;
  nextresistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::_internal_mutable_nextresistance() {
  
  if (nextresistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimePerVolumeData>(GetArena());
    nextresistance_ = p;
  }
  return nextresistance_;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::mutable_nextresistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.NextResistance)
  return _internal_mutable_nextresistance();
}
inline void FluidCircuitPathData::set_allocated_nextresistance(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* nextresistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextresistance_);
  }
  if (nextresistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextresistance)->GetArena();
    if (message_arena != submessage_arena) {
      nextresistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextresistance, submessage_arena);
    }
    
  } else {
    
  }
  nextresistance_ = nextresistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextResistance)
}

// .pulse.cdm.bind.ScalarPressureTimePerVolumeData ResistanceBaseline = 4;
inline bool FluidCircuitPathData::_internal_has_resistancebaseline() const {
  return this != internal_default_instance() && resistancebaseline_ != nullptr;
}
inline bool FluidCircuitPathData::has_resistancebaseline() const {
  return _internal_has_resistancebaseline();
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& FluidCircuitPathData::_internal_resistancebaseline() const {
  const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* p = resistancebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimePerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& FluidCircuitPathData::resistancebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.ResistanceBaseline)
  return _internal_resistancebaseline();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_resistancebaseline(
    ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistancebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancebaseline_);
  }
  resistancebaseline_ = resistancebaseline;
  if (resistancebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.ResistanceBaseline)
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::release_resistancebaseline() {
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = resistancebaseline_;
  resistancebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::unsafe_arena_release_resistancebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.ResistanceBaseline)
  
  ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* temp = resistancebaseline_;
  resistancebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::_internal_mutable_resistancebaseline() {
  
  if (resistancebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimePerVolumeData>(GetArena());
    resistancebaseline_ = p;
  }
  return resistancebaseline_;
}
inline ::pulse::cdm::bind::ScalarPressureTimePerVolumeData* FluidCircuitPathData::mutable_resistancebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.ResistanceBaseline)
  return _internal_mutable_resistancebaseline();
}
inline void FluidCircuitPathData::set_allocated_resistancebaseline(::pulse::cdm::bind::ScalarPressureTimePerVolumeData* resistancebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancebaseline_);
  }
  if (resistancebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      resistancebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resistancebaseline, submessage_arena);
    }
    
  } else {
    
  }
  resistancebaseline_ = resistancebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.ResistanceBaseline)
}

// .pulse.cdm.bind.ScalarVolumePerPressureData Compliance = 5;
inline bool FluidCircuitPathData::_internal_has_compliance() const {
  return this != internal_default_instance() && compliance_ != nullptr;
}
inline bool FluidCircuitPathData::has_compliance() const {
  return _internal_has_compliance();
}
inline const ::pulse::cdm::bind::ScalarVolumePerPressureData& FluidCircuitPathData::_internal_compliance() const {
  const ::pulse::cdm::bind::ScalarVolumePerPressureData* p = compliance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumePerPressureData&>(
      ::pulse::cdm::bind::_ScalarVolumePerPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerPressureData& FluidCircuitPathData::compliance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.Compliance)
  return _internal_compliance();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_compliance(
    ::pulse::cdm::bind::ScalarVolumePerPressureData* compliance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compliance_);
  }
  compliance_ = compliance;
  if (compliance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.Compliance)
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::release_compliance() {
  
  ::pulse::cdm::bind::ScalarVolumePerPressureData* temp = compliance_;
  compliance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::unsafe_arena_release_compliance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.Compliance)
  
  ::pulse::cdm::bind::ScalarVolumePerPressureData* temp = compliance_;
  compliance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::_internal_mutable_compliance() {
  
  if (compliance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumePerPressureData>(GetArena());
    compliance_ = p;
  }
  return compliance_;
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::mutable_compliance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.Compliance)
  return _internal_mutable_compliance();
}
inline void FluidCircuitPathData::set_allocated_compliance(::pulse::cdm::bind::ScalarVolumePerPressureData* compliance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(compliance_);
  }
  if (compliance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compliance)->GetArena();
    if (message_arena != submessage_arena) {
      compliance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compliance, submessage_arena);
    }
    
  } else {
    
  }
  compliance_ = compliance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.Compliance)
}

// .pulse.cdm.bind.ScalarVolumePerPressureData NextCompliance = 6;
inline bool FluidCircuitPathData::_internal_has_nextcompliance() const {
  return this != internal_default_instance() && nextcompliance_ != nullptr;
}
inline bool FluidCircuitPathData::has_nextcompliance() const {
  return _internal_has_nextcompliance();
}
inline const ::pulse::cdm::bind::ScalarVolumePerPressureData& FluidCircuitPathData::_internal_nextcompliance() const {
  const ::pulse::cdm::bind::ScalarVolumePerPressureData* p = nextcompliance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumePerPressureData&>(
      ::pulse::cdm::bind::_ScalarVolumePerPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerPressureData& FluidCircuitPathData::nextcompliance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.NextCompliance)
  return _internal_nextcompliance();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_nextcompliance(
    ::pulse::cdm::bind::ScalarVolumePerPressureData* nextcompliance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcompliance_);
  }
  nextcompliance_ = nextcompliance;
  if (nextcompliance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextCompliance)
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::release_nextcompliance() {
  
  ::pulse::cdm::bind::ScalarVolumePerPressureData* temp = nextcompliance_;
  nextcompliance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::unsafe_arena_release_nextcompliance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.NextCompliance)
  
  ::pulse::cdm::bind::ScalarVolumePerPressureData* temp = nextcompliance_;
  nextcompliance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::_internal_mutable_nextcompliance() {
  
  if (nextcompliance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumePerPressureData>(GetArena());
    nextcompliance_ = p;
  }
  return nextcompliance_;
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::mutable_nextcompliance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.NextCompliance)
  return _internal_mutable_nextcompliance();
}
inline void FluidCircuitPathData::set_allocated_nextcompliance(::pulse::cdm::bind::ScalarVolumePerPressureData* nextcompliance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcompliance_);
  }
  if (nextcompliance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcompliance)->GetArena();
    if (message_arena != submessage_arena) {
      nextcompliance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextcompliance, submessage_arena);
    }
    
  } else {
    
  }
  nextcompliance_ = nextcompliance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextCompliance)
}

// .pulse.cdm.bind.ScalarVolumePerPressureData ComplianceBaseline = 7;
inline bool FluidCircuitPathData::_internal_has_compliancebaseline() const {
  return this != internal_default_instance() && compliancebaseline_ != nullptr;
}
inline bool FluidCircuitPathData::has_compliancebaseline() const {
  return _internal_has_compliancebaseline();
}
inline const ::pulse::cdm::bind::ScalarVolumePerPressureData& FluidCircuitPathData::_internal_compliancebaseline() const {
  const ::pulse::cdm::bind::ScalarVolumePerPressureData* p = compliancebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumePerPressureData&>(
      ::pulse::cdm::bind::_ScalarVolumePerPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerPressureData& FluidCircuitPathData::compliancebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.ComplianceBaseline)
  return _internal_compliancebaseline();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_compliancebaseline(
    ::pulse::cdm::bind::ScalarVolumePerPressureData* compliancebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compliancebaseline_);
  }
  compliancebaseline_ = compliancebaseline;
  if (compliancebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.ComplianceBaseline)
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::release_compliancebaseline() {
  
  ::pulse::cdm::bind::ScalarVolumePerPressureData* temp = compliancebaseline_;
  compliancebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::unsafe_arena_release_compliancebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.ComplianceBaseline)
  
  ::pulse::cdm::bind::ScalarVolumePerPressureData* temp = compliancebaseline_;
  compliancebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::_internal_mutable_compliancebaseline() {
  
  if (compliancebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumePerPressureData>(GetArena());
    compliancebaseline_ = p;
  }
  return compliancebaseline_;
}
inline ::pulse::cdm::bind::ScalarVolumePerPressureData* FluidCircuitPathData::mutable_compliancebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.ComplianceBaseline)
  return _internal_mutable_compliancebaseline();
}
inline void FluidCircuitPathData::set_allocated_compliancebaseline(::pulse::cdm::bind::ScalarVolumePerPressureData* compliancebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(compliancebaseline_);
  }
  if (compliancebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(compliancebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      compliancebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compliancebaseline, submessage_arena);
    }
    
  } else {
    
  }
  compliancebaseline_ = compliancebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.ComplianceBaseline)
}

// .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData Inertance = 8;
inline bool FluidCircuitPathData::_internal_has_inertance() const {
  return this != internal_default_instance() && inertance_ != nullptr;
}
inline bool FluidCircuitPathData::has_inertance() const {
  return _internal_has_inertance();
}
inline const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& FluidCircuitPathData::_internal_inertance() const {
  const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* p = inertance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimeSquaredPerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& FluidCircuitPathData::inertance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.Inertance)
  return _internal_inertance();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_inertance(
    ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inertance_);
  }
  inertance_ = inertance;
  if (inertance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.Inertance)
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::release_inertance() {
  
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* temp = inertance_;
  inertance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::unsafe_arena_release_inertance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.Inertance)
  
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* temp = inertance_;
  inertance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::_internal_mutable_inertance() {
  
  if (inertance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData>(GetArena());
    inertance_ = p;
  }
  return inertance_;
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::mutable_inertance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.Inertance)
  return _internal_mutable_inertance();
}
inline void FluidCircuitPathData::set_allocated_inertance(::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inertance_);
  }
  if (inertance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inertance)->GetArena();
    if (message_arena != submessage_arena) {
      inertance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inertance, submessage_arena);
    }
    
  } else {
    
  }
  inertance_ = inertance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.Inertance)
}

// .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData NextInertance = 9;
inline bool FluidCircuitPathData::_internal_has_nextinertance() const {
  return this != internal_default_instance() && nextinertance_ != nullptr;
}
inline bool FluidCircuitPathData::has_nextinertance() const {
  return _internal_has_nextinertance();
}
inline const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& FluidCircuitPathData::_internal_nextinertance() const {
  const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* p = nextinertance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimeSquaredPerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& FluidCircuitPathData::nextinertance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.NextInertance)
  return _internal_nextinertance();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_nextinertance(
    ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* nextinertance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextinertance_);
  }
  nextinertance_ = nextinertance;
  if (nextinertance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextInertance)
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::release_nextinertance() {
  
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* temp = nextinertance_;
  nextinertance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::unsafe_arena_release_nextinertance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.NextInertance)
  
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* temp = nextinertance_;
  nextinertance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::_internal_mutable_nextinertance() {
  
  if (nextinertance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData>(GetArena());
    nextinertance_ = p;
  }
  return nextinertance_;
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::mutable_nextinertance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.NextInertance)
  return _internal_mutable_nextinertance();
}
inline void FluidCircuitPathData::set_allocated_nextinertance(::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* nextinertance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextinertance_);
  }
  if (nextinertance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextinertance)->GetArena();
    if (message_arena != submessage_arena) {
      nextinertance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextinertance, submessage_arena);
    }
    
  } else {
    
  }
  nextinertance_ = nextinertance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextInertance)
}

// .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData InertanceBaseline = 10;
inline bool FluidCircuitPathData::_internal_has_inertancebaseline() const {
  return this != internal_default_instance() && inertancebaseline_ != nullptr;
}
inline bool FluidCircuitPathData::has_inertancebaseline() const {
  return _internal_has_inertancebaseline();
}
inline const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& FluidCircuitPathData::_internal_inertancebaseline() const {
  const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* p = inertancebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData&>(
      ::pulse::cdm::bind::_ScalarPressureTimeSquaredPerVolumeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& FluidCircuitPathData::inertancebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.InertanceBaseline)
  return _internal_inertancebaseline();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_inertancebaseline(
    ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertancebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inertancebaseline_);
  }
  inertancebaseline_ = inertancebaseline;
  if (inertancebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.InertanceBaseline)
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::release_inertancebaseline() {
  
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* temp = inertancebaseline_;
  inertancebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::unsafe_arena_release_inertancebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.InertanceBaseline)
  
  ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* temp = inertancebaseline_;
  inertancebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::_internal_mutable_inertancebaseline() {
  
  if (inertancebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData>(GetArena());
    inertancebaseline_ = p;
  }
  return inertancebaseline_;
}
inline ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* FluidCircuitPathData::mutable_inertancebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.InertanceBaseline)
  return _internal_mutable_inertancebaseline();
}
inline void FluidCircuitPathData::set_allocated_inertancebaseline(::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData* inertancebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inertancebaseline_);
  }
  if (inertancebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inertancebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      inertancebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inertancebaseline, submessage_arena);
    }
    
  } else {
    
  }
  inertancebaseline_ = inertancebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.InertanceBaseline)
}

// .pulse.cdm.bind.ScalarVolumePerTimeData Flow = 11;
inline bool FluidCircuitPathData::_internal_has_flow() const {
  return this != internal_default_instance() && flow_ != nullptr;
}
inline bool FluidCircuitPathData::has_flow() const {
  return _internal_has_flow();
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::_internal_flow() const {
  const ::pulse::cdm::bind::ScalarVolumePerTimeData* p = flow_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumePerTimeData&>(
      ::pulse::cdm::bind::_ScalarVolumePerTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::flow() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.Flow)
  return _internal_flow();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_flow(
    ::pulse::cdm::bind::ScalarVolumePerTimeData* flow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_);
  }
  flow_ = flow;
  if (flow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.Flow)
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::release_flow() {
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = flow_;
  flow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::unsafe_arena_release_flow() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.Flow)
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = flow_;
  flow_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::_internal_mutable_flow() {
  
  if (flow_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumePerTimeData>(GetArena());
    flow_ = p;
  }
  return flow_;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::mutable_flow() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.Flow)
  return _internal_mutable_flow();
}
inline void FluidCircuitPathData::set_allocated_flow(::pulse::cdm::bind::ScalarVolumePerTimeData* flow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_);
  }
  if (flow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow)->GetArena();
    if (message_arena != submessage_arena) {
      flow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow, submessage_arena);
    }
    
  } else {
    
  }
  flow_ = flow;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.Flow)
}

// .pulse.cdm.bind.ScalarVolumePerTimeData NextFlow = 12;
inline bool FluidCircuitPathData::_internal_has_nextflow() const {
  return this != internal_default_instance() && nextflow_ != nullptr;
}
inline bool FluidCircuitPathData::has_nextflow() const {
  return _internal_has_nextflow();
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::_internal_nextflow() const {
  const ::pulse::cdm::bind::ScalarVolumePerTimeData* p = nextflow_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumePerTimeData&>(
      ::pulse::cdm::bind::_ScalarVolumePerTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::nextflow() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.NextFlow)
  return _internal_nextflow();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_nextflow(
    ::pulse::cdm::bind::ScalarVolumePerTimeData* nextflow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextflow_);
  }
  nextflow_ = nextflow;
  if (nextflow) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextFlow)
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::release_nextflow() {
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = nextflow_;
  nextflow_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::unsafe_arena_release_nextflow() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.NextFlow)
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = nextflow_;
  nextflow_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::_internal_mutable_nextflow() {
  
  if (nextflow_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumePerTimeData>(GetArena());
    nextflow_ = p;
  }
  return nextflow_;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::mutable_nextflow() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.NextFlow)
  return _internal_mutable_nextflow();
}
inline void FluidCircuitPathData::set_allocated_nextflow(::pulse::cdm::bind::ScalarVolumePerTimeData* nextflow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextflow_);
  }
  if (nextflow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextflow)->GetArena();
    if (message_arena != submessage_arena) {
      nextflow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextflow, submessage_arena);
    }
    
  } else {
    
  }
  nextflow_ = nextflow;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextFlow)
}

// .pulse.cdm.bind.ScalarVolumePerTimeData FlowSource = 13;
inline bool FluidCircuitPathData::_internal_has_flowsource() const {
  return this != internal_default_instance() && flowsource_ != nullptr;
}
inline bool FluidCircuitPathData::has_flowsource() const {
  return _internal_has_flowsource();
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::_internal_flowsource() const {
  const ::pulse::cdm::bind::ScalarVolumePerTimeData* p = flowsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumePerTimeData&>(
      ::pulse::cdm::bind::_ScalarVolumePerTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::flowsource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.FlowSource)
  return _internal_flowsource();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_flowsource(
    ::pulse::cdm::bind::ScalarVolumePerTimeData* flowsource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flowsource_);
  }
  flowsource_ = flowsource;
  if (flowsource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.FlowSource)
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::release_flowsource() {
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = flowsource_;
  flowsource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::unsafe_arena_release_flowsource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.FlowSource)
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = flowsource_;
  flowsource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::_internal_mutable_flowsource() {
  
  if (flowsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumePerTimeData>(GetArena());
    flowsource_ = p;
  }
  return flowsource_;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::mutable_flowsource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.FlowSource)
  return _internal_mutable_flowsource();
}
inline void FluidCircuitPathData::set_allocated_flowsource(::pulse::cdm::bind::ScalarVolumePerTimeData* flowsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flowsource_);
  }
  if (flowsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flowsource)->GetArena();
    if (message_arena != submessage_arena) {
      flowsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flowsource, submessage_arena);
    }
    
  } else {
    
  }
  flowsource_ = flowsource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.FlowSource)
}

// .pulse.cdm.bind.ScalarVolumePerTimeData NextFlowSource = 14;
inline bool FluidCircuitPathData::_internal_has_nextflowsource() const {
  return this != internal_default_instance() && nextflowsource_ != nullptr;
}
inline bool FluidCircuitPathData::has_nextflowsource() const {
  return _internal_has_nextflowsource();
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::_internal_nextflowsource() const {
  const ::pulse::cdm::bind::ScalarVolumePerTimeData* p = nextflowsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumePerTimeData&>(
      ::pulse::cdm::bind::_ScalarVolumePerTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::nextflowsource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.NextFlowSource)
  return _internal_nextflowsource();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_nextflowsource(
    ::pulse::cdm::bind::ScalarVolumePerTimeData* nextflowsource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextflowsource_);
  }
  nextflowsource_ = nextflowsource;
  if (nextflowsource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextFlowSource)
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::release_nextflowsource() {
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = nextflowsource_;
  nextflowsource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::unsafe_arena_release_nextflowsource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.NextFlowSource)
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = nextflowsource_;
  nextflowsource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::_internal_mutable_nextflowsource() {
  
  if (nextflowsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumePerTimeData>(GetArena());
    nextflowsource_ = p;
  }
  return nextflowsource_;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::mutable_nextflowsource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.NextFlowSource)
  return _internal_mutable_nextflowsource();
}
inline void FluidCircuitPathData::set_allocated_nextflowsource(::pulse::cdm::bind::ScalarVolumePerTimeData* nextflowsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextflowsource_);
  }
  if (nextflowsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextflowsource)->GetArena();
    if (message_arena != submessage_arena) {
      nextflowsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextflowsource, submessage_arena);
    }
    
  } else {
    
  }
  nextflowsource_ = nextflowsource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextFlowSource)
}

// .pulse.cdm.bind.ScalarVolumePerTimeData FlowSourceBaseline = 15;
inline bool FluidCircuitPathData::_internal_has_flowsourcebaseline() const {
  return this != internal_default_instance() && flowsourcebaseline_ != nullptr;
}
inline bool FluidCircuitPathData::has_flowsourcebaseline() const {
  return _internal_has_flowsourcebaseline();
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::_internal_flowsourcebaseline() const {
  const ::pulse::cdm::bind::ScalarVolumePerTimeData* p = flowsourcebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarVolumePerTimeData&>(
      ::pulse::cdm::bind::_ScalarVolumePerTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarVolumePerTimeData& FluidCircuitPathData::flowsourcebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.FlowSourceBaseline)
  return _internal_flowsourcebaseline();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_flowsourcebaseline(
    ::pulse::cdm::bind::ScalarVolumePerTimeData* flowsourcebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flowsourcebaseline_);
  }
  flowsourcebaseline_ = flowsourcebaseline;
  if (flowsourcebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.FlowSourceBaseline)
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::release_flowsourcebaseline() {
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = flowsourcebaseline_;
  flowsourcebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::unsafe_arena_release_flowsourcebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.FlowSourceBaseline)
  
  ::pulse::cdm::bind::ScalarVolumePerTimeData* temp = flowsourcebaseline_;
  flowsourcebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::_internal_mutable_flowsourcebaseline() {
  
  if (flowsourcebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarVolumePerTimeData>(GetArena());
    flowsourcebaseline_ = p;
  }
  return flowsourcebaseline_;
}
inline ::pulse::cdm::bind::ScalarVolumePerTimeData* FluidCircuitPathData::mutable_flowsourcebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.FlowSourceBaseline)
  return _internal_mutable_flowsourcebaseline();
}
inline void FluidCircuitPathData::set_allocated_flowsourcebaseline(::pulse::cdm::bind::ScalarVolumePerTimeData* flowsourcebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flowsourcebaseline_);
  }
  if (flowsourcebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flowsourcebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      flowsourcebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flowsourcebaseline, submessage_arena);
    }
    
  } else {
    
  }
  flowsourcebaseline_ = flowsourcebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.FlowSourceBaseline)
}

// .pulse.cdm.bind.ScalarPressureData PressureSource = 16;
inline bool FluidCircuitPathData::_internal_has_pressuresource() const {
  return this != internal_default_instance() && pressuresource_ != nullptr;
}
inline bool FluidCircuitPathData::has_pressuresource() const {
  return _internal_has_pressuresource();
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitPathData::_internal_pressuresource() const {
  const ::pulse::cdm::bind::ScalarPressureData* p = pressuresource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureData&>(
      ::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitPathData::pressuresource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.PressureSource)
  return _internal_pressuresource();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_pressuresource(
    ::pulse::cdm::bind::ScalarPressureData* pressuresource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pressuresource_);
  }
  pressuresource_ = pressuresource;
  if (pressuresource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.PressureSource)
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::release_pressuresource() {
  
  ::pulse::cdm::bind::ScalarPressureData* temp = pressuresource_;
  pressuresource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::unsafe_arena_release_pressuresource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.PressureSource)
  
  ::pulse::cdm::bind::ScalarPressureData* temp = pressuresource_;
  pressuresource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::_internal_mutable_pressuresource() {
  
  if (pressuresource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureData>(GetArena());
    pressuresource_ = p;
  }
  return pressuresource_;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::mutable_pressuresource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.PressureSource)
  return _internal_mutable_pressuresource();
}
inline void FluidCircuitPathData::set_allocated_pressuresource(::pulse::cdm::bind::ScalarPressureData* pressuresource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pressuresource_);
  }
  if (pressuresource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pressuresource)->GetArena();
    if (message_arena != submessage_arena) {
      pressuresource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pressuresource, submessage_arena);
    }
    
  } else {
    
  }
  pressuresource_ = pressuresource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.PressureSource)
}

// .pulse.cdm.bind.ScalarPressureData NextPressureSource = 17;
inline bool FluidCircuitPathData::_internal_has_nextpressuresource() const {
  return this != internal_default_instance() && nextpressuresource_ != nullptr;
}
inline bool FluidCircuitPathData::has_nextpressuresource() const {
  return _internal_has_nextpressuresource();
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitPathData::_internal_nextpressuresource() const {
  const ::pulse::cdm::bind::ScalarPressureData* p = nextpressuresource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureData&>(
      ::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitPathData::nextpressuresource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.NextPressureSource)
  return _internal_nextpressuresource();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_nextpressuresource(
    ::pulse::cdm::bind::ScalarPressureData* nextpressuresource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextpressuresource_);
  }
  nextpressuresource_ = nextpressuresource;
  if (nextpressuresource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextPressureSource)
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::release_nextpressuresource() {
  
  ::pulse::cdm::bind::ScalarPressureData* temp = nextpressuresource_;
  nextpressuresource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::unsafe_arena_release_nextpressuresource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.NextPressureSource)
  
  ::pulse::cdm::bind::ScalarPressureData* temp = nextpressuresource_;
  nextpressuresource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::_internal_mutable_nextpressuresource() {
  
  if (nextpressuresource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureData>(GetArena());
    nextpressuresource_ = p;
  }
  return nextpressuresource_;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::mutable_nextpressuresource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.NextPressureSource)
  return _internal_mutable_nextpressuresource();
}
inline void FluidCircuitPathData::set_allocated_nextpressuresource(::pulse::cdm::bind::ScalarPressureData* nextpressuresource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextpressuresource_);
  }
  if (nextpressuresource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextpressuresource)->GetArena();
    if (message_arena != submessage_arena) {
      nextpressuresource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextpressuresource, submessage_arena);
    }
    
  } else {
    
  }
  nextpressuresource_ = nextpressuresource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.NextPressureSource)
}

// .pulse.cdm.bind.ScalarPressureData PressureSourceBaseline = 18;
inline bool FluidCircuitPathData::_internal_has_pressuresourcebaseline() const {
  return this != internal_default_instance() && pressuresourcebaseline_ != nullptr;
}
inline bool FluidCircuitPathData::has_pressuresourcebaseline() const {
  return _internal_has_pressuresourcebaseline();
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitPathData::_internal_pressuresourcebaseline() const {
  const ::pulse::cdm::bind::ScalarPressureData* p = pressuresourcebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureData&>(
      ::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitPathData::pressuresourcebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.PressureSourceBaseline)
  return _internal_pressuresourcebaseline();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_pressuresourcebaseline(
    ::pulse::cdm::bind::ScalarPressureData* pressuresourcebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pressuresourcebaseline_);
  }
  pressuresourcebaseline_ = pressuresourcebaseline;
  if (pressuresourcebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.PressureSourceBaseline)
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::release_pressuresourcebaseline() {
  
  ::pulse::cdm::bind::ScalarPressureData* temp = pressuresourcebaseline_;
  pressuresourcebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::unsafe_arena_release_pressuresourcebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.PressureSourceBaseline)
  
  ::pulse::cdm::bind::ScalarPressureData* temp = pressuresourcebaseline_;
  pressuresourcebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::_internal_mutable_pressuresourcebaseline() {
  
  if (pressuresourcebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureData>(GetArena());
    pressuresourcebaseline_ = p;
  }
  return pressuresourcebaseline_;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::mutable_pressuresourcebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.PressureSourceBaseline)
  return _internal_mutable_pressuresourcebaseline();
}
inline void FluidCircuitPathData::set_allocated_pressuresourcebaseline(::pulse::cdm::bind::ScalarPressureData* pressuresourcebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pressuresourcebaseline_);
  }
  if (pressuresourcebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pressuresourcebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      pressuresourcebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pressuresourcebaseline, submessage_arena);
    }
    
  } else {
    
  }
  pressuresourcebaseline_ = pressuresourcebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.PressureSourceBaseline)
}

// .pulse.cdm.bind.ScalarPressureData ValveBreakdownPressure = 19;
inline bool FluidCircuitPathData::_internal_has_valvebreakdownpressure() const {
  return this != internal_default_instance() && valvebreakdownpressure_ != nullptr;
}
inline bool FluidCircuitPathData::has_valvebreakdownpressure() const {
  return _internal_has_valvebreakdownpressure();
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitPathData::_internal_valvebreakdownpressure() const {
  const ::pulse::cdm::bind::ScalarPressureData* p = valvebreakdownpressure_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPressureData&>(
      ::pulse::cdm::bind::_ScalarPressureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPressureData& FluidCircuitPathData::valvebreakdownpressure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.FluidCircuitPathData.ValveBreakdownPressure)
  return _internal_valvebreakdownpressure();
}
inline void FluidCircuitPathData::unsafe_arena_set_allocated_valvebreakdownpressure(
    ::pulse::cdm::bind::ScalarPressureData* valvebreakdownpressure) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valvebreakdownpressure_);
  }
  valvebreakdownpressure_ = valvebreakdownpressure;
  if (valvebreakdownpressure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.FluidCircuitPathData.ValveBreakdownPressure)
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::release_valvebreakdownpressure() {
  
  ::pulse::cdm::bind::ScalarPressureData* temp = valvebreakdownpressure_;
  valvebreakdownpressure_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::unsafe_arena_release_valvebreakdownpressure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.FluidCircuitPathData.ValveBreakdownPressure)
  
  ::pulse::cdm::bind::ScalarPressureData* temp = valvebreakdownpressure_;
  valvebreakdownpressure_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::_internal_mutable_valvebreakdownpressure() {
  
  if (valvebreakdownpressure_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPressureData>(GetArena());
    valvebreakdownpressure_ = p;
  }
  return valvebreakdownpressure_;
}
inline ::pulse::cdm::bind::ScalarPressureData* FluidCircuitPathData::mutable_valvebreakdownpressure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.FluidCircuitPathData.ValveBreakdownPressure)
  return _internal_mutable_valvebreakdownpressure();
}
inline void FluidCircuitPathData::set_allocated_valvebreakdownpressure(::pulse::cdm::bind::ScalarPressureData* valvebreakdownpressure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(valvebreakdownpressure_);
  }
  if (valvebreakdownpressure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valvebreakdownpressure)->GetArena();
    if (message_arena != submessage_arena) {
      valvebreakdownpressure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valvebreakdownpressure, submessage_arena);
    }
    
  } else {
    
  }
  valvebreakdownpressure_ = valvebreakdownpressure;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.FluidCircuitPathData.ValveBreakdownPressure)
}

// -------------------------------------------------------------------

// ThermalCircuitData

// .pulse.cdm.bind.CircuitData Circuit = 1;
inline bool ThermalCircuitData::_internal_has_circuit() const {
  return this != internal_default_instance() && circuit_ != nullptr;
}
inline bool ThermalCircuitData::has_circuit() const {
  return _internal_has_circuit();
}
inline void ThermalCircuitData::clear_circuit() {
  if (GetArena() == nullptr && circuit_ != nullptr) {
    delete circuit_;
  }
  circuit_ = nullptr;
}
inline const ::pulse::cdm::bind::CircuitData& ThermalCircuitData::_internal_circuit() const {
  const ::pulse::cdm::bind::CircuitData* p = circuit_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::CircuitData&>(
      ::pulse::cdm::bind::_CircuitData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitData& ThermalCircuitData::circuit() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitData.Circuit)
  return _internal_circuit();
}
inline void ThermalCircuitData::unsafe_arena_set_allocated_circuit(
    ::pulse::cdm::bind::CircuitData* circuit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuit_);
  }
  circuit_ = circuit;
  if (circuit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitData.Circuit)
}
inline ::pulse::cdm::bind::CircuitData* ThermalCircuitData::release_circuit() {
  
  ::pulse::cdm::bind::CircuitData* temp = circuit_;
  circuit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::CircuitData* ThermalCircuitData::unsafe_arena_release_circuit() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitData.Circuit)
  
  ::pulse::cdm::bind::CircuitData* temp = circuit_;
  circuit_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitData* ThermalCircuitData::_internal_mutable_circuit() {
  
  if (circuit_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitData>(GetArena());
    circuit_ = p;
  }
  return circuit_;
}
inline ::pulse::cdm::bind::CircuitData* ThermalCircuitData::mutable_circuit() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitData.Circuit)
  return _internal_mutable_circuit();
}
inline void ThermalCircuitData::set_allocated_circuit(::pulse::cdm::bind::CircuitData* circuit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuit_;
  }
  if (circuit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuit);
    if (message_arena != submessage_arena) {
      circuit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuit, submessage_arena);
    }
    
  } else {
    
  }
  circuit_ = circuit;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitData.Circuit)
}

// -------------------------------------------------------------------

// ThermalCircuitNodeData

// .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
inline bool ThermalCircuitNodeData::_internal_has_circuitnode() const {
  return this != internal_default_instance() && circuitnode_ != nullptr;
}
inline bool ThermalCircuitNodeData::has_circuitnode() const {
  return _internal_has_circuitnode();
}
inline void ThermalCircuitNodeData::clear_circuitnode() {
  if (GetArena() == nullptr && circuitnode_ != nullptr) {
    delete circuitnode_;
  }
  circuitnode_ = nullptr;
}
inline const ::pulse::cdm::bind::CircuitNodeData& ThermalCircuitNodeData::_internal_circuitnode() const {
  const ::pulse::cdm::bind::CircuitNodeData* p = circuitnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::CircuitNodeData&>(
      ::pulse::cdm::bind::_CircuitNodeData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitNodeData& ThermalCircuitNodeData::circuitnode() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitNodeData.CircuitNode)
  return _internal_circuitnode();
}
inline void ThermalCircuitNodeData::unsafe_arena_set_allocated_circuitnode(
    ::pulse::cdm::bind::CircuitNodeData* circuitnode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitnode_);
  }
  circuitnode_ = circuitnode;
  if (circuitnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.CircuitNode)
}
inline ::pulse::cdm::bind::CircuitNodeData* ThermalCircuitNodeData::release_circuitnode() {
  
  ::pulse::cdm::bind::CircuitNodeData* temp = circuitnode_;
  circuitnode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::CircuitNodeData* ThermalCircuitNodeData::unsafe_arena_release_circuitnode() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitNodeData.CircuitNode)
  
  ::pulse::cdm::bind::CircuitNodeData* temp = circuitnode_;
  circuitnode_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitNodeData* ThermalCircuitNodeData::_internal_mutable_circuitnode() {
  
  if (circuitnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitNodeData>(GetArena());
    circuitnode_ = p;
  }
  return circuitnode_;
}
inline ::pulse::cdm::bind::CircuitNodeData* ThermalCircuitNodeData::mutable_circuitnode() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitNodeData.CircuitNode)
  return _internal_mutable_circuitnode();
}
inline void ThermalCircuitNodeData::set_allocated_circuitnode(::pulse::cdm::bind::CircuitNodeData* circuitnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitnode_;
  }
  if (circuitnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitnode);
    if (message_arena != submessage_arena) {
      circuitnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitnode, submessage_arena);
    }
    
  } else {
    
  }
  circuitnode_ = circuitnode;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.CircuitNode)
}

// .pulse.cdm.bind.ScalarTemperatureData Temperature = 2;
inline bool ThermalCircuitNodeData::_internal_has_temperature() const {
  return this != internal_default_instance() && temperature_ != nullptr;
}
inline bool ThermalCircuitNodeData::has_temperature() const {
  return _internal_has_temperature();
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitNodeData::_internal_temperature() const {
  const ::pulse::cdm::bind::ScalarTemperatureData* p = temperature_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarTemperatureData&>(
      ::pulse::cdm::bind::_ScalarTemperatureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitNodeData::temperature() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitNodeData.Temperature)
  return _internal_temperature();
}
inline void ThermalCircuitNodeData::unsafe_arena_set_allocated_temperature(
    ::pulse::cdm::bind::ScalarTemperatureData* temperature) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperature_);
  }
  temperature_ = temperature;
  if (temperature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.Temperature)
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitNodeData::release_temperature() {
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = temperature_;
  temperature_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitNodeData::unsafe_arena_release_temperature() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitNodeData.Temperature)
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = temperature_;
  temperature_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitNodeData::_internal_mutable_temperature() {
  
  if (temperature_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarTemperatureData>(GetArena());
    temperature_ = p;
  }
  return temperature_;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitNodeData::mutable_temperature() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitNodeData.Temperature)
  return _internal_mutable_temperature();
}
inline void ThermalCircuitNodeData::set_allocated_temperature(::pulse::cdm::bind::ScalarTemperatureData* temperature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperature_);
  }
  if (temperature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperature)->GetArena();
    if (message_arena != submessage_arena) {
      temperature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, temperature, submessage_arena);
    }
    
  } else {
    
  }
  temperature_ = temperature;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.Temperature)
}

// .pulse.cdm.bind.ScalarTemperatureData NextTemperature = 3;
inline bool ThermalCircuitNodeData::_internal_has_nexttemperature() const {
  return this != internal_default_instance() && nexttemperature_ != nullptr;
}
inline bool ThermalCircuitNodeData::has_nexttemperature() const {
  return _internal_has_nexttemperature();
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitNodeData::_internal_nexttemperature() const {
  const ::pulse::cdm::bind::ScalarTemperatureData* p = nexttemperature_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarTemperatureData&>(
      ::pulse::cdm::bind::_ScalarTemperatureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitNodeData::nexttemperature() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitNodeData.NextTemperature)
  return _internal_nexttemperature();
}
inline void ThermalCircuitNodeData::unsafe_arena_set_allocated_nexttemperature(
    ::pulse::cdm::bind::ScalarTemperatureData* nexttemperature) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexttemperature_);
  }
  nexttemperature_ = nexttemperature;
  if (nexttemperature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.NextTemperature)
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitNodeData::release_nexttemperature() {
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = nexttemperature_;
  nexttemperature_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitNodeData::unsafe_arena_release_nexttemperature() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitNodeData.NextTemperature)
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = nexttemperature_;
  nexttemperature_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitNodeData::_internal_mutable_nexttemperature() {
  
  if (nexttemperature_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarTemperatureData>(GetArena());
    nexttemperature_ = p;
  }
  return nexttemperature_;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitNodeData::mutable_nexttemperature() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitNodeData.NextTemperature)
  return _internal_mutable_nexttemperature();
}
inline void ThermalCircuitNodeData::set_allocated_nexttemperature(::pulse::cdm::bind::ScalarTemperatureData* nexttemperature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexttemperature_);
  }
  if (nexttemperature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexttemperature)->GetArena();
    if (message_arena != submessage_arena) {
      nexttemperature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexttemperature, submessage_arena);
    }
    
  } else {
    
  }
  nexttemperature_ = nexttemperature;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.NextTemperature)
}

// .pulse.cdm.bind.ScalarEnergyData Heat = 4;
inline bool ThermalCircuitNodeData::_internal_has_heat() const {
  return this != internal_default_instance() && heat_ != nullptr;
}
inline bool ThermalCircuitNodeData::has_heat() const {
  return _internal_has_heat();
}
inline const ::pulse::cdm::bind::ScalarEnergyData& ThermalCircuitNodeData::_internal_heat() const {
  const ::pulse::cdm::bind::ScalarEnergyData* p = heat_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarEnergyData&>(
      ::pulse::cdm::bind::_ScalarEnergyData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarEnergyData& ThermalCircuitNodeData::heat() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitNodeData.Heat)
  return _internal_heat();
}
inline void ThermalCircuitNodeData::unsafe_arena_set_allocated_heat(
    ::pulse::cdm::bind::ScalarEnergyData* heat) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heat_);
  }
  heat_ = heat;
  if (heat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.Heat)
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::release_heat() {
  
  ::pulse::cdm::bind::ScalarEnergyData* temp = heat_;
  heat_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::unsafe_arena_release_heat() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitNodeData.Heat)
  
  ::pulse::cdm::bind::ScalarEnergyData* temp = heat_;
  heat_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::_internal_mutable_heat() {
  
  if (heat_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarEnergyData>(GetArena());
    heat_ = p;
  }
  return heat_;
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::mutable_heat() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitNodeData.Heat)
  return _internal_mutable_heat();
}
inline void ThermalCircuitNodeData::set_allocated_heat(::pulse::cdm::bind::ScalarEnergyData* heat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heat_);
  }
  if (heat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heat)->GetArena();
    if (message_arena != submessage_arena) {
      heat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heat, submessage_arena);
    }
    
  } else {
    
  }
  heat_ = heat;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.Heat)
}

// .pulse.cdm.bind.ScalarEnergyData NextHeat = 5;
inline bool ThermalCircuitNodeData::_internal_has_nextheat() const {
  return this != internal_default_instance() && nextheat_ != nullptr;
}
inline bool ThermalCircuitNodeData::has_nextheat() const {
  return _internal_has_nextheat();
}
inline const ::pulse::cdm::bind::ScalarEnergyData& ThermalCircuitNodeData::_internal_nextheat() const {
  const ::pulse::cdm::bind::ScalarEnergyData* p = nextheat_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarEnergyData&>(
      ::pulse::cdm::bind::_ScalarEnergyData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarEnergyData& ThermalCircuitNodeData::nextheat() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitNodeData.NextHeat)
  return _internal_nextheat();
}
inline void ThermalCircuitNodeData::unsafe_arena_set_allocated_nextheat(
    ::pulse::cdm::bind::ScalarEnergyData* nextheat) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextheat_);
  }
  nextheat_ = nextheat;
  if (nextheat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.NextHeat)
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::release_nextheat() {
  
  ::pulse::cdm::bind::ScalarEnergyData* temp = nextheat_;
  nextheat_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::unsafe_arena_release_nextheat() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitNodeData.NextHeat)
  
  ::pulse::cdm::bind::ScalarEnergyData* temp = nextheat_;
  nextheat_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::_internal_mutable_nextheat() {
  
  if (nextheat_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarEnergyData>(GetArena());
    nextheat_ = p;
  }
  return nextheat_;
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::mutable_nextheat() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitNodeData.NextHeat)
  return _internal_mutable_nextheat();
}
inline void ThermalCircuitNodeData::set_allocated_nextheat(::pulse::cdm::bind::ScalarEnergyData* nextheat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextheat_);
  }
  if (nextheat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextheat)->GetArena();
    if (message_arena != submessage_arena) {
      nextheat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextheat, submessage_arena);
    }
    
  } else {
    
  }
  nextheat_ = nextheat;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.NextHeat)
}

// .pulse.cdm.bind.ScalarEnergyData HeatBaseline = 6;
inline bool ThermalCircuitNodeData::_internal_has_heatbaseline() const {
  return this != internal_default_instance() && heatbaseline_ != nullptr;
}
inline bool ThermalCircuitNodeData::has_heatbaseline() const {
  return _internal_has_heatbaseline();
}
inline const ::pulse::cdm::bind::ScalarEnergyData& ThermalCircuitNodeData::_internal_heatbaseline() const {
  const ::pulse::cdm::bind::ScalarEnergyData* p = heatbaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarEnergyData&>(
      ::pulse::cdm::bind::_ScalarEnergyData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarEnergyData& ThermalCircuitNodeData::heatbaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitNodeData.HeatBaseline)
  return _internal_heatbaseline();
}
inline void ThermalCircuitNodeData::unsafe_arena_set_allocated_heatbaseline(
    ::pulse::cdm::bind::ScalarEnergyData* heatbaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heatbaseline_);
  }
  heatbaseline_ = heatbaseline;
  if (heatbaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.HeatBaseline)
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::release_heatbaseline() {
  
  ::pulse::cdm::bind::ScalarEnergyData* temp = heatbaseline_;
  heatbaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::unsafe_arena_release_heatbaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitNodeData.HeatBaseline)
  
  ::pulse::cdm::bind::ScalarEnergyData* temp = heatbaseline_;
  heatbaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::_internal_mutable_heatbaseline() {
  
  if (heatbaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarEnergyData>(GetArena());
    heatbaseline_ = p;
  }
  return heatbaseline_;
}
inline ::pulse::cdm::bind::ScalarEnergyData* ThermalCircuitNodeData::mutable_heatbaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitNodeData.HeatBaseline)
  return _internal_mutable_heatbaseline();
}
inline void ThermalCircuitNodeData::set_allocated_heatbaseline(::pulse::cdm::bind::ScalarEnergyData* heatbaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heatbaseline_);
  }
  if (heatbaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heatbaseline)->GetArena();
    if (message_arena != submessage_arena) {
      heatbaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heatbaseline, submessage_arena);
    }
    
  } else {
    
  }
  heatbaseline_ = heatbaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitNodeData.HeatBaseline)
}

// -------------------------------------------------------------------

// ThermalCircuitPathData

// .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
inline bool ThermalCircuitPathData::_internal_has_circuitpath() const {
  return this != internal_default_instance() && circuitpath_ != nullptr;
}
inline bool ThermalCircuitPathData::has_circuitpath() const {
  return _internal_has_circuitpath();
}
inline void ThermalCircuitPathData::clear_circuitpath() {
  if (GetArena() == nullptr && circuitpath_ != nullptr) {
    delete circuitpath_;
  }
  circuitpath_ = nullptr;
}
inline const ::pulse::cdm::bind::CircuitPathData& ThermalCircuitPathData::_internal_circuitpath() const {
  const ::pulse::cdm::bind::CircuitPathData* p = circuitpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::CircuitPathData&>(
      ::pulse::cdm::bind::_CircuitPathData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitPathData& ThermalCircuitPathData::circuitpath() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.CircuitPath)
  return _internal_circuitpath();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_circuitpath(
    ::pulse::cdm::bind::CircuitPathData* circuitpath) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitpath_);
  }
  circuitpath_ = circuitpath;
  if (circuitpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.CircuitPath)
}
inline ::pulse::cdm::bind::CircuitPathData* ThermalCircuitPathData::release_circuitpath() {
  
  ::pulse::cdm::bind::CircuitPathData* temp = circuitpath_;
  circuitpath_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::CircuitPathData* ThermalCircuitPathData::unsafe_arena_release_circuitpath() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.CircuitPath)
  
  ::pulse::cdm::bind::CircuitPathData* temp = circuitpath_;
  circuitpath_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitPathData* ThermalCircuitPathData::_internal_mutable_circuitpath() {
  
  if (circuitpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitPathData>(GetArena());
    circuitpath_ = p;
  }
  return circuitpath_;
}
inline ::pulse::cdm::bind::CircuitPathData* ThermalCircuitPathData::mutable_circuitpath() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.CircuitPath)
  return _internal_mutable_circuitpath();
}
inline void ThermalCircuitPathData::set_allocated_circuitpath(::pulse::cdm::bind::CircuitPathData* circuitpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete circuitpath_;
  }
  if (circuitpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circuitpath);
    if (message_arena != submessage_arena) {
      circuitpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitpath, submessage_arena);
    }
    
  } else {
    
  }
  circuitpath_ = circuitpath;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.CircuitPath)
}

// .pulse.cdm.bind.ScalarHeatResistanceData Resistance = 2;
inline bool ThermalCircuitPathData::_internal_has_resistance() const {
  return this != internal_default_instance() && resistance_ != nullptr;
}
inline bool ThermalCircuitPathData::has_resistance() const {
  return _internal_has_resistance();
}
inline const ::pulse::cdm::bind::ScalarHeatResistanceData& ThermalCircuitPathData::_internal_resistance() const {
  const ::pulse::cdm::bind::ScalarHeatResistanceData* p = resistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarHeatResistanceData&>(
      ::pulse::cdm::bind::_ScalarHeatResistanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarHeatResistanceData& ThermalCircuitPathData::resistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.Resistance)
  return _internal_resistance();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_resistance(
    ::pulse::cdm::bind::ScalarHeatResistanceData* resistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistance_);
  }
  resistance_ = resistance;
  if (resistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.Resistance)
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::release_resistance() {
  
  ::pulse::cdm::bind::ScalarHeatResistanceData* temp = resistance_;
  resistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::unsafe_arena_release_resistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.Resistance)
  
  ::pulse::cdm::bind::ScalarHeatResistanceData* temp = resistance_;
  resistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::_internal_mutable_resistance() {
  
  if (resistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarHeatResistanceData>(GetArena());
    resistance_ = p;
  }
  return resistance_;
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::mutable_resistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.Resistance)
  return _internal_mutable_resistance();
}
inline void ThermalCircuitPathData::set_allocated_resistance(::pulse::cdm::bind::ScalarHeatResistanceData* resistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistance_);
  }
  if (resistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistance)->GetArena();
    if (message_arena != submessage_arena) {
      resistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resistance, submessage_arena);
    }
    
  } else {
    
  }
  resistance_ = resistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.Resistance)
}

// .pulse.cdm.bind.ScalarHeatResistanceData NextResistance = 3;
inline bool ThermalCircuitPathData::_internal_has_nextresistance() const {
  return this != internal_default_instance() && nextresistance_ != nullptr;
}
inline bool ThermalCircuitPathData::has_nextresistance() const {
  return _internal_has_nextresistance();
}
inline const ::pulse::cdm::bind::ScalarHeatResistanceData& ThermalCircuitPathData::_internal_nextresistance() const {
  const ::pulse::cdm::bind::ScalarHeatResistanceData* p = nextresistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarHeatResistanceData&>(
      ::pulse::cdm::bind::_ScalarHeatResistanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarHeatResistanceData& ThermalCircuitPathData::nextresistance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.NextResistance)
  return _internal_nextresistance();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_nextresistance(
    ::pulse::cdm::bind::ScalarHeatResistanceData* nextresistance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextresistance_);
  }
  nextresistance_ = nextresistance;
  if (nextresistance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextResistance)
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::release_nextresistance() {
  
  ::pulse::cdm::bind::ScalarHeatResistanceData* temp = nextresistance_;
  nextresistance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::unsafe_arena_release_nextresistance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.NextResistance)
  
  ::pulse::cdm::bind::ScalarHeatResistanceData* temp = nextresistance_;
  nextresistance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::_internal_mutable_nextresistance() {
  
  if (nextresistance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarHeatResistanceData>(GetArena());
    nextresistance_ = p;
  }
  return nextresistance_;
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::mutable_nextresistance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.NextResistance)
  return _internal_mutable_nextresistance();
}
inline void ThermalCircuitPathData::set_allocated_nextresistance(::pulse::cdm::bind::ScalarHeatResistanceData* nextresistance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextresistance_);
  }
  if (nextresistance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextresistance)->GetArena();
    if (message_arena != submessage_arena) {
      nextresistance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextresistance, submessage_arena);
    }
    
  } else {
    
  }
  nextresistance_ = nextresistance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextResistance)
}

// .pulse.cdm.bind.ScalarHeatResistanceData ResistanceBaseline = 4;
inline bool ThermalCircuitPathData::_internal_has_resistancebaseline() const {
  return this != internal_default_instance() && resistancebaseline_ != nullptr;
}
inline bool ThermalCircuitPathData::has_resistancebaseline() const {
  return _internal_has_resistancebaseline();
}
inline const ::pulse::cdm::bind::ScalarHeatResistanceData& ThermalCircuitPathData::_internal_resistancebaseline() const {
  const ::pulse::cdm::bind::ScalarHeatResistanceData* p = resistancebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarHeatResistanceData&>(
      ::pulse::cdm::bind::_ScalarHeatResistanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarHeatResistanceData& ThermalCircuitPathData::resistancebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.ResistanceBaseline)
  return _internal_resistancebaseline();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_resistancebaseline(
    ::pulse::cdm::bind::ScalarHeatResistanceData* resistancebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancebaseline_);
  }
  resistancebaseline_ = resistancebaseline;
  if (resistancebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.ResistanceBaseline)
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::release_resistancebaseline() {
  
  ::pulse::cdm::bind::ScalarHeatResistanceData* temp = resistancebaseline_;
  resistancebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::unsafe_arena_release_resistancebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.ResistanceBaseline)
  
  ::pulse::cdm::bind::ScalarHeatResistanceData* temp = resistancebaseline_;
  resistancebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::_internal_mutable_resistancebaseline() {
  
  if (resistancebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarHeatResistanceData>(GetArena());
    resistancebaseline_ = p;
  }
  return resistancebaseline_;
}
inline ::pulse::cdm::bind::ScalarHeatResistanceData* ThermalCircuitPathData::mutable_resistancebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.ResistanceBaseline)
  return _internal_mutable_resistancebaseline();
}
inline void ThermalCircuitPathData::set_allocated_resistancebaseline(::pulse::cdm::bind::ScalarHeatResistanceData* resistancebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancebaseline_);
  }
  if (resistancebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      resistancebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resistancebaseline, submessage_arena);
    }
    
  } else {
    
  }
  resistancebaseline_ = resistancebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.ResistanceBaseline)
}

// .pulse.cdm.bind.ScalarHeatCapacitanceData Capacitance = 5;
inline bool ThermalCircuitPathData::_internal_has_capacitance() const {
  return this != internal_default_instance() && capacitance_ != nullptr;
}
inline bool ThermalCircuitPathData::has_capacitance() const {
  return _internal_has_capacitance();
}
inline const ::pulse::cdm::bind::ScalarHeatCapacitanceData& ThermalCircuitPathData::_internal_capacitance() const {
  const ::pulse::cdm::bind::ScalarHeatCapacitanceData* p = capacitance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarHeatCapacitanceData&>(
      ::pulse::cdm::bind::_ScalarHeatCapacitanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarHeatCapacitanceData& ThermalCircuitPathData::capacitance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.Capacitance)
  return _internal_capacitance();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_capacitance(
    ::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitance_);
  }
  capacitance_ = capacitance;
  if (capacitance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.Capacitance)
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::release_capacitance() {
  
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* temp = capacitance_;
  capacitance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::unsafe_arena_release_capacitance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.Capacitance)
  
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* temp = capacitance_;
  capacitance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::_internal_mutable_capacitance() {
  
  if (capacitance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarHeatCapacitanceData>(GetArena());
    capacitance_ = p;
  }
  return capacitance_;
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::mutable_capacitance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.Capacitance)
  return _internal_mutable_capacitance();
}
inline void ThermalCircuitPathData::set_allocated_capacitance(::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitance_);
  }
  if (capacitance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitance)->GetArena();
    if (message_arena != submessage_arena) {
      capacitance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capacitance, submessage_arena);
    }
    
  } else {
    
  }
  capacitance_ = capacitance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.Capacitance)
}

// .pulse.cdm.bind.ScalarHeatCapacitanceData NextCapacitance = 6;
inline bool ThermalCircuitPathData::_internal_has_nextcapacitance() const {
  return this != internal_default_instance() && nextcapacitance_ != nullptr;
}
inline bool ThermalCircuitPathData::has_nextcapacitance() const {
  return _internal_has_nextcapacitance();
}
inline const ::pulse::cdm::bind::ScalarHeatCapacitanceData& ThermalCircuitPathData::_internal_nextcapacitance() const {
  const ::pulse::cdm::bind::ScalarHeatCapacitanceData* p = nextcapacitance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarHeatCapacitanceData&>(
      ::pulse::cdm::bind::_ScalarHeatCapacitanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarHeatCapacitanceData& ThermalCircuitPathData::nextcapacitance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.NextCapacitance)
  return _internal_nextcapacitance();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_nextcapacitance(
    ::pulse::cdm::bind::ScalarHeatCapacitanceData* nextcapacitance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcapacitance_);
  }
  nextcapacitance_ = nextcapacitance;
  if (nextcapacitance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextCapacitance)
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::release_nextcapacitance() {
  
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* temp = nextcapacitance_;
  nextcapacitance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::unsafe_arena_release_nextcapacitance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.NextCapacitance)
  
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* temp = nextcapacitance_;
  nextcapacitance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::_internal_mutable_nextcapacitance() {
  
  if (nextcapacitance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarHeatCapacitanceData>(GetArena());
    nextcapacitance_ = p;
  }
  return nextcapacitance_;
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::mutable_nextcapacitance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.NextCapacitance)
  return _internal_mutable_nextcapacitance();
}
inline void ThermalCircuitPathData::set_allocated_nextcapacitance(::pulse::cdm::bind::ScalarHeatCapacitanceData* nextcapacitance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcapacitance_);
  }
  if (nextcapacitance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextcapacitance)->GetArena();
    if (message_arena != submessage_arena) {
      nextcapacitance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextcapacitance, submessage_arena);
    }
    
  } else {
    
  }
  nextcapacitance_ = nextcapacitance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextCapacitance)
}

// .pulse.cdm.bind.ScalarHeatCapacitanceData CapacitanceBaseline = 7;
inline bool ThermalCircuitPathData::_internal_has_capacitancebaseline() const {
  return this != internal_default_instance() && capacitancebaseline_ != nullptr;
}
inline bool ThermalCircuitPathData::has_capacitancebaseline() const {
  return _internal_has_capacitancebaseline();
}
inline const ::pulse::cdm::bind::ScalarHeatCapacitanceData& ThermalCircuitPathData::_internal_capacitancebaseline() const {
  const ::pulse::cdm::bind::ScalarHeatCapacitanceData* p = capacitancebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarHeatCapacitanceData&>(
      ::pulse::cdm::bind::_ScalarHeatCapacitanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarHeatCapacitanceData& ThermalCircuitPathData::capacitancebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.CapacitanceBaseline)
  return _internal_capacitancebaseline();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_capacitancebaseline(
    ::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitancebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitancebaseline_);
  }
  capacitancebaseline_ = capacitancebaseline;
  if (capacitancebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.CapacitanceBaseline)
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::release_capacitancebaseline() {
  
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* temp = capacitancebaseline_;
  capacitancebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::unsafe_arena_release_capacitancebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.CapacitanceBaseline)
  
  ::pulse::cdm::bind::ScalarHeatCapacitanceData* temp = capacitancebaseline_;
  capacitancebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::_internal_mutable_capacitancebaseline() {
  
  if (capacitancebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarHeatCapacitanceData>(GetArena());
    capacitancebaseline_ = p;
  }
  return capacitancebaseline_;
}
inline ::pulse::cdm::bind::ScalarHeatCapacitanceData* ThermalCircuitPathData::mutable_capacitancebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.CapacitanceBaseline)
  return _internal_mutable_capacitancebaseline();
}
inline void ThermalCircuitPathData::set_allocated_capacitancebaseline(::pulse::cdm::bind::ScalarHeatCapacitanceData* capacitancebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitancebaseline_);
  }
  if (capacitancebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacitancebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      capacitancebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capacitancebaseline, submessage_arena);
    }
    
  } else {
    
  }
  capacitancebaseline_ = capacitancebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.CapacitanceBaseline)
}

// .pulse.cdm.bind.ScalarHeatInductanceData Inductance = 8;
inline bool ThermalCircuitPathData::_internal_has_inductance() const {
  return this != internal_default_instance() && inductance_ != nullptr;
}
inline bool ThermalCircuitPathData::has_inductance() const {
  return _internal_has_inductance();
}
inline const ::pulse::cdm::bind::ScalarHeatInductanceData& ThermalCircuitPathData::_internal_inductance() const {
  const ::pulse::cdm::bind::ScalarHeatInductanceData* p = inductance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarHeatInductanceData&>(
      ::pulse::cdm::bind::_ScalarHeatInductanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarHeatInductanceData& ThermalCircuitPathData::inductance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.Inductance)
  return _internal_inductance();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_inductance(
    ::pulse::cdm::bind::ScalarHeatInductanceData* inductance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductance_);
  }
  inductance_ = inductance;
  if (inductance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.Inductance)
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::release_inductance() {
  
  ::pulse::cdm::bind::ScalarHeatInductanceData* temp = inductance_;
  inductance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::unsafe_arena_release_inductance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.Inductance)
  
  ::pulse::cdm::bind::ScalarHeatInductanceData* temp = inductance_;
  inductance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::_internal_mutable_inductance() {
  
  if (inductance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarHeatInductanceData>(GetArena());
    inductance_ = p;
  }
  return inductance_;
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::mutable_inductance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.Inductance)
  return _internal_mutable_inductance();
}
inline void ThermalCircuitPathData::set_allocated_inductance(::pulse::cdm::bind::ScalarHeatInductanceData* inductance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductance_);
  }
  if (inductance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductance)->GetArena();
    if (message_arena != submessage_arena) {
      inductance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inductance, submessage_arena);
    }
    
  } else {
    
  }
  inductance_ = inductance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.Inductance)
}

// .pulse.cdm.bind.ScalarHeatInductanceData NextInductance = 9;
inline bool ThermalCircuitPathData::_internal_has_nextinductance() const {
  return this != internal_default_instance() && nextinductance_ != nullptr;
}
inline bool ThermalCircuitPathData::has_nextinductance() const {
  return _internal_has_nextinductance();
}
inline const ::pulse::cdm::bind::ScalarHeatInductanceData& ThermalCircuitPathData::_internal_nextinductance() const {
  const ::pulse::cdm::bind::ScalarHeatInductanceData* p = nextinductance_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarHeatInductanceData&>(
      ::pulse::cdm::bind::_ScalarHeatInductanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarHeatInductanceData& ThermalCircuitPathData::nextinductance() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.NextInductance)
  return _internal_nextinductance();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_nextinductance(
    ::pulse::cdm::bind::ScalarHeatInductanceData* nextinductance) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextinductance_);
  }
  nextinductance_ = nextinductance;
  if (nextinductance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextInductance)
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::release_nextinductance() {
  
  ::pulse::cdm::bind::ScalarHeatInductanceData* temp = nextinductance_;
  nextinductance_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::unsafe_arena_release_nextinductance() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.NextInductance)
  
  ::pulse::cdm::bind::ScalarHeatInductanceData* temp = nextinductance_;
  nextinductance_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::_internal_mutable_nextinductance() {
  
  if (nextinductance_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarHeatInductanceData>(GetArena());
    nextinductance_ = p;
  }
  return nextinductance_;
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::mutable_nextinductance() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.NextInductance)
  return _internal_mutable_nextinductance();
}
inline void ThermalCircuitPathData::set_allocated_nextinductance(::pulse::cdm::bind::ScalarHeatInductanceData* nextinductance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextinductance_);
  }
  if (nextinductance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextinductance)->GetArena();
    if (message_arena != submessage_arena) {
      nextinductance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextinductance, submessage_arena);
    }
    
  } else {
    
  }
  nextinductance_ = nextinductance;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextInductance)
}

// .pulse.cdm.bind.ScalarHeatInductanceData InductanceBaseline = 10;
inline bool ThermalCircuitPathData::_internal_has_inductancebaseline() const {
  return this != internal_default_instance() && inductancebaseline_ != nullptr;
}
inline bool ThermalCircuitPathData::has_inductancebaseline() const {
  return _internal_has_inductancebaseline();
}
inline const ::pulse::cdm::bind::ScalarHeatInductanceData& ThermalCircuitPathData::_internal_inductancebaseline() const {
  const ::pulse::cdm::bind::ScalarHeatInductanceData* p = inductancebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarHeatInductanceData&>(
      ::pulse::cdm::bind::_ScalarHeatInductanceData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarHeatInductanceData& ThermalCircuitPathData::inductancebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.InductanceBaseline)
  return _internal_inductancebaseline();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_inductancebaseline(
    ::pulse::cdm::bind::ScalarHeatInductanceData* inductancebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductancebaseline_);
  }
  inductancebaseline_ = inductancebaseline;
  if (inductancebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.InductanceBaseline)
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::release_inductancebaseline() {
  
  ::pulse::cdm::bind::ScalarHeatInductanceData* temp = inductancebaseline_;
  inductancebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::unsafe_arena_release_inductancebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.InductanceBaseline)
  
  ::pulse::cdm::bind::ScalarHeatInductanceData* temp = inductancebaseline_;
  inductancebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::_internal_mutable_inductancebaseline() {
  
  if (inductancebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarHeatInductanceData>(GetArena());
    inductancebaseline_ = p;
  }
  return inductancebaseline_;
}
inline ::pulse::cdm::bind::ScalarHeatInductanceData* ThermalCircuitPathData::mutable_inductancebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.InductanceBaseline)
  return _internal_mutable_inductancebaseline();
}
inline void ThermalCircuitPathData::set_allocated_inductancebaseline(::pulse::cdm::bind::ScalarHeatInductanceData* inductancebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductancebaseline_);
  }
  if (inductancebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inductancebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      inductancebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inductancebaseline, submessage_arena);
    }
    
  } else {
    
  }
  inductancebaseline_ = inductancebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.InductanceBaseline)
}

// .pulse.cdm.bind.ScalarPowerData HeatTransferRate = 11;
inline bool ThermalCircuitPathData::_internal_has_heattransferrate() const {
  return this != internal_default_instance() && heattransferrate_ != nullptr;
}
inline bool ThermalCircuitPathData::has_heattransferrate() const {
  return _internal_has_heattransferrate();
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::_internal_heattransferrate() const {
  const ::pulse::cdm::bind::ScalarPowerData* p = heattransferrate_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPowerData&>(
      ::pulse::cdm::bind::_ScalarPowerData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::heattransferrate() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.HeatTransferRate)
  return _internal_heattransferrate();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_heattransferrate(
    ::pulse::cdm::bind::ScalarPowerData* heattransferrate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heattransferrate_);
  }
  heattransferrate_ = heattransferrate;
  if (heattransferrate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.HeatTransferRate)
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::release_heattransferrate() {
  
  ::pulse::cdm::bind::ScalarPowerData* temp = heattransferrate_;
  heattransferrate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::unsafe_arena_release_heattransferrate() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.HeatTransferRate)
  
  ::pulse::cdm::bind::ScalarPowerData* temp = heattransferrate_;
  heattransferrate_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::_internal_mutable_heattransferrate() {
  
  if (heattransferrate_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPowerData>(GetArena());
    heattransferrate_ = p;
  }
  return heattransferrate_;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::mutable_heattransferrate() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.HeatTransferRate)
  return _internal_mutable_heattransferrate();
}
inline void ThermalCircuitPathData::set_allocated_heattransferrate(::pulse::cdm::bind::ScalarPowerData* heattransferrate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heattransferrate_);
  }
  if (heattransferrate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heattransferrate)->GetArena();
    if (message_arena != submessage_arena) {
      heattransferrate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heattransferrate, submessage_arena);
    }
    
  } else {
    
  }
  heattransferrate_ = heattransferrate;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.HeatTransferRate)
}

// .pulse.cdm.bind.ScalarPowerData NextHeatTransferRate = 12;
inline bool ThermalCircuitPathData::_internal_has_nextheattransferrate() const {
  return this != internal_default_instance() && nextheattransferrate_ != nullptr;
}
inline bool ThermalCircuitPathData::has_nextheattransferrate() const {
  return _internal_has_nextheattransferrate();
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::_internal_nextheattransferrate() const {
  const ::pulse::cdm::bind::ScalarPowerData* p = nextheattransferrate_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPowerData&>(
      ::pulse::cdm::bind::_ScalarPowerData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::nextheattransferrate() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.NextHeatTransferRate)
  return _internal_nextheattransferrate();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_nextheattransferrate(
    ::pulse::cdm::bind::ScalarPowerData* nextheattransferrate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextheattransferrate_);
  }
  nextheattransferrate_ = nextheattransferrate;
  if (nextheattransferrate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextHeatTransferRate)
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::release_nextheattransferrate() {
  
  ::pulse::cdm::bind::ScalarPowerData* temp = nextheattransferrate_;
  nextheattransferrate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::unsafe_arena_release_nextheattransferrate() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.NextHeatTransferRate)
  
  ::pulse::cdm::bind::ScalarPowerData* temp = nextheattransferrate_;
  nextheattransferrate_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::_internal_mutable_nextheattransferrate() {
  
  if (nextheattransferrate_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPowerData>(GetArena());
    nextheattransferrate_ = p;
  }
  return nextheattransferrate_;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::mutable_nextheattransferrate() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.NextHeatTransferRate)
  return _internal_mutable_nextheattransferrate();
}
inline void ThermalCircuitPathData::set_allocated_nextheattransferrate(::pulse::cdm::bind::ScalarPowerData* nextheattransferrate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextheattransferrate_);
  }
  if (nextheattransferrate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextheattransferrate)->GetArena();
    if (message_arena != submessage_arena) {
      nextheattransferrate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextheattransferrate, submessage_arena);
    }
    
  } else {
    
  }
  nextheattransferrate_ = nextheattransferrate;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextHeatTransferRate)
}

// .pulse.cdm.bind.ScalarPowerData HeatSource = 13;
inline bool ThermalCircuitPathData::_internal_has_heatsource() const {
  return this != internal_default_instance() && heatsource_ != nullptr;
}
inline bool ThermalCircuitPathData::has_heatsource() const {
  return _internal_has_heatsource();
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::_internal_heatsource() const {
  const ::pulse::cdm::bind::ScalarPowerData* p = heatsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPowerData&>(
      ::pulse::cdm::bind::_ScalarPowerData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::heatsource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.HeatSource)
  return _internal_heatsource();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_heatsource(
    ::pulse::cdm::bind::ScalarPowerData* heatsource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heatsource_);
  }
  heatsource_ = heatsource;
  if (heatsource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.HeatSource)
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::release_heatsource() {
  
  ::pulse::cdm::bind::ScalarPowerData* temp = heatsource_;
  heatsource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::unsafe_arena_release_heatsource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.HeatSource)
  
  ::pulse::cdm::bind::ScalarPowerData* temp = heatsource_;
  heatsource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::_internal_mutable_heatsource() {
  
  if (heatsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPowerData>(GetArena());
    heatsource_ = p;
  }
  return heatsource_;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::mutable_heatsource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.HeatSource)
  return _internal_mutable_heatsource();
}
inline void ThermalCircuitPathData::set_allocated_heatsource(::pulse::cdm::bind::ScalarPowerData* heatsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heatsource_);
  }
  if (heatsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heatsource)->GetArena();
    if (message_arena != submessage_arena) {
      heatsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heatsource, submessage_arena);
    }
    
  } else {
    
  }
  heatsource_ = heatsource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.HeatSource)
}

// .pulse.cdm.bind.ScalarPowerData NextHeatSource = 14;
inline bool ThermalCircuitPathData::_internal_has_nextheatsource() const {
  return this != internal_default_instance() && nextheatsource_ != nullptr;
}
inline bool ThermalCircuitPathData::has_nextheatsource() const {
  return _internal_has_nextheatsource();
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::_internal_nextheatsource() const {
  const ::pulse::cdm::bind::ScalarPowerData* p = nextheatsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPowerData&>(
      ::pulse::cdm::bind::_ScalarPowerData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::nextheatsource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.NextHeatSource)
  return _internal_nextheatsource();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_nextheatsource(
    ::pulse::cdm::bind::ScalarPowerData* nextheatsource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextheatsource_);
  }
  nextheatsource_ = nextheatsource;
  if (nextheatsource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextHeatSource)
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::release_nextheatsource() {
  
  ::pulse::cdm::bind::ScalarPowerData* temp = nextheatsource_;
  nextheatsource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::unsafe_arena_release_nextheatsource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.NextHeatSource)
  
  ::pulse::cdm::bind::ScalarPowerData* temp = nextheatsource_;
  nextheatsource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::_internal_mutable_nextheatsource() {
  
  if (nextheatsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPowerData>(GetArena());
    nextheatsource_ = p;
  }
  return nextheatsource_;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::mutable_nextheatsource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.NextHeatSource)
  return _internal_mutable_nextheatsource();
}
inline void ThermalCircuitPathData::set_allocated_nextheatsource(::pulse::cdm::bind::ScalarPowerData* nextheatsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextheatsource_);
  }
  if (nextheatsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nextheatsource)->GetArena();
    if (message_arena != submessage_arena) {
      nextheatsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nextheatsource, submessage_arena);
    }
    
  } else {
    
  }
  nextheatsource_ = nextheatsource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextHeatSource)
}

// .pulse.cdm.bind.ScalarPowerData HeatSourceBaseline = 15;
inline bool ThermalCircuitPathData::_internal_has_heatsourcebaseline() const {
  return this != internal_default_instance() && heatsourcebaseline_ != nullptr;
}
inline bool ThermalCircuitPathData::has_heatsourcebaseline() const {
  return _internal_has_heatsourcebaseline();
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::_internal_heatsourcebaseline() const {
  const ::pulse::cdm::bind::ScalarPowerData* p = heatsourcebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarPowerData&>(
      ::pulse::cdm::bind::_ScalarPowerData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarPowerData& ThermalCircuitPathData::heatsourcebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.HeatSourceBaseline)
  return _internal_heatsourcebaseline();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_heatsourcebaseline(
    ::pulse::cdm::bind::ScalarPowerData* heatsourcebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heatsourcebaseline_);
  }
  heatsourcebaseline_ = heatsourcebaseline;
  if (heatsourcebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.HeatSourceBaseline)
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::release_heatsourcebaseline() {
  
  ::pulse::cdm::bind::ScalarPowerData* temp = heatsourcebaseline_;
  heatsourcebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::unsafe_arena_release_heatsourcebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.HeatSourceBaseline)
  
  ::pulse::cdm::bind::ScalarPowerData* temp = heatsourcebaseline_;
  heatsourcebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::_internal_mutable_heatsourcebaseline() {
  
  if (heatsourcebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarPowerData>(GetArena());
    heatsourcebaseline_ = p;
  }
  return heatsourcebaseline_;
}
inline ::pulse::cdm::bind::ScalarPowerData* ThermalCircuitPathData::mutable_heatsourcebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.HeatSourceBaseline)
  return _internal_mutable_heatsourcebaseline();
}
inline void ThermalCircuitPathData::set_allocated_heatsourcebaseline(::pulse::cdm::bind::ScalarPowerData* heatsourcebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heatsourcebaseline_);
  }
  if (heatsourcebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heatsourcebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      heatsourcebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heatsourcebaseline, submessage_arena);
    }
    
  } else {
    
  }
  heatsourcebaseline_ = heatsourcebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.HeatSourceBaseline)
}

// .pulse.cdm.bind.ScalarTemperatureData TemperatureSource = 16;
inline bool ThermalCircuitPathData::_internal_has_temperaturesource() const {
  return this != internal_default_instance() && temperaturesource_ != nullptr;
}
inline bool ThermalCircuitPathData::has_temperaturesource() const {
  return _internal_has_temperaturesource();
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitPathData::_internal_temperaturesource() const {
  const ::pulse::cdm::bind::ScalarTemperatureData* p = temperaturesource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarTemperatureData&>(
      ::pulse::cdm::bind::_ScalarTemperatureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitPathData::temperaturesource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSource)
  return _internal_temperaturesource();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_temperaturesource(
    ::pulse::cdm::bind::ScalarTemperatureData* temperaturesource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperaturesource_);
  }
  temperaturesource_ = temperaturesource;
  if (temperaturesource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSource)
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::release_temperaturesource() {
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = temperaturesource_;
  temperaturesource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::unsafe_arena_release_temperaturesource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSource)
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = temperaturesource_;
  temperaturesource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::_internal_mutable_temperaturesource() {
  
  if (temperaturesource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarTemperatureData>(GetArena());
    temperaturesource_ = p;
  }
  return temperaturesource_;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::mutable_temperaturesource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSource)
  return _internal_mutable_temperaturesource();
}
inline void ThermalCircuitPathData::set_allocated_temperaturesource(::pulse::cdm::bind::ScalarTemperatureData* temperaturesource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperaturesource_);
  }
  if (temperaturesource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperaturesource)->GetArena();
    if (message_arena != submessage_arena) {
      temperaturesource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, temperaturesource, submessage_arena);
    }
    
  } else {
    
  }
  temperaturesource_ = temperaturesource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSource)
}

// .pulse.cdm.bind.ScalarTemperatureData NextTemperatureSource = 17;
inline bool ThermalCircuitPathData::_internal_has_nexttemperaturesource() const {
  return this != internal_default_instance() && nexttemperaturesource_ != nullptr;
}
inline bool ThermalCircuitPathData::has_nexttemperaturesource() const {
  return _internal_has_nexttemperaturesource();
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitPathData::_internal_nexttemperaturesource() const {
  const ::pulse::cdm::bind::ScalarTemperatureData* p = nexttemperaturesource_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarTemperatureData&>(
      ::pulse::cdm::bind::_ScalarTemperatureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitPathData::nexttemperaturesource() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.NextTemperatureSource)
  return _internal_nexttemperaturesource();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_nexttemperaturesource(
    ::pulse::cdm::bind::ScalarTemperatureData* nexttemperaturesource) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexttemperaturesource_);
  }
  nexttemperaturesource_ = nexttemperaturesource;
  if (nexttemperaturesource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextTemperatureSource)
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::release_nexttemperaturesource() {
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = nexttemperaturesource_;
  nexttemperaturesource_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::unsafe_arena_release_nexttemperaturesource() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.NextTemperatureSource)
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = nexttemperaturesource_;
  nexttemperaturesource_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::_internal_mutable_nexttemperaturesource() {
  
  if (nexttemperaturesource_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarTemperatureData>(GetArena());
    nexttemperaturesource_ = p;
  }
  return nexttemperaturesource_;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::mutable_nexttemperaturesource() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.NextTemperatureSource)
  return _internal_mutable_nexttemperaturesource();
}
inline void ThermalCircuitPathData::set_allocated_nexttemperaturesource(::pulse::cdm::bind::ScalarTemperatureData* nexttemperaturesource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexttemperaturesource_);
  }
  if (nexttemperaturesource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexttemperaturesource)->GetArena();
    if (message_arena != submessage_arena) {
      nexttemperaturesource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexttemperaturesource, submessage_arena);
    }
    
  } else {
    
  }
  nexttemperaturesource_ = nexttemperaturesource;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.NextTemperatureSource)
}

// .pulse.cdm.bind.ScalarTemperatureData TemperatureSourceBaseline = 18;
inline bool ThermalCircuitPathData::_internal_has_temperaturesourcebaseline() const {
  return this != internal_default_instance() && temperaturesourcebaseline_ != nullptr;
}
inline bool ThermalCircuitPathData::has_temperaturesourcebaseline() const {
  return _internal_has_temperaturesourcebaseline();
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitPathData::_internal_temperaturesourcebaseline() const {
  const ::pulse::cdm::bind::ScalarTemperatureData* p = temperaturesourcebaseline_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarTemperatureData&>(
      ::pulse::cdm::bind::_ScalarTemperatureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitPathData::temperaturesourcebaseline() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSourceBaseline)
  return _internal_temperaturesourcebaseline();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_temperaturesourcebaseline(
    ::pulse::cdm::bind::ScalarTemperatureData* temperaturesourcebaseline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperaturesourcebaseline_);
  }
  temperaturesourcebaseline_ = temperaturesourcebaseline;
  if (temperaturesourcebaseline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSourceBaseline)
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::release_temperaturesourcebaseline() {
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = temperaturesourcebaseline_;
  temperaturesourcebaseline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::unsafe_arena_release_temperaturesourcebaseline() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSourceBaseline)
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = temperaturesourcebaseline_;
  temperaturesourcebaseline_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::_internal_mutable_temperaturesourcebaseline() {
  
  if (temperaturesourcebaseline_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarTemperatureData>(GetArena());
    temperaturesourcebaseline_ = p;
  }
  return temperaturesourcebaseline_;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::mutable_temperaturesourcebaseline() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSourceBaseline)
  return _internal_mutable_temperaturesourcebaseline();
}
inline void ThermalCircuitPathData::set_allocated_temperaturesourcebaseline(::pulse::cdm::bind::ScalarTemperatureData* temperaturesourcebaseline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperaturesourcebaseline_);
  }
  if (temperaturesourcebaseline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperaturesourcebaseline)->GetArena();
    if (message_arena != submessage_arena) {
      temperaturesourcebaseline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, temperaturesourcebaseline, submessage_arena);
    }
    
  } else {
    
  }
  temperaturesourcebaseline_ = temperaturesourcebaseline;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.TemperatureSourceBaseline)
}

// .pulse.cdm.bind.ScalarTemperatureData ValveBreakdownTemperature = 19;
inline bool ThermalCircuitPathData::_internal_has_valvebreakdowntemperature() const {
  return this != internal_default_instance() && valvebreakdowntemperature_ != nullptr;
}
inline bool ThermalCircuitPathData::has_valvebreakdowntemperature() const {
  return _internal_has_valvebreakdowntemperature();
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitPathData::_internal_valvebreakdowntemperature() const {
  const ::pulse::cdm::bind::ScalarTemperatureData* p = valvebreakdowntemperature_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulse::cdm::bind::ScalarTemperatureData&>(
      ::pulse::cdm::bind::_ScalarTemperatureData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTemperatureData& ThermalCircuitPathData::valvebreakdowntemperature() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.ThermalCircuitPathData.ValveBreakdownTemperature)
  return _internal_valvebreakdowntemperature();
}
inline void ThermalCircuitPathData::unsafe_arena_set_allocated_valvebreakdowntemperature(
    ::pulse::cdm::bind::ScalarTemperatureData* valvebreakdowntemperature) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valvebreakdowntemperature_);
  }
  valvebreakdowntemperature_ = valvebreakdowntemperature;
  if (valvebreakdowntemperature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.ValveBreakdownTemperature)
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::release_valvebreakdowntemperature() {
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = valvebreakdowntemperature_;
  valvebreakdowntemperature_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::unsafe_arena_release_valvebreakdowntemperature() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.ThermalCircuitPathData.ValveBreakdownTemperature)
  
  ::pulse::cdm::bind::ScalarTemperatureData* temp = valvebreakdowntemperature_;
  valvebreakdowntemperature_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::_internal_mutable_valvebreakdowntemperature() {
  
  if (valvebreakdowntemperature_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarTemperatureData>(GetArena());
    valvebreakdowntemperature_ = p;
  }
  return valvebreakdowntemperature_;
}
inline ::pulse::cdm::bind::ScalarTemperatureData* ThermalCircuitPathData::mutable_valvebreakdowntemperature() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.ThermalCircuitPathData.ValveBreakdownTemperature)
  return _internal_mutable_valvebreakdowntemperature();
}
inline void ThermalCircuitPathData::set_allocated_valvebreakdowntemperature(::pulse::cdm::bind::ScalarTemperatureData* valvebreakdowntemperature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(valvebreakdowntemperature_);
  }
  if (valvebreakdowntemperature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valvebreakdowntemperature)->GetArena();
    if (message_arena != submessage_arena) {
      valvebreakdowntemperature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valvebreakdowntemperature, submessage_arena);
    }
    
  } else {
    
  }
  valvebreakdowntemperature_ = valvebreakdowntemperature;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.ThermalCircuitPathData.ValveBreakdownTemperature)
}

// -------------------------------------------------------------------

// CircuitManagerData

// repeated .pulse.cdm.bind.ElectricalCircuitNodeData ElectricalNode = 1;
inline int CircuitManagerData::_internal_electricalnode_size() const {
  return electricalnode_.size();
}
inline int CircuitManagerData::electricalnode_size() const {
  return _internal_electricalnode_size();
}
inline void CircuitManagerData::clear_electricalnode() {
  electricalnode_.Clear();
}
inline ::pulse::cdm::bind::ElectricalCircuitNodeData* CircuitManagerData::mutable_electricalnode(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitManagerData.ElectricalNode)
  return electricalnode_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitNodeData >*
CircuitManagerData::mutable_electricalnode() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitManagerData.ElectricalNode)
  return &electricalnode_;
}
inline const ::pulse::cdm::bind::ElectricalCircuitNodeData& CircuitManagerData::_internal_electricalnode(int index) const {
  return electricalnode_.Get(index);
}
inline const ::pulse::cdm::bind::ElectricalCircuitNodeData& CircuitManagerData::electricalnode(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitManagerData.ElectricalNode)
  return _internal_electricalnode(index);
}
inline ::pulse::cdm::bind::ElectricalCircuitNodeData* CircuitManagerData::_internal_add_electricalnode() {
  return electricalnode_.Add();
}
inline ::pulse::cdm::bind::ElectricalCircuitNodeData* CircuitManagerData::add_electricalnode() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitManagerData.ElectricalNode)
  return _internal_add_electricalnode();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitNodeData >&
CircuitManagerData::electricalnode() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitManagerData.ElectricalNode)
  return electricalnode_;
}

// repeated .pulse.cdm.bind.ElectricalCircuitPathData ElectricalPath = 2;
inline int CircuitManagerData::_internal_electricalpath_size() const {
  return electricalpath_.size();
}
inline int CircuitManagerData::electricalpath_size() const {
  return _internal_electricalpath_size();
}
inline void CircuitManagerData::clear_electricalpath() {
  electricalpath_.Clear();
}
inline ::pulse::cdm::bind::ElectricalCircuitPathData* CircuitManagerData::mutable_electricalpath(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitManagerData.ElectricalPath)
  return electricalpath_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitPathData >*
CircuitManagerData::mutable_electricalpath() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitManagerData.ElectricalPath)
  return &electricalpath_;
}
inline const ::pulse::cdm::bind::ElectricalCircuitPathData& CircuitManagerData::_internal_electricalpath(int index) const {
  return electricalpath_.Get(index);
}
inline const ::pulse::cdm::bind::ElectricalCircuitPathData& CircuitManagerData::electricalpath(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitManagerData.ElectricalPath)
  return _internal_electricalpath(index);
}
inline ::pulse::cdm::bind::ElectricalCircuitPathData* CircuitManagerData::_internal_add_electricalpath() {
  return electricalpath_.Add();
}
inline ::pulse::cdm::bind::ElectricalCircuitPathData* CircuitManagerData::add_electricalpath() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitManagerData.ElectricalPath)
  return _internal_add_electricalpath();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitPathData >&
CircuitManagerData::electricalpath() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitManagerData.ElectricalPath)
  return electricalpath_;
}

// repeated .pulse.cdm.bind.ElectricalCircuitData ElectricalCircuit = 3;
inline int CircuitManagerData::_internal_electricalcircuit_size() const {
  return electricalcircuit_.size();
}
inline int CircuitManagerData::electricalcircuit_size() const {
  return _internal_electricalcircuit_size();
}
inline void CircuitManagerData::clear_electricalcircuit() {
  electricalcircuit_.Clear();
}
inline ::pulse::cdm::bind::ElectricalCircuitData* CircuitManagerData::mutable_electricalcircuit(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitManagerData.ElectricalCircuit)
  return electricalcircuit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitData >*
CircuitManagerData::mutable_electricalcircuit() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitManagerData.ElectricalCircuit)
  return &electricalcircuit_;
}
inline const ::pulse::cdm::bind::ElectricalCircuitData& CircuitManagerData::_internal_electricalcircuit(int index) const {
  return electricalcircuit_.Get(index);
}
inline const ::pulse::cdm::bind::ElectricalCircuitData& CircuitManagerData::electricalcircuit(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitManagerData.ElectricalCircuit)
  return _internal_electricalcircuit(index);
}
inline ::pulse::cdm::bind::ElectricalCircuitData* CircuitManagerData::_internal_add_electricalcircuit() {
  return electricalcircuit_.Add();
}
inline ::pulse::cdm::bind::ElectricalCircuitData* CircuitManagerData::add_electricalcircuit() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitManagerData.ElectricalCircuit)
  return _internal_add_electricalcircuit();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ElectricalCircuitData >&
CircuitManagerData::electricalcircuit() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitManagerData.ElectricalCircuit)
  return electricalcircuit_;
}

// repeated .pulse.cdm.bind.FluidCircuitNodeData FluidNode = 4;
inline int CircuitManagerData::_internal_fluidnode_size() const {
  return fluidnode_.size();
}
inline int CircuitManagerData::fluidnode_size() const {
  return _internal_fluidnode_size();
}
inline void CircuitManagerData::clear_fluidnode() {
  fluidnode_.Clear();
}
inline ::pulse::cdm::bind::FluidCircuitNodeData* CircuitManagerData::mutable_fluidnode(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitManagerData.FluidNode)
  return fluidnode_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitNodeData >*
CircuitManagerData::mutable_fluidnode() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitManagerData.FluidNode)
  return &fluidnode_;
}
inline const ::pulse::cdm::bind::FluidCircuitNodeData& CircuitManagerData::_internal_fluidnode(int index) const {
  return fluidnode_.Get(index);
}
inline const ::pulse::cdm::bind::FluidCircuitNodeData& CircuitManagerData::fluidnode(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitManagerData.FluidNode)
  return _internal_fluidnode(index);
}
inline ::pulse::cdm::bind::FluidCircuitNodeData* CircuitManagerData::_internal_add_fluidnode() {
  return fluidnode_.Add();
}
inline ::pulse::cdm::bind::FluidCircuitNodeData* CircuitManagerData::add_fluidnode() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitManagerData.FluidNode)
  return _internal_add_fluidnode();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitNodeData >&
CircuitManagerData::fluidnode() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitManagerData.FluidNode)
  return fluidnode_;
}

// repeated .pulse.cdm.bind.FluidCircuitPathData FluidPath = 5;
inline int CircuitManagerData::_internal_fluidpath_size() const {
  return fluidpath_.size();
}
inline int CircuitManagerData::fluidpath_size() const {
  return _internal_fluidpath_size();
}
inline void CircuitManagerData::clear_fluidpath() {
  fluidpath_.Clear();
}
inline ::pulse::cdm::bind::FluidCircuitPathData* CircuitManagerData::mutable_fluidpath(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitManagerData.FluidPath)
  return fluidpath_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitPathData >*
CircuitManagerData::mutable_fluidpath() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitManagerData.FluidPath)
  return &fluidpath_;
}
inline const ::pulse::cdm::bind::FluidCircuitPathData& CircuitManagerData::_internal_fluidpath(int index) const {
  return fluidpath_.Get(index);
}
inline const ::pulse::cdm::bind::FluidCircuitPathData& CircuitManagerData::fluidpath(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitManagerData.FluidPath)
  return _internal_fluidpath(index);
}
inline ::pulse::cdm::bind::FluidCircuitPathData* CircuitManagerData::_internal_add_fluidpath() {
  return fluidpath_.Add();
}
inline ::pulse::cdm::bind::FluidCircuitPathData* CircuitManagerData::add_fluidpath() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitManagerData.FluidPath)
  return _internal_add_fluidpath();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitPathData >&
CircuitManagerData::fluidpath() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitManagerData.FluidPath)
  return fluidpath_;
}

// repeated .pulse.cdm.bind.FluidCircuitData FluidCircuit = 6;
inline int CircuitManagerData::_internal_fluidcircuit_size() const {
  return fluidcircuit_.size();
}
inline int CircuitManagerData::fluidcircuit_size() const {
  return _internal_fluidcircuit_size();
}
inline void CircuitManagerData::clear_fluidcircuit() {
  fluidcircuit_.Clear();
}
inline ::pulse::cdm::bind::FluidCircuitData* CircuitManagerData::mutable_fluidcircuit(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitManagerData.FluidCircuit)
  return fluidcircuit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitData >*
CircuitManagerData::mutable_fluidcircuit() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitManagerData.FluidCircuit)
  return &fluidcircuit_;
}
inline const ::pulse::cdm::bind::FluidCircuitData& CircuitManagerData::_internal_fluidcircuit(int index) const {
  return fluidcircuit_.Get(index);
}
inline const ::pulse::cdm::bind::FluidCircuitData& CircuitManagerData::fluidcircuit(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitManagerData.FluidCircuit)
  return _internal_fluidcircuit(index);
}
inline ::pulse::cdm::bind::FluidCircuitData* CircuitManagerData::_internal_add_fluidcircuit() {
  return fluidcircuit_.Add();
}
inline ::pulse::cdm::bind::FluidCircuitData* CircuitManagerData::add_fluidcircuit() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitManagerData.FluidCircuit)
  return _internal_add_fluidcircuit();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::FluidCircuitData >&
CircuitManagerData::fluidcircuit() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitManagerData.FluidCircuit)
  return fluidcircuit_;
}

// repeated .pulse.cdm.bind.ThermalCircuitNodeData ThermalNode = 7;
inline int CircuitManagerData::_internal_thermalnode_size() const {
  return thermalnode_.size();
}
inline int CircuitManagerData::thermalnode_size() const {
  return _internal_thermalnode_size();
}
inline void CircuitManagerData::clear_thermalnode() {
  thermalnode_.Clear();
}
inline ::pulse::cdm::bind::ThermalCircuitNodeData* CircuitManagerData::mutable_thermalnode(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitManagerData.ThermalNode)
  return thermalnode_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitNodeData >*
CircuitManagerData::mutable_thermalnode() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitManagerData.ThermalNode)
  return &thermalnode_;
}
inline const ::pulse::cdm::bind::ThermalCircuitNodeData& CircuitManagerData::_internal_thermalnode(int index) const {
  return thermalnode_.Get(index);
}
inline const ::pulse::cdm::bind::ThermalCircuitNodeData& CircuitManagerData::thermalnode(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitManagerData.ThermalNode)
  return _internal_thermalnode(index);
}
inline ::pulse::cdm::bind::ThermalCircuitNodeData* CircuitManagerData::_internal_add_thermalnode() {
  return thermalnode_.Add();
}
inline ::pulse::cdm::bind::ThermalCircuitNodeData* CircuitManagerData::add_thermalnode() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitManagerData.ThermalNode)
  return _internal_add_thermalnode();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitNodeData >&
CircuitManagerData::thermalnode() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitManagerData.ThermalNode)
  return thermalnode_;
}

// repeated .pulse.cdm.bind.ThermalCircuitPathData ThermalPath = 8;
inline int CircuitManagerData::_internal_thermalpath_size() const {
  return thermalpath_.size();
}
inline int CircuitManagerData::thermalpath_size() const {
  return _internal_thermalpath_size();
}
inline void CircuitManagerData::clear_thermalpath() {
  thermalpath_.Clear();
}
inline ::pulse::cdm::bind::ThermalCircuitPathData* CircuitManagerData::mutable_thermalpath(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitManagerData.ThermalPath)
  return thermalpath_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitPathData >*
CircuitManagerData::mutable_thermalpath() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitManagerData.ThermalPath)
  return &thermalpath_;
}
inline const ::pulse::cdm::bind::ThermalCircuitPathData& CircuitManagerData::_internal_thermalpath(int index) const {
  return thermalpath_.Get(index);
}
inline const ::pulse::cdm::bind::ThermalCircuitPathData& CircuitManagerData::thermalpath(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitManagerData.ThermalPath)
  return _internal_thermalpath(index);
}
inline ::pulse::cdm::bind::ThermalCircuitPathData* CircuitManagerData::_internal_add_thermalpath() {
  return thermalpath_.Add();
}
inline ::pulse::cdm::bind::ThermalCircuitPathData* CircuitManagerData::add_thermalpath() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitManagerData.ThermalPath)
  return _internal_add_thermalpath();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitPathData >&
CircuitManagerData::thermalpath() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitManagerData.ThermalPath)
  return thermalpath_;
}

// repeated .pulse.cdm.bind.ThermalCircuitData ThermalCircuit = 9;
inline int CircuitManagerData::_internal_thermalcircuit_size() const {
  return thermalcircuit_.size();
}
inline int CircuitManagerData::thermalcircuit_size() const {
  return _internal_thermalcircuit_size();
}
inline void CircuitManagerData::clear_thermalcircuit() {
  thermalcircuit_.Clear();
}
inline ::pulse::cdm::bind::ThermalCircuitData* CircuitManagerData::mutable_thermalcircuit(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.CircuitManagerData.ThermalCircuit)
  return thermalcircuit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitData >*
CircuitManagerData::mutable_thermalcircuit() {
  // @@protoc_insertion_point(field_mutable_list:pulse.cdm.bind.CircuitManagerData.ThermalCircuit)
  return &thermalcircuit_;
}
inline const ::pulse::cdm::bind::ThermalCircuitData& CircuitManagerData::_internal_thermalcircuit(int index) const {
  return thermalcircuit_.Get(index);
}
inline const ::pulse::cdm::bind::ThermalCircuitData& CircuitManagerData::thermalcircuit(int index) const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.CircuitManagerData.ThermalCircuit)
  return _internal_thermalcircuit(index);
}
inline ::pulse::cdm::bind::ThermalCircuitData* CircuitManagerData::_internal_add_thermalcircuit() {
  return thermalcircuit_.Add();
}
inline ::pulse::cdm::bind::ThermalCircuitData* CircuitManagerData::add_thermalcircuit() {
  // @@protoc_insertion_point(field_add:pulse.cdm.bind.CircuitManagerData.ThermalCircuit)
  return _internal_add_thermalcircuit();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::ThermalCircuitData >&
CircuitManagerData::thermalcircuit() const {
  // @@protoc_insertion_point(field_list:pulse.cdm.bind.CircuitManagerData.ThermalCircuit)
  return thermalcircuit_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bind
}  // namespace cdm
}  // namespace pulse

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pulse_2fcdm_2fbind_2fCircuit_2eproto
